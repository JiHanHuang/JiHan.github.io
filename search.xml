<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>glusterfs系列-环境搭建</title>
      <link href="/2023/07/14/glusterfs%E7%B3%BB%E5%88%97-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/07/14/glusterfs%E7%B3%BB%E5%88%97-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>Glusterfs是一款分布式文件系统，相对配置简单，高性能，无单点故障，适合作为基础服务打包到产品或系统中，提供文件系统服务。<br>本文将进行Glusterfs的环境搭建(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em><a href="https://docs.gluster.org/en/latest/#split-brain" target="_blank" rel="noopener">Glusterfs官方文档</a></em><br><em><a href="https://github.com/gluster/glusterfs" target="_blank" rel="noopener">Glusterfs-github</a></em></p><a id="more"></a><h2 id="序"><a class="header-anchor" href="#序"></a>序</h2><p>本文的搭建环境：虚拟机，Ubuntu18，使用apt安装，需要root权限<br>准备3个节点，分别命名为server1，server2和server3.<br>每个节点需要额外挂载一个硬盘。</p><h2 id="安装"><a class="header-anchor" href="#安装"></a>安装</h2><h3 id="Glusterfs安装-apt"><a class="header-anchor" href="#Glusterfs安装-apt"></a>Glusterfs安装(apt)</h3><ol><li><p>运行以下命令在 server1上安装 software-properties-common。<br><code>apt-get install software-properties-common</code></p></li><li><p>添加社区 GlusterFS PPA。<br><code>add-apt-repository ppa:gluster/glusterfs-7</code></p></li><li><p>请确保使用的是最新安装包。<br><code>apt-get update</code></p></li><li><p>安装 GlusterFS 服务器。<br><code>apt-get install glusterfs-server -y</code></p></li><li><p>在机器上验证安装包版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glusterfs -V</span><br><span class="line">ps -ef | grep glusterd</span><br></pre></td></tr></table></figure><p><img src="/2023/07/14/glusterfs系列-环境搭建/glusterfs%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF.png" alt></p></li></ol><h3 id="Glusterfs安装-docker"><a class="header-anchor" href="#Glusterfs安装-docker"></a>Glusterfs安装(docker)</h3><ol start="0"><li><p>d<a href="https://docker-practice.github.io/zh-cn/install/ubuntu.html" target="_blank" rel="noopener">ocker安装</a></p></li><li><p>获取镜像：<br><code>docker pull ghcr.io/gluster/gluster-containers:centos</code><br>如果需要导入到其他设备安装：</p><ol><li>制作完成后，进行打包：<br><code># docker save aba01f181a4a &gt; /xxxx/glusterfs.image.tar</code></li><li>上传到新设备进行导入：<br><code># docker load &lt; glusterfs.image.tar</code></li><li>新导入的镜像，名称和tag都是空，打上标签：<br><code># docker tag 07c351837a3590f20 gluster/gluster-containers:centos</code></li><li>查看新设备的本地镜像<br><code># docker images</code></li></ol></li><li><p>启动glusterfs：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --name gluster \</span><br><span class="line">    -v /etc/glusterfs:/etc/glusterfs:z \</span><br><span class="line">    -v /var/lib/glusterd:/var/lib/glusterd:z \</span><br><span class="line">    -v /var/log/glusterfs:/var/log/glusterfs:z \</span><br><span class="line">    -v /sys/fs/cgroup:/sys/fs/cgroup:rw \</span><br><span class="line">    -d --privileged=true --net=host \</span><br><span class="line">    -v /data/glusterfs:/data/glusterfs \</span><br><span class="line">    gluster/gluster-containers:centos</span><br></pre></td></tr></table></figure><p>/data是额外的磁盘挂载点，/data/glusterfs是创建块路径的父目录</p></li><li><p>进入镜像，查看状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker exec -it gluster bash</span><br><span class="line">xxx # systemctl status glusterfs</span><br></pre></td></tr></table></figure></li></ol><h3 id="搭建Glusterfs集群"><a class="header-anchor" href="#搭建Glusterfs集群"></a>搭建Glusterfs集群</h3><p>节点的硬盘挂载到/data目录下。<br>首先只创建两个节点的集群，这里先将server1和server2关联成一个集群：</p><ol><li><p>在 server1上运行以下命令添加server2节点并创建集群。<br><code>gluster peer probe server2</code></p></li><li><p>验证集群中的所有节点均已成功连接。<br><code>gluster peer status</code><br><img src="/2023/07/14/glusterfs系列-环境搭建/glusterfs%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%812.png" alt><br><img src="/2023/07/14/glusterfs系列-环境搭建/glusterfs%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%811.png" alt></p></li><li><p>确认server1和server2挂载的硬盘，并创建对应的块路径： /data/glusterfs/rep<br><img src="/2023/07/14/glusterfs系列-环境搭建/glusterfs%E7%9B%98%E7%AC%A6%E6%8C%82%E8%BD%BD1.png" alt><br><img src="/2023/07/14/glusterfs系列-环境搭建/glusterfs%E7%9B%98%E7%AC%A6%E6%8C%82%E8%BD%BD2.png" alt></p></li><li><p>创建复制卷(2备份)，<a href="#glusterfs%E7%9A%84%E5%90%84%E7%A7%8D%E5%8D%B7">卷的讲解</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gluster volume create rep-vol replica 2 \</span><br><span class="line">server1:/data/glusterfs/rep server2:/data/glusterfs/rep</span><br></pre></td></tr></table></figure><p>如果是三备份，则需要三个磁盘块。如果是2备份，但是提供了4个磁盘块，则会自动创建为分布式复制卷。</p></li><li><p>启动分布式卷 rep-vol<br><code>gluster volume start rep-vol</code></p></li><li><p>查看状态：<br><code>gluster volume status</code><br><img src="/2023/07/14/glusterfs系列-环境搭建/glusterfs%E5%A4%8D%E5%88%B6%E5%8D%B7%E7%8A%B6%E6%80%81.png" alt></p></li></ol><h3 id="创建挂载点"><a class="header-anchor" href="#创建挂载点"></a>创建挂载点</h3><p>当我们完成上述glusterfs安装和集群创建后，基本完成了分布式文件系统搭建过程。而使用分布式文件系统，则需要把创建的卷挂载到需要使用的地方。挂载方式推荐使用系统的<code>mount</code>命令。<br><strong>不论是apt安装还是docker安装，都必须在主机上进行mount</strong>，docker中mount，并不会通过文件映射映射到本地上。但本机mount后，通过目录映射可以映射到docker中。<br>挂载命令(设置rep-vol的挂载点到/gfs，并通过server1节点访问)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t glusterfs server1:/rep-vol /gfs</span><br></pre></td></tr></table></figure><p><img src="/2023/07/14/glusterfs系列-环境搭建/glusterfs%E6%8C%82%E8%BD%BD%E7%82%B9%E9%85%8D%E7%BD%AE.png" alt><br>配置完成后，就可以通过/gfs访问glusterfs的分布式文件系统了。</p><h3 id="glusterfs的各种卷"><a class="header-anchor" href="#glusterfs的各种卷"></a>glusterfs的各种卷</h3><p>glusterfs中有多种卷类型，可根据实际情况选择卷类型进行使用</p><h4 id="分布式卷"><a class="header-anchor" href="#分布式卷"></a>分布式卷</h4><p>将文件通过hash算法分布在多个磁盘块上，文件没有冗余，但能充分利用磁盘空间<br><img src="/2023/07/14/glusterfs系列-环境搭建/glusterfs%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%B7.png" alt></p><h4 id="复制卷卷"><a class="header-anchor" href="#复制卷卷"></a>复制卷卷</h4><p>根据设置的备份数量，将文件划分成多个备份，存储到不同的节点上，读写时进行副本同步<br><img src="/2023/07/14/glusterfs系列-环境搭建/glusterfs%E5%A4%8D%E5%88%B6%E5%8D%B7.png" alt></p><h4 id="分布式复制卷"><a class="header-anchor" href="#分布式复制卷"></a>分布式复制卷</h4><p>是分布式卷和复制卷的融合，比如有4个节点，但是只设置了2备份，则总共有2份数据分布在4个节点上。<br><img src="/2023/07/14/glusterfs系列-环境搭建/glusterfs%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%8D%E5%88%B6%E5%8D%B7.png" alt></p><h4 id="条带卷"><a class="header-anchor" href="#条带卷"></a>条带卷</h4><p>数据分布类似分布式卷，但数据以条带方式一段段分布存储，以提高读写性能。<br><img src="/2023/07/14/glusterfs系列-环境搭建/glusterfs%E6%9D%A1%E5%B8%A6%E5%8D%B7.png" alt><br>同样还有分布式条带卷，就是在条带卷上增加分布式存储。同分布式复制卷一个原理</p><h3 id="总结"><a class="header-anchor" href="#总结"></a>总结</h3><p>至此，glusterfs的安装搭建就完成了，总体来说搭建过程还是比较简单的。</p><h4 id="参考"><a class="header-anchor" href="#参考"></a>参考</h4><p><a href="https://github.com/gluster/gluster-containers" target="_blank" rel="noopener">https://github.com/gluster/gluster-containers</a><br><a href="https://docker-practice.github.io/zh-cn/install/ubuntu.html" target="_blank" rel="noopener">https://docker-practice.github.io/zh-cn/install/ubuntu.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Glusterfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glusterfs系列-初探</title>
      <link href="/2023/07/14/glusterfs%E7%B3%BB%E5%88%97-%E5%88%9D%E6%8E%A2/"/>
      <url>/2023/07/14/glusterfs%E7%B3%BB%E5%88%97-%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>Glusterfs是一款分布式文件系统，相对配置简单，高性能，无单点故障，适合作为基础服务打包到产品或系统中，提供文件系统服务。<br>本文将初步介绍Glusterfs的一些特性和适用场景。(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em><a href="https://docs.gluster.org/en/latest/#split-brain" target="_blank" rel="noopener">Glusterfs官方文档</a></em><br><em><a href="https://github.com/gluster/glusterfs" target="_blank" rel="noopener">Glusterfs-github</a></em></p><a id="more"></a><h2 id="序"><a class="header-anchor" href="#序"></a>序</h2><p>分布式文件系统：<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/0" target="_blank" rel="noopener">分布式文件系统百度百科</a><br>一些需要使用分布式文件系统的情况：</p><ol><li>高可用场景，有一主一备需要同步一些文件。</li><li>集群情况，可靠性和容量限制，需要一个统一的文件系统接口，为多个服务器提供服务。</li><li>磁盘容量限制，或者可靠性要求，需要多台设备统一对外提供和普通文件系统一样的服务。</li></ol><h2 id="简介"><a class="header-anchor" href="#简介"></a>简介</h2><p>开源分布式横向扩展文件系统，可以根据存储需求快速调配存储，内含丰富的自动故障转移功能，且摈弃集中元数据服务器的思想。适用于数据密集型任务的可扩展网络文件系统，具有可扩展性、高性能、高可用性等特点。</p><h2 id="特性"><a class="header-anchor" href="#特性"></a>特性</h2><p>在选择一个分布式文件系统时，先明确需求，再看此分布式文件系统的特性师傅满足需求。<br>在此大致列出Glusterfs的一些特性：</p><table><thead><tr><th>功能点</th><th>GlusterFs</th></tr></thead><tbody><tr><td>分布式文件系统架构模式</td><td>去中心化</td></tr><tr><td>是否支持快照，和主动复制</td><td>支持主动复制和快照</td></tr><tr><td>恢复机制是副本机制还是纠删码</td><td>多副本机制</td></tr><tr><td>擅长处理的文件类型（大中小文件）</td><td>由于基于文件系统，对于大量小文件不友好</td></tr><tr><td>擅长处理的数据特性(写多，读多…)</td><td>适合静态数据(视频，音频)，无关系型数据</td></tr><tr><td>备份数据恢复方式</td><td>支持备份恢复，恢复时需要重新构建卷。</td></tr><tr><td>并发下读写如何处理，用锁机制还是actor模型</td><td>不保证数据强一致性，同时写入采用actor方式保证互斥。</td></tr><tr><td>支持的存储模式（对象存储，文件存储和块存储)</td><td>文件存储</td></tr><tr><td>是否需要支持事务</td><td>复制卷写入采用同步事务性操作。存在changelog</td></tr><tr><td>节点动态扩容支持，以及机制</td><td>Scale-Out架构和弹性hash都可以便捷进行扩容，支持容量扩展</td></tr><tr><td>活跃状态(社区活跃高，文档，star)</td><td>文档友好, 社区活跃度较低，4.1k star</td></tr><tr><td>部署维护便捷性</td><td>部署维护较为简单</td></tr><tr><td>性能</td><td>对于大文件读写有较好性能，主要限制取决于带宽</td></tr><tr><td>是否是轻量级</td><td>相对轻量</td></tr><tr><td>是否支持直接文件存储</td><td>是</td></tr><tr><td>已知可能存在的缺陷</td><td>基于Linux操作系统，跨系统很难支持</td></tr></tbody></table><h2 id="其他分布式文件系统"><a class="header-anchor" href="#其他分布式文件系统"></a>其他分布式文件系统</h2><p>​ 常见的分布式文件系统有，GFS、HDFS、Lustre 、Ceph 、GridFS 、mogileFS、TFS、FastDFS等。各自适用于不同的领域。它们都不是系统级的分布式文件系统，而是应用级的分布式文件存储服务。</p><ol><li><p><strong>GFS（Google File System）</strong><br>​ Google GFS文件系统，一个面向大规模数据密集型应用的、可伸缩的分布式文件系统。GFS虽然运行在廉价的普遍硬件设备上，但是它依然了提供灾难冗余的能力，为大量客户机提供了高性能的服务。GFS是一个为Google内部设计的大数据分布式存储框架，由2003年Google发表的论文提出，遗憾的是Google并没有将其开源，但是基于GFS的设计理念，诞生了很多优秀的开源类GFS文件系统。</p></li><li><p><strong>HDFS（Hadoop Distributed File System）</strong><br>​ HDFS是Hadoop（Apache开源项目）的专用文件系统， Hadoop是一个大数据计算框架，它允许使用简单的编程模型跨计算机集群分布式处理大型数据集，是Google发表的MapReduce算法的实现，HDFS是GFS的开源实现。</p></li><li><p><strong>Ceph</strong><br>​ Ceph是加州大学Santa Cruz分校的Sage Weil（DreamHost的联合创始人）专为博士论文设计的新一代自由软件分布式文件系统，并使用Ceph完成了他的论文。Ceph的主要目标是设计成基于POSIX的没有单点故障的分布式文件系统，使数据能容错和无缝的复制。与其它分布式文件系统相比，ceph 性能最高，因为其使用C++编写而成。 由于 ceph 使用 btrfs 文件系统， 而btrfs 文件系统需要 Linux 2.6.34 以上的内核才支持。自2007年毕业之后，Sage开始全职投入到Ceph开 发之中，使其能适用于生产环境，经过十几年的发展，Ceph已经趋向于成熟。</p></li><li><p><strong>Lustre</strong><br>​ Lustre是一个开源、分布式并行文件系统软件平台，具有高可扩展、高性能、高可用等特点。Lustre的构造目标是为大规模计算系统提供一个全局一致的POSIX兼容的命名空间，这些计算系统包括了世界上包含最强大的高性能计算系统。它支持数百PB数据存储空间，支持数百GB/s乃至数TB/s并发聚合带宽。</p></li><li><p><strong>GridFS</strong><br>GridFS 是MongDB的分布式存储系统，用于存储和恢复那些超过16M（BSON文件限制）的文件(如：图片、音频、视频等)。GridFS 也是文件存储的一种方式，但是它是存储在MonoDB的集合中。GridFS 可以更好的存储大于16M的文件。GridFS 会将大文件对象分割成多个小的chunk(文件片段),一般为256k/个,每个chunk将作为MongoDB的一个文档(document)被存储在chunks集合中。GridFS 用两个集合来存储一个文件：fs.files与fs.chunks。每个文件的实际内容被存在chunks(二进制数据)中,和文件有关的meta数据(filename,content_type,还有用户自定义的属性)将会被存在files集合中。</p></li><li><p><strong>MogileFS</strong><br>​ MogileFS是一个开源的分布式文件存储系统，是由LiveJournal旗下的Danga Interactive公司开发。目前使用MogileFS的公司非常多，如日本排名先前的几个互联公司以及国内的Yupoo(又拍)、digg、豆瓣、大众点评、搜狗等，分别为所在的组织或公司管理着海量的图片。以大众点评为例，用户全部图片均有MogileFS存储，数据量已经达到500TB以上</p></li><li><p><strong>FastDFS（Fast Distributed File System）</strong><br>​ FastDFS是一个开源的分布式文件系统，由纯C编写，性能很高。她对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。</p></li><li><p><strong>TFS（Taobao File System）</strong><br>​ TFS是一个高可扩展、高可用、高性能、面向互联网服务的分布式文件系统，主要针对海量的非结构化数据，它构筑在普通的Linux机器集群上，可为外部提供高可靠和高并发的存储访问。TFS为淘宝提供海量小文件存储，通常文件大小不超过1M，满足了淘宝对小文件存储的需求，被广泛地应用在淘宝各项应用中。它采用了HA架构和平滑扩容，保证了整个文件系统的可用性和扩展性。同时扁平化的数据组织结构，可将文件名映射到文件的物理地址，简化了文件的访问流程，一定程度上为TFS提供了良好的读写性能。</p></li></ol><h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2><p><a href="https://docs.gluster.org/en/latest/" target="_blank" rel="noopener">https://docs.gluster.org/en/latest/</a><br><a href="https://www.cnblogs.com/zhijiyiyu/p/15339674.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhijiyiyu/p/15339674.html</a><br><a href="https://www.hellodemos.com/hello-glusterfs/glusterfs-demos.html" target="_blank" rel="noopener">https://www.hellodemos.com/hello-glusterfs/glusterfs-demos.html</a><br><a href="https://blog.csdn.net/qq_37862148/article/details/113999206" target="_blank" rel="noopener">https://blog.csdn.net/qq_37862148/article/details/113999206</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Glusterfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活工作的工具推荐和选择指南</title>
      <link href="/2023/01/28/%E7%94%9F%E6%B4%BB%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%E5%92%8C%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/"/>
      <url>/2023/01/28/%E7%94%9F%E6%B4%BB%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%E5%92%8C%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>想要工作生活有条不紊的进行，免不了要借助一些工具，工具人(本人)给你提供了一点点关于工具选取和使用的建议呢(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　by JiHan</p><hr><a id="more"></a><h2 id="写在前面"><a class="header-anchor" href="#写在前面"></a>写在前面</h2><p>工具能使我们更好的学习，工作和生活，帮助我们解决一些问题。本文将包含以下内容，期望对您有所帮助：</p><ol><li>为何要使用工具</li><li>怎么从0到1选择工具</li><li>怎么选择好的工具</li><li>工具类别</li><li>个人工具推荐：笔记相关，计划相关，代办相关，文档相关…</li></ol><h2 id="为何使用工具"><a class="header-anchor" href="#为何使用工具"></a>为何使用工具</h2><h3 id="一个故事"><a class="header-anchor" href="#一个故事"></a>一个故事</h3><p>前几天，听一个朋友说，他有个弟弟，大学在读，假期太慢，就负责处理家里一部分小生意，也当是锻炼了。但是一天下来，搞得手忙脚乱，收货，货架整理，资金收支，一团乱麻。然后那个朋友就让他使用思维导图，把每一项列举出来，注意事项等。<br>后面他弟弟用了过后：“哇塞，简直太清晰了，我知道怎么把这个事情搞好了。你也太厉害了吧。”<br>我朋友，狗生第一次收到弟弟的赞扬（笑哭）</p><h3 id="工具的作用"><a class="header-anchor" href="#工具的作用"></a>工具的作用</h3><p>能帮助你脱离现在的困境，或者帮助你快速前行。有时候像你调到枯井里上面垂下的绳子，或者你跑半马时穿的跑鞋。是人类和动物的区别(狗头)</p><h2 id="工具的选择"><a class="header-anchor" href="#工具的选择"></a>工具的选择</h2><p>相信我，你遇到过的问题，别人都遇到过。但是别人中了彩票，你不一定中，哈哈<br>搜索引擎是21世纪最伟大的发明，也是我用的最多的软件。利用搜索软件(现在是个社交软件都有搜索引擎)看看和你有相同困境的人吧。</p><h3 id="从0到1选择工具"><a class="header-anchor" href="#从0到1选择工具"></a>从0到1选择工具</h3><h4 id="你的需求"><a class="header-anchor" href="#你的需求"></a>你的需求</h4><p>首先明确你的需求是什么，如果你老是丢三落四，那么你需求就是找个记忆的；如果你是自行车坏了，那你可能需要一个扳手。先明确自己的需求。</p><h4 id="选择适合的"><a class="header-anchor" href="#选择适合的"></a>选择适合的</h4><p>同类型的工具有很多，现在的时代，除非真的是自行车坏了，基本都是在依托手机工作和生活。因此明确需求过后，进行网上搜索，找到相关app进行下载和使用，选择一个用着最舒服，最合适的，<strong>是最合适的，而不是最好的</strong>。当然你不可能找到一个完全契合你的app，无妨，能够顺利解决问题就好。</p><h4 id="不轻易更换"><a class="header-anchor" href="#不轻易更换"></a>不轻易更换</h4><p>如果一个工具能顺利解决你所遇到的问题.并且使用比较舒适，就不要随意更换了，工具的使用和熟悉是需要成本的，同类工具的频繁更换只会浪费你的时间，而且新工具，多多少少还是有其他问题的。</p><h2 id="工具类型"><a class="header-anchor" href="#工具类型"></a>工具类型</h2><p>分类是个人随意想法分类的，不严谨也不全面，随便看看</p><h3 id="生活类"><a class="header-anchor" href="#生活类"></a>生活类</h3><ul><li>金钱 (支付宝，微信，各大行软件)</li><li>通信 (QQ，微信，手机本身，运营商软件)</li><li>外卖 (美团，饿了么)</li><li>影音娱乐 (网易云，腾讯视频，QQ音乐、哔哩哔哩)</li><li>出行 (百度地图，国航app)</li><li>辅助记忆：备忘录，TODO，笔记，日常记录</li><li>习惯养成：番茄时间，日常习惯打卡</li><li>学习：各类字典，阅读软件，视频软件，浏览器</li></ul><h3 id="工作类"><a class="header-anchor" href="#工作类"></a>工作类</h3><ul><li>文档 (word，wps)</li><li>通信 (钉钉，企业微信…)</li><li>人事软件 (OA, 邮箱…)</li><li>专业相关 (编程软件，绘图软件，设计软件…)</li><li>辅助类型：备忘，TODO，笔记，思维导图，时序图，浏览器</li></ul><h3 id="学习类"><a class="header-anchor" href="#学习类"></a>学习类</h3><ul><li>通信 (网课软件，聊天软件，浏览器)</li><li>阅读 (词典，浏览器，读书软件)</li><li>实体书或笔纸</li></ul><h3 id="个人推荐"><a class="header-anchor" href="#个人推荐"></a>个人推荐</h3><p>常见的软件，和娱乐类型的软件，我就不推荐了，大家都知道，我就列举一些能够更方便提升生活和学习质量的软件：</p><ul><li>印象笔记：主要用于笔记记录，支持跨平台，用了好些年了。你可以选择一个适合的软件，笔记软件有很多笔记积累，选好了基本不会换了，要谨慎。</li><li>坚果云：跨平台自动文档同步，文档相关数据同步很方便</li><li>怡养：坚果云同一公司，文档类型软件，包括思维导图，流程图，TODO，并且内嵌的word，excel，ppt（这个让我有些意外）</li><li>utools：电脑端效率提升工具，非常方便的去查找文件，启动程序，截图，图文转换等等，类似快捷的工具箱。支持插件化</li><li>vscode：主要文本编辑软件，和编程软件</li><li>朝暮计划：跨平台app，主要包含习惯养成，番茄时间，TODO表，备忘录等功能</li><li>护眼软件：苦逼社畜，不爱护眼睛，不注意身体。推荐一个根据时间动态调解平面亮度：<a href="https://justgetflux.com/" target="_blank" rel="noopener">f.lux</a>， 一个定时提醒你喝水休息的软件：<a href="http://www.fadetop.com/" target="_blank" rel="noopener">fadetop</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Diameter协议学习笔记</title>
      <link href="/2023/01/17/Diameter%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/17/Diameter%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>工作需要，了解以下Diameter协议以及应用场景(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em><a href="https://baike.baidu.com/item/Diameter?fromModule=lemma_search-box" target="_blank" rel="noopener">Diameter协议介绍</a></em><br><em><a href="https://www.rfc-editor.org/rfc/rfc3588.html" target="_blank" rel="noopener">RFC3588</a></em></p><a id="more"></a><h2 id="简介"><a class="header-anchor" href="#简介"></a>简介</h2><h3 id="协议简介"><a class="header-anchor" href="#协议简介"></a>协议简介</h3><p>Diameter协议是<a href="https://baike.baidu.com/item/RADIUS/3073981" target="_blank" rel="noopener">Radius</a>(<a href="https://www.rfc-editor.org/rfc/rfc2865" target="_blank" rel="noopener">RFC2865</a>)的下一代<a href="https://baike.baidu.com/item/AAA/150315?fromtitle=AAA%E5%8D%8F%E8%AE%AE&amp;fromid=1161567&amp;fromModule=lemma_search-box" target="_blank" rel="noopener">AAA协议</a>（AAA是认证（Authentication）、授权（Authorization）和计费（Accounting）的简称，是网络安全中进行访问控制的一种安全管理机制，提供认证、授权和计费三种安全服务。），主要用于移动IP、NAS请求和移动代理的认证、授权和计费工作。</p><p>其中主要的业界实现：一个基于diameter的资源的策略管理的接口<a href="https://www.arib.or.jp/english/html/overview/doc/STD-T63v9_40/5_Appendix/Rel10/29/29214-a60.pdf" target="_blank" rel="noopener">3GPP 29.214</a></p><h3 id="关联简介"><a class="header-anchor" href="#关联简介"></a>关联简介</h3><p><a href="https://baike.baidu.com/item/RADIUS/3073981" target="_blank" rel="noopener">Radius简介</a><br><a href="https://www.cnblogs.com/ranzhong/p/14410221.html" target="_blank" rel="noopener">RADIUS和Diameter</a><br><a href="https://support.huawei.com/enterprise/zh/doc/EDOC1100086522" target="_blank" rel="noopener"><strong>RADIUS如何工作</strong></a>，文章比较详细的介绍了Radius的工作原理和场景<br><a href="https://blog.csdn.net/iteye_7332/article/details/82485179" target="_blank" rel="noopener">Diameter 协议详解</a><br><a href="https://baike.baidu.com/item/pap/4760747" target="_blank" rel="noopener">密码认证协议（PAP）</a></p><h2 id="Diameter的RFC标准"><a class="header-anchor" href="#Diameter的RFC标准"></a>Diameter的RFC标准</h2><h2 id="Radius环境搭建及使用"><a class="header-anchor" href="#Radius环境搭建及使用"></a>Radius环境搭建及使用</h2><h2 id="Diameter环境搭建及使用"><a class="header-anchor" href="#Diameter环境搭建及使用"></a>Diameter环境搭建及使用</h2><h2 id="业界实现环境搭建和使用"><a class="header-anchor" href="#业界实现环境搭建和使用"></a>业界实现环境搭建和使用</h2><h2 id="业界实现的源码阅读"><a class="header-anchor" href="#业界实现的源码阅读"></a>业界实现的源码阅读</h2><h2 id="Diameter在具体场景中的应用"><a class="header-anchor" href="#Diameter在具体场景中的应用"></a>Diameter在具体场景中的应用</h2><h2 id="其他"><a class="header-anchor" href="#其他"></a>其他</h2>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diameter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《万历十五年》读书笔记</title>
      <link href="/2023/01/16/%E3%80%8A%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/16/%E3%80%8A%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>与其说是笔记，不如说是读后感。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><a id="more"></a><p>最开始因为推荐看这本书，推荐理由大概是：书中采用了独特的视角看待历史，用一种大历史观去评判历史。按照这种推荐，我尝试看了看，期初，我并没有感到什么是大历史观，书中章节通过几大人物为切入点来描述万历年间的历史，而我看到的这些人物，都是普普通通的人，感觉很是平凡，没有对清官的称赞，没有对改革者功绩的肯定，没有对大将军的夸赞。感觉他们只是尽力而为的普通人，都郁郁而终。<br>从对万历皇帝的描述，我感受到了一个从孩童懵懂-&gt;少年的励志-&gt;青年的壮志-&gt;中年的摆烂。年少的皇帝，九岁即位，上有母后，师长，下有群臣百姓。没有快乐的童年，年少即位，对于很多事情都依赖师长——张居正。少年时期努力学习，青年时期跟随张居正开始尝试改革；张居正死后，由于立太子的心愿无法达成，加上从小到大文官对自己的约束，而又无力改变。开始摆烂。<br>而张居正，则是一心想要进行改革的人，虽然书中对他的描写并感觉不到什么赞扬。可惜整个经济体制的结构，时代限制，文官集团限制，最后改革也并未成功，死前奉为太师，死后差点挖坟。<br>申时行则因为张居正的前车之鉴，加上自己又受张居正提携。他做首辅之时，则不敢大刀阔斧的改革，而是想采用中庸的办法来缓解朝廷内部的矛盾，按我们现在的话说，就是和事老。<br>而海瑞的描述，感觉就是一个偏执的人，一丝不苟正直的作风，有股出淤泥而不染的作风。但可惜的是，他想让这摊浑水变清澈。<br>我从其他地方得知的戚继光，完美抗倭英雄；用兵如神的大将军。而这里面，他的确非常有带兵打仗的军事天赋，并且能够在有限的条件下达到如此成就，也的确不凡。可惜也随着张居正倒台随之郁郁不得志了。<br>李贽说是一个哲学家，不如说一个空想家。好在有些才华，不然感觉很难混下去。按作者的说法，他最大的功绩在于：我们又多了一个视角看待当时的世界。<br>总体来说，上面六人，都是有心想要做出改革的人。张居正和申时行作为政治家，想通过政策改变来改变明朝当时的现状，海瑞也是同样如此。戚继光则想壮大国家的军事实力，万历皇帝当然想得到“尧舜之帝”的称颂；李贽则想从思想层面来找出道路。无一例外都失败了，和万历皇帝的“摆烂”关系不大，和张居正的“贪腐”关系不大，和申时行的“不作为”关系不大，和海瑞“刚愎自用”的改革关系不大，当然和李贽不切实际的哲学理论关系更不大了。关键在于当时整个社会固化的小农经济体制，对商业的不重视，以道德代替法律的政治框架导致。<br>直到最后，我才渐渐明白这就是大历史观，历史的兴衰不在乎个人的英明或贪腐，而在整个社会形态(意识和经济基础)和政治体系是否脱节，个人的作用往往只能减缓或加速这一进程。而作者之所以专门拿出万历十五年来写(每个朝代都存在这种脱节)，估计是万历年间是中国在世界的地位由胜到衰的转折点吧。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《C++ Primer Plus》读书笔记</title>
      <link href="/2023/01/16/%E3%80%8AC-Primer-Plus%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/16/%E3%80%8AC-Primer-Plus%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>从C开发转到C++的初学者(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>主题： C++入门相关书籍<br>类别：计算机-&gt;实用性+理论性论述书-&gt;nginx<br>概要：从模块开发了解nginx的使用以及nginx整体结构。从源码原理解析了解nginx底层设计和各种优化操作。</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>作者想通过文章帮助人们了解nginx的模块开发，和其内部实现原理。<br>而我也想进行nginx源码学习，了解其中的实现原理和架构，以及一些实现亮点。</p><h2 id="主旨"><a class="header-anchor" href="#主旨"></a>主旨</h2><h3 id="文章的核心内容"><a class="header-anchor" href="#文章的核心内容"></a>文章的核心内容</h3><h4 id="核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。"><a class="header-anchor" href="#核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。"></a>核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。</h4><h3 id="整本书的架构"><a class="header-anchor" href="#整本书的架构"></a>整本书的架构</h3><h4 id="作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。"><a class="header-anchor" href="#作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。"></a>作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。</h4><h3 id="问题处理"><a class="header-anchor" href="#问题处理"></a>问题处理</h3><h4 id="作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。"><a class="header-anchor" href="#作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。"></a>作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。</h4><h2 id="章节"><a class="header-anchor" href="#章节"></a>章节</h2><h3 id="nginx模块开发"><a class="header-anchor" href="#nginx模块开发"></a>nginx模块开发</h3><p>该模块主要进行nginx整体架构的初步介绍，并指导进行相关的实践操作，进行相关模块开发。</p><h4 id><a class="header-anchor" href="#"></a></h4><h3 id="nginx原理"><a class="header-anchor" href="#nginx原理"></a>nginx原理</h3><p>从架构深入到内部实现，讲解nginx源码的各个模块的关键设计。需要配合源码来进行阅读。</p><h4 id="-v2"><a class="header-anchor" href="#-v2"></a></h4><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><h3 id="所得"><a class="header-anchor" href="#所得"></a>所得</h3><h4 id="作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？"><a class="header-anchor" href="#作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？"></a>作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？</h4><h3 id="所想"><a class="header-anchor" href="#所想"></a>所想</h3><h4 id="看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。"><a class="header-anchor" href="#看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。"></a>看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。</h4><h3 id="相关"><a class="header-anchor" href="#相关"></a>相关</h3><h4 id="可以列出相关的看过的书籍，或者问题参考链接网页一类的。"><a class="header-anchor" href="#可以列出相关的看过的书籍，或者问题参考链接网页一类的。"></a>可以列出相关的看过的书籍，或者问题参考链接网页一类的。</h4>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144 计算机网络笔记</title>
      <link href="/2022/11/12/CS144-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/12/CS144-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>补足一下计算机网络知识(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>主题：计算机网络<br>类别：计算机-&gt;原理性+实用性-&gt;计算机网络<br>概要：更加系统的学习计算机网络，并完成相应的实验</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>计算机网络知识一直比较欠缺，并且没有系统学习过。工作后发现很多地方都是一知半解，故重新学习。<br><code>CS144</code>也是比较知名的计算机网络公开课，主要是搭配了对应的lab，从学习到实践深度理解。<br><a href="https://cs144.github.io/" target="_blank" rel="noopener">CS144课程主页</a><br><a href="https://www.bilibili.com/video/BV1e5411c7aY/" target="_blank" rel="noopener">bilibili课程视频</a></p><p><em>课程lab是基于C++和linux平台的，这些都是前置的基础知识</em></p><h2 id="课程学习"><a class="header-anchor" href="#课程学习"></a>课程学习</h2><p>如果只看视频课程，估计没有几分钟就睡着了。建议看几节课程后开始进行对应的lab，如果有对应的网络基础，可以直接进行lab。</p><h3 id="基础课程-lab0"><a class="header-anchor" href="#基础课程-lab0"></a>基础课程+lab0</h3><h4 id="基础课程"><a class="header-anchor" href="#基础课程"></a>基础课程</h4><p>课程基础，以上面bilibili的视频为例，学完P0-Pxx基本就可以开始lab0了</p><h4 id="lab0"><a class="header-anchor" href="#lab0"></a>lab0</h4><p><a href="https://cs144.github.io/assignments/lab0.pdf" target="_blank" rel="noopener">lab0 指导手册</a><br>英文不好的(比如我)，有点耐心慢慢看就好。<br>lab0中主要使用c<ins>作为主要开发语言，而且采用了比较严格的c</ins>的语法，还是需要一定的基础的。</p><h4 id="lab1"><a class="header-anchor" href="#lab1"></a>lab1</h4><p><a href="https://cs144.github.io/assignments/lab1.pdf" target="_blank" rel="noopener">lab1 指导手册</a></p><h3 id="观点2"><a class="header-anchor" href="#观点2"></a>观点2</h3><h3 id="观点3"><a class="header-anchor" href="#观点3"></a>观点3</h3><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><h3 id="延展"><a class="header-anchor" href="#延展"></a>延展</h3><h4 id="作者所提出的问题，是否就是你真正想问的问题？是否有必要进行分析阅读？理由？"><a class="header-anchor" href="#作者所提出的问题，是否就是你真正想问的问题？是否有必要进行分析阅读？理由？"></a>作者所提出的问题，是否就是你真正想问的问题？是否有必要进行分析阅读？理由？</h4><h3 id="相关"><a class="header-anchor" href="#相关"></a>相关</h3><h4 id="可以列出相关的看过的书籍，或者问题参考链接网页一类的。"><a class="header-anchor" href="#可以列出相关的看过的书籍，或者问题参考链接网页一类的。"></a>可以列出相关的看过的书籍，或者问题参考链接网页一类的。</h4>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux进程通信及示例</title>
      <link href="/2022/08/03/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8F%8A%E7%A4%BA%E4%BE%8B/"/>
      <url>/2022/08/03/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8F%8A%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>介绍linux进程通信的几种方式，以及每一种方式的适用场景。并给出了相应示例。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>需要一定linux的使用背景以及C语言基础。<br><strong>什么是进程通信：</strong><br>进程间通信(InterProcess Communication, IPC)是指在不同进程之间传播或交换信息。<br>IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享内存、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。本文只针对经典的IPC，即：管道、消息队列、信号量及共享内存。</p><h2 id="进程通信"><a class="header-anchor" href="#进程通信"></a>进程通信</h2><h3 id="管道"><a class="header-anchor" href="#管道"></a>管道</h3><p>我们常说的管道，都指匿名管道，FIFO通常会用命名管道一词<br>管道的使用会存以下两个限制：</p><ol><li>管道的通信都是半双工的(即数据只能在一个方向流动)</li><li>管道只能在具有公共祖先的两个进程之间通信。通常一个管道进程<code>fork</code>出子进程后，管道就能在父子进程之间通信了。</li></ol><p>管道创建函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p><code>fd[0]</code>为读打开，即输出，<code>fd[1]</code>为写打开，即为输入。一个典型的工作场景：<br>即进程先调用<code>pipe</code>，再进行<code>fork</code><br><img src="/2022/08/03/linux进程通信及示例/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E7%A4%BA%E4%BE%8B.jpg" alt><br>然后我们根据需要各自关闭父子进程的读/写通道。<br><img src="/2022/08/03/linux进程通信及示例/%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%88%B0%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%A1%E9%81%93.jpg" alt></p><h5 id="示例"><a class="header-anchor" href="#示例"></a>示例</h5><p>我们在程序中需要执行一个命令，并且获得命令输出的结果。比如我们要执行<code>date</code>命令:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUN_CMD <span class="meta-string">"/usr/bin/date"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">char</span> output[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123; <span class="comment">//parent</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (read(fd[<span class="number">0</span>], output, <span class="keyword">sizeof</span>(output)<span class="number">-1</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read error"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parent:\n%s"</span>, output);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//child</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        execv(RUN_CMD, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./main </span><br><span class="line">Parent:</span><br><span class="line">Wed Aug  3 16:10:57 CST 2022</span><br></pre></td></tr></table></figure><p><code>execv</code>函数<a href="https://linux.die.net/man/3/execv" target="_blank" rel="noopener">参考</a><br>当然上述功能也可以用<a href="https://www.man7.org/linux/man-pages/man3/popen.3.html" target="_blank" rel="noopener">popen</a>函数实现。更加简单。</p><h5 id="适用场景"><a class="header-anchor" href="#适用场景"></a>适用场景</h5><p>由于管道的限制，常常用于父进程和子进程之间的通信。<br>最为常见的应用就是<code>shell</code>中使用的<code>|</code>管道符了。</p><h3 id="命名管道"><a class="header-anchor" href="#命名管道"></a>命名管道</h3><p>命名管道(FIFO)，相比于管道来说，他的限制只有一个：</p><ol><li>通信都是半双工的(即数据只能在一个方向流动)</li></ol><p>这就意味着它能用于不相干的进行之间进行数据通信。<br>FIFO本质上就是一种文件类型，可通过查看文件的<code>stat</code>结构中的<code>st_mode</code>编码得知。比如FIFO文件，我们执行<code>stat file.name</code>会看到<code>fifo</code>字样。<br>FIFO创建函数(有点类似文件创建):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__path, <span class="keyword">__mode_t</span> __mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span> <span class="params">(<span class="keyword">int</span> __fd, <span class="keyword">const</span> <span class="keyword">char</span> *__path, <span class="keyword">__mode_t</span> __mode)</span></span>;</span><br><span class="line"><span class="comment">//函数返回值成功为0，错误为-1</span></span><br></pre></td></tr></table></figure><p><code>mkfifo</code>函数与<code>open</code>函数类似。<br><code>mkfifoat</code>函数则用来在<code>fd</code>文件描述符表示的目录相关的位置创建一个FIFO<br><em>函数具体参数可参考<a href="https://man7.org/linux/man-pages/man3/mkfifo.3.html" target="_blank" rel="noopener">man手册</a></em></p><p>我们也可以可以通过<code>mkfifo</code>命令来创建FIFO文件<br>同样，对FIFO的读写操作，类似于对文件的读写。<br>当<code>open</code>一个FIFO文件时，可指定是否阻塞：<code>O_NONBLOCK</code>标记。</p><ul><li>不指定：读/写都会阻塞，直到有对应的写/读到来</li><li>指定：如果读/写时没有对应的写/读，会返回相应的错误码</li></ul><p>如果是多个进程进行写操作，为了防止写入数据交叉，需要设置操作原子性，<code>PIPE_BUF</code>就是对应原子性数据的大小。<br>我们常常遇到的一种情况：<br><img src="/2022/08/03/linux进程通信及示例/FIFO%E7%A4%BA%E4%BE%8B.jpg" alt></p><h5 id="示例-v2"><a class="header-anchor" href="#示例-v2"></a>示例</h5><p>我们创建两个子进程写入数据，父进程读出数据(当然不一定要父子进程)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> fifo_file[] = <span class="string">"/tmp/fifo_file"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pid1=<span class="number">0</span>, pid2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    mkfifo(fifo_file,O_CREAT |O_RDWR);</span><br><span class="line">    pid1 = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid1  &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        pid2 = fork();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid1 &gt; <span class="number">0</span> &amp;&amp; pid2 &gt; <span class="number">0</span> )&#123; <span class="comment">//parent</span></span><br><span class="line">        <span class="comment">// 读写方式打开，read函数则会阻塞，一直等待数据来临</span></span><br><span class="line">        <span class="comment">// 只读方式打开，则子进程写完(也可能没写完)，read函数返回0值，退出</span></span><br><span class="line">        <span class="comment">//fd = open(fifo_file, O_RDWR);</span></span><br><span class="line">        fd = open(fifo_file, O_RDONLY);</span><br><span class="line">        <span class="comment">//确保2个进程都写完</span></span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        waitpid(pid1,&amp;status,<span class="number">0</span>);</span><br><span class="line">        waitpid(pid2,&amp;status,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (read(fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read:%s"</span>, buf);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid1 &lt; <span class="number">0</span> || pid2 &lt; <span class="number">0</span>) &#123; <span class="comment">//error</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//children</span></span><br><span class="line">        fd = open(fifo_file, O_WRONLY);</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">"hello: %d, %d\n"</span>,pid1, pid2);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./main </span><br><span class="line">read:hello: 0, 0</span><br><span class="line">hello: 17967, 0</span><br></pre></td></tr></table></figure><p>也可以用命令行达到上面的效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello1"</span> &gt;&gt; fifo &amp;</span></span><br><span class="line">[1] 30040</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello2"</span> &gt;&gt; fifo &amp;</span></span><br><span class="line">[2] 30041</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat fifo </span></span><br><span class="line">hello1</span><br><span class="line">hello2</span><br><span class="line">[1]-  Done                    echo "hello1" &gt;&gt; fifo</span><br><span class="line">[2]+  Done                    echo "hello2" &gt;&gt; fifo</span><br></pre></td></tr></table></figure><p>注意，使用命令的时候，都是阻塞的，读写不需同时存在，否则会阻塞。</p><h5 id="适用场景-v2"><a class="header-anchor" href="#适用场景-v2"></a>适用场景</h5><ol><li>数据缓冲，缓存来不及处理的数据。</li><li>时钟域隔离。</li><li>用于不同宽度的数据接口。</li></ol><p><em>后两种可参考网上解释</em></p><h3 id="消息队列"><a class="header-anchor" href="#消息队列"></a>消息队列</h3><p>消息队列是消息的链接表，存储在内核中，有消息队列表示符标识。<br>意味着内核里有现成的消息队列，让你可直接使用。<br><code>msgget</code>则是创建或者打开一个现有队列。<a href="https://man7.org/linux/man-pages/man2/msgget.2.html" target="_blank" rel="noopener">msgget详解</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span> <span class="params">(<span class="keyword">key_t</span> __key, <span class="keyword">int</span> __msgflg)</span></span>;</span><br></pre></td></tr></table></figure><p>每个队列都包含一个<code>msqid_ds</code>的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span><span class="comment">/* structure describing operation permission */</span></span><br><span class="line">  <span class="keyword">__time_t</span> msg_stime;<span class="comment">/* time of last msgsnd command */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __x86_64__</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __unused1;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">__time_t</span> msg_rtime;<span class="comment">/* time of last msgrcv command */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __x86_64__</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __unused2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">__time_t</span> msg_ctime;<span class="comment">/* time of last change */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __x86_64__</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __unused3;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">__syscall_ulong_t</span> __msg_cbytes; <span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">  <span class="keyword">msgqnum_t</span> msg_qnum;<span class="comment">/* number of messages currently on queue */</span></span><br><span class="line">  <span class="keyword">msglen_t</span> msg_qbytes;<span class="comment">/* max number of bytes allowed on queue */</span></span><br><span class="line">  <span class="keyword">__pid_t</span> msg_lspid;<span class="comment">/* pid of last msgsnd() */</span></span><br><span class="line">  <span class="keyword">__pid_t</span> msg_lrpid;<span class="comment">/* pid of last msgrcv() */</span></span><br><span class="line">  <span class="keyword">__syscall_ulong_t</span> __unused4;</span><br><span class="line">  <span class="keyword">__syscall_ulong_t</span> __unused5;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以通过<code>msgctl</code>函数获取或设置<code>msqid_ds</code>操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span> <span class="params">(<span class="keyword">int</span> __msqid, <span class="keyword">int</span> __cmd, struct msqid_ds *__buf)</span></span>;</span><br></pre></td></tr></table></figure><p>可以使用<code>msgsnd</code>来添加消息到队列尾，使用<code>msgrcv</code>获取消息，当然不一定要先入先出，也可以按照消息类型来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span> <span class="params">(<span class="keyword">int</span> __msqid, <span class="keyword">const</span> <span class="keyword">void</span> *__msgp, <span class="keyword">size_t</span> __msgsz,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> __msgflg)</span></span>;<span class="comment">//成功:0，失败:-1</span></span><br><span class="line"><span class="keyword">ssize_t</span> msgrcv (<span class="keyword">int</span> __msqid, <span class="keyword">void</span> *__msgp, <span class="keyword">size_t</span> __msgsz,</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> __msgtyp, <span class="keyword">int</span> __msgflg);<span class="comment">//成功:接收字符长度，失败:-1</span></span><br></pre></td></tr></table></figure><p>同样可以通过设置<code>__msgflg</code>来确定是阻塞还是非阻塞IO操作。<br><code>msgsnd</code>中的<code>__msgp</code>可以是如下结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mymesg</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> msgtyp;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">512</span>]; <span class="comment">//对应着__msgsz的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中队列的最大消息数是根据最大队列数和最大数据量来决定的。可以通过<code>msqid_ds</code>中的<code>msg_qbytes</code>得知</p><h5 id="示例-v3"><a class="header-anchor" href="#示例-v3"></a>示例</h5><p>还是常见示例，做一个父子进程的消峰值处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> msg_bytes 512</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> type;</span><br><span class="line">    <span class="keyword">char</span> text[msg_bytes];</span><br><span class="line">&#125; msg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid, pid1=<span class="number">0</span>, pid2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret,msgid;</span><br><span class="line"></span><br><span class="line">    msgid = msgget(IPC_PRIVATE,<span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"msgget error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pid1 = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid1  &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        pid2 = fork();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid1 &gt; <span class="number">0</span> &amp;&amp; pid2 &gt; <span class="number">0</span> )&#123; <span class="comment">//parent</span></span><br><span class="line">        pid = getpid();</span><br><span class="line">        msg tmp;</span><br><span class="line">        <span class="comment">//阻塞方式</span></span><br><span class="line">        <span class="comment">//while ((ret = msgrcv(msgid, (void *)&amp;tmp, msg_bytes, 1, 0)) &gt; 0)&#123;</span></span><br><span class="line">        <span class="comment">//非阻塞方式</span></span><br><span class="line">        <span class="keyword">while</span> ((ret = msgrcv(msgid, (<span class="keyword">void</span> *)&amp;tmp, msg_bytes, <span class="number">1</span>, IPC_NOWAIT)))&#123;</span><br><span class="line">            <span class="keyword">if</span> ((ret &lt; <span class="number">0</span>) &amp;&amp; (errno != ENOMSG)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d, %d read:%s\n"</span>, pid, ret, tmp.text);</span><br><span class="line">            <span class="built_in">memset</span>(&amp;tmp.text, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp.text));</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"msg receive over. %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        waitpid(pid1,&amp;status,<span class="number">0</span>);</span><br><span class="line">        waitpid(pid2,&amp;status,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent process[%d] exit\n"</span>, pid);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid1 &lt; <span class="number">0</span> || pid2 &lt; <span class="number">0</span>) &#123; <span class="comment">//error</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//children</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        pid = getpid();</span><br><span class="line">        msg tmp = &#123;.type = <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">            tmp.type = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">sprintf</span>(tmp.text, <span class="string">"hello: %d, N:%d\n"</span>, pid, i);</span><br><span class="line">            <span class="keyword">if</span> ((ret = msgsnd(msgid, &amp;tmp, msg_bytes, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"msg send error:%s\n"</span>,strerror(errno));</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;tmp.text, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp.text));</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process[%d] exit\n"</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="适用场景-v3"><a class="header-anchor" href="#适用场景-v3"></a>适用场景</h5><p>从速度上来说，<code>消息队列</code>和<code>unix sock</code>并没有太大差别，消息队列的主要用途：</p><ol><li>应用解耦</li><li>异步消息</li><li>流量削锋</li></ol><h3 id="信号量"><a class="header-anchor" href="#信号量"></a>信号量</h3><p>和之前的<code>IPC</code>不同，信号量是一个计数器，用于为多个进程提供共享数据对象的访问。</p><h5 id="示例-v4"><a class="header-anchor" href="#示例-v4"></a>示例</h5><h5 id="适用场景-v4"><a class="header-anchor" href="#适用场景-v4"></a>适用场景</h5><h3 id="共享内存"><a class="header-anchor" href="#共享内存"></a>共享内存</h3><h5 id="简介"><a class="header-anchor" href="#简介"></a>简介</h5><h5 id="示例-v5"><a class="header-anchor" href="#示例-v5"></a>示例</h5><h5 id="适用场景-v5"><a class="header-anchor" href="#适用场景-v5"></a>适用场景</h5><h2 id="各个进程通信比较"><a class="header-anchor" href="#各个进程通信比较"></a>各个进程通信比较</h2><h3 id="进程对于共享资源的访问互斥方式"><a class="header-anchor" href="#进程对于共享资源的访问互斥方式"></a>进程对于共享资源的访问互斥方式</h3><ol><li>信号量，就是标记共享资源还有多少可使用，使用了就-1。本质上就是存在于内核的一个计数器，可以通过<code>semget</code>系列函数来获取信号量。</li><li>使用记录锁，即创建一个空文件，并用改文件的第一个字节(不一定存在)作为锁字节。获取和释放资源时会进行写锁和释放锁。进程终止时，内核会自动释放该锁。</li><li>互斥量，需要将共享资源加载到内存，互斥量在文件的相同偏移出初始化互斥量。</li></ol><h4 id="区别和比较"><a class="header-anchor" href="#区别和比较"></a>区别和比较</h4><p>性能：信号量和记录锁的性能差别不大，互斥量则有量级的性能提升。<br>这里通常使用的还是记录锁，信号量相比记录锁操作更为繁琐，而互斥量的稳定性和适配则不如记录锁。除非异常追求性能，不然通常都选择记录锁。</p><h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/qq_44443986/article/details/115065540" target="_blank" rel="noopener">Linux 进程间通信(IPC)—大总结</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SSL体系理解</title>
      <link href="/2022/07/27/SSL%E4%BD%93%E7%B3%BB%E7%90%86%E8%A7%A3/"/>
      <url>/2022/07/27/SSL%E4%BD%93%E7%B3%BB%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>从整体上理解ssl干了什么事情，证书又起什么作用。只关注功能流程，不关注细节实现(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><a id="more"></a><h3 id="背景"><a class="header-anchor" href="#背景"></a>背景</h3><h4 id="本文目的"><a class="header-anchor" href="#本文目的"></a>本文目的</h4><p>主要从整体流程上介绍<code>ssl</code>的作用，<code>证书</code>作用，从大体上对<code>证书和ssl</code>有一定理解</p><h4 id="背景知识"><a class="header-anchor" href="#背景知识"></a>背景知识</h4><ol><li>基础网络知识，类似TCP/IP</li><li>常见加密算法类型，了解<a href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/2152944" target="_blank" rel="noopener">对称加密</a>和<a href="https://blog.csdn.net/u014294681/article/details/86705999" target="_blank" rel="noopener">非对称加密</a></li></ol><h4 id="主要涉及"><a class="header-anchor" href="#主要涉及"></a>主要涉及</h4><ul><li><strong>SSL</strong>： 主要用于<strong>加密</strong>和<strong>鉴别</strong></li><li><strong>使用场景</strong>： 常见基于<code>TCP</code>协议上，使用<code>TCP+SSL</code>协议构成<code>TLS</code>协议。基于<code>TLS</code>上传输<code>HTTP</code>报文行程了<code>HTTPS</code></li><li><strong>RSA</strong>： 非对称加密的一种算法，主要用于SSL中报文私钥的生成。</li><li><strong>证书</strong>： 主要用于SSL握手中对对方身份的鉴别</li></ul><h3 id="HTTPS的握手流程"><a class="header-anchor" href="#HTTPS的握手流程"></a>HTTPS的握手流程</h3><p>HTTPS本质是在TLS上传输数据，那么从通信开始，到正式传输数据要经历三个阶段：</p><pre class="mermaid">graph TDA(TCP 3次握手)B(RSA秘钥交换)C(用秘钥加密数据)A --> BB -- 生成对称秘钥 --> CclassDef orange fill:#f96,stroke:#333,stroke-width:4px;class B orange</pre><p><strong>TIPS：</strong><br>问： 为何要用RSA秘钥交换<br>答：非对称加密算法的保密性好，不需要交换秘钥</p><p>问：为何用对称秘钥加密数据通信<br>答：因为快</p><p>其中关键的一步就是<strong>RSA秘钥交换</strong><br><img src="/2022/07/27/SSL体系理解/ssl%E9%80%9A%E4%BF%A1.png" alt="HTTPS流程"><br><em>图片源于网络(具体引用路径忘了)</em></p><p><strong>TIPS：</strong></p><ol><li>服务器中的公钥和私钥，主要用于协商生成随机秘钥(后续数据通信的对称秘钥)</li><li>此流程中，客户端会验证服务端发送的公钥，通常这个公钥就包含在我们常见的证书中。</li><li>此流程是常见的简单流程，涉及到双向校验等更复杂的流程，可自行研究。</li></ol><p>那么这里的公钥，即证书是怎么颁发的呢？证书结构如何呢？<br>这就涉及到我们第二个内容</p><h3 id="证书"><a class="header-anchor" href="#证书"></a>证书</h3><h4 id="证书作用"><a class="header-anchor" href="#证书作用"></a>证书作用</h4><ol><li>保证你网络上访问的地址，是真实的服务器，而不是伪造的。比如你访问<code>www.baidu.com</code>时，是真正访问的百度，而不是其他的伪造网站。</li><li>这里有一个<code>PY</code>交易，即你的浏览器或电脑上有很多内置的权威根CA证书，只要你访问的网站，返回证书是这个根证书下颁发的，则是可信的。如果不在这个列表里，则需要你导入证书。比如你可以在<code>windows</code>上看到(<code>win+R</code>执行<code>certmgr.msc</code>)：<br><img src="/2022/07/27/SSL体系理解/%E4%BF%A1%E4%BB%BB%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84%E7%A4%BA%E4%BE%8B.jpg" alt></li></ol><h4 id="证书颁发"><a class="header-anchor" href="#证书颁发"></a>证书颁发</h4><ul><li><strong>证书颁发机构</strong>：是一家知名且受信任的组织，它对网站进行验证以确保互联网更安全。</li><li><strong>CA证书</strong>：CA机构颁发的证明，是一种数字证书。它包含了公钥、公钥拥有者名称、CA的数字签名、有效期、授权中心名称、证书序列号等信息。我们可以通俗的理解为数字证书是个人或企业在网络上的身份证。</li><li><strong>申请CA证书</strong>：为保障申请CA证书的是真实合法的机构。申请时需要一系列的文件，比如：营业执照、身份证、公司法人身份证、诚信承诺书、公司公章及法人章印模等。</li><li><strong>数字证书签名原理</strong>：同样使用的是非对称加密算法，每个数字证书都包含证书信息和公私钥对<br><img src="/2022/07/27/SSL体系理解/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86.png" alt><br><em><a href="https://blog.csdn.net/u014294681/article/details/86705999" target="_blank" rel="noopener">图片来源</a></em></li><li><strong>证书链及域名证书</strong>：CA证书下可以签发一系列的子证书及域名证书，形成证书链。本质上，你申请的CA证书也是子证书。<br><img src="/2022/07/27/SSL体系理解/%E8%AF%81%E4%B9%A6%E9%93%BE.png" alt="证书链"><br><em><a href="https://en.wikipedia.org/wiki/Chain_of_trust" target="_blank" rel="noopener">图片来源</a></em></li></ul><h4 id="证书结构"><a class="header-anchor" href="#证书结构"></a>证书结构</h4><p>一个证书中包含：</p><ol><li>基本字段<ul><li>版本：目前主流的证书版本是V3</li><li>序列号：证书颁发机构CA分配给证书的唯一标识</li><li>签名算法：用于签名的哈希算法和数字签名算法</li><li>签名哈希算法：用于签名的哈希算法</li><li>颁发者：证书颁发机构CA的详细信息</li><li>有效期：证书生效日期和失效日期</li><li>使用者：证书使用者的详细信息</li><li>公钥：公钥密码算法、密钥长度和使用者公钥内容</li></ul></li><li>扩展字段</li><li>证书签名<br><img src="/2022/07/27/SSL体系理解/%E8%AF%81%E4%B9%A6%E7%BB%93%E6%9E%84.jpg" alt><br><em><a href="https://flylib.com/books/en/1.2.1.137/1/" target="_blank" rel="noopener">图片来源</a></em></li></ol><h4 id="证书校验"><a class="header-anchor" href="#证书校验"></a>证书校验</h4><ol><li>只要你上级证书可信，你就可信。不然一直向上追溯，直到浏览器或系统的证书列表，可参考<a href="https://blog.csdn.net/justinzengTM/article/details/104154100" target="_blank" rel="noopener">证书链-证书校验</a></li><li>当前证书校验：将证书信息计算hash，是否等于指纹通过公钥计算得到的hash值。<br><img src="/2022/07/27/SSL体系理解/%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C.jpg" alt><br><em><a href="https://zhuanlan.zhihu.com/p/403704980" target="_blank" rel="noopener">图片来源</a></em></li></ol><p>至此，基本明确了ssl+证书是如何工作了。对其中细节想有更深入了解，可自行研究。</p><h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/133375078" target="_blank" rel="noopener">一篇文章让你彻底弄懂SSL/TLS协议</a><br><a href="https://blog.csdn.net/u014294681/article/details/86705999" target="_blank" rel="noopener">加解密篇 - 非对称加密算法 (RSA、DSA、ECC、DH)</a><br><a href="https://blog.csdn.net/justinzengTM/article/details/104154100" target="_blank" rel="noopener">证书链-证书校验</a><br><a href="https://zhuanlan.zhihu.com/p/30655259" target="_blank" rel="noopener">HTTPS 精读之 TLS 证书校验</a><br><a href="https://zhuanlan.zhihu.com/p/403704980" target="_blank" rel="noopener">数字签名和数字证书的原理解读</a><br><a href="https://flylib.com/books/en/1.2.1.137/1/" target="_blank" rel="noopener">Digital Certificates</a><br><a href="https://en.wikipedia.org/wiki/Chain_of_trust" target="_blank" rel="noopener">Chain of trust</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssl </tag>
            
            <tag> openssl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>投资理财学习</title>
      <link href="/2022/06/13/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/13/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="专题研究"><a class="header-anchor" href="#专题研究"></a>专题研究</h3><ol><li>通货膨胀产生的原因：</li><li>基金是什么</li><li>基金如何保障安全</li><li>疫情是怎么影响全国GDP大波动的，为何有这样类型的波动。<a href="http://www.gov.cn/shuju/hgjjyxqk/detail.html?q=0" target="_blank" rel="noopener">GDP数据统计</a></li><li>人口增长曲线以及对经济和社会的影响</li></ol><h3 id="基金投资"><a class="header-anchor" href="#基金投资"></a>基金投资</h3><p>通货膨胀产生的原因：</p><p>基金是什么：</p><p>基金安全如何保障：</p><p>基金的分类：</p><p>货币基金筛选：</p><ol><li>七日年化</li><li>规模：20亿-2000亿</li><li>成立时间三年以上</li><li>费用成本越低越好(管理费，申购费，赎回费) &lt; 0.7%</li></ol><p>债券基金：</p><ol><li>规模：5亿-100亿</li><li>成立时间三年以上</li><li>基金评级五星，上证，招商。</li><li>三年以上的收益情况，越优越好</li><li>费用成本越低越好 &lt; 0.7%</li></ol><p>混合基金：</p><ol><li>规模：5亿-100亿</li><li>成立时间三年以上</li><li>基金评级五星，上证，招商。</li><li>三年以上的收益情况，越优越好</li><li>费用成本越低越好</li><li>基金经理<ol><li>从业时间</li><li>从业收益，至少跑赢大盘</li><li>基金经理更好频率(换人了就要考虑是不是卖了)</li></ol></li><li>资产配置，股票买的越多，风险越高</li></ol><p>股票基金：</p><ol><li>规模：5亿-100亿</li><li>成立时间三年以上</li><li>基金评级五星，上证，招商。</li><li>三年以上的收益情况，越优越好</li><li>费用成本越低越好</li><li>基金经理<ol><li>从业时间</li><li>从业收益，至少跑赢大盘</li><li>基金经理更好频率(换人了就要考虑是不是卖了)</li></ol></li></ol><p>被动型基金(指数基金):<br>优势：<br>1. 管理费用低<br>2. 不依赖基金经理<br>3. 指数=国运（指数都是包含的股市中规模最大的，最优的部分股票）</p><p>越靠前的企业组成的指数基金，收益越稳定，起伏越小，当然收益峰值不如中小型的多<br>指数指标：</p><ol><li>市盈率(PE)=股票价格/每股净利率<ol><li>举例：一个奶茶店每年赚5w，有人看中了这个奶茶店，出100w买，则需要20年回本。PE=20年。PE越小越容易赚钱</li><li>优点：简单有效</li><li>缺点：无法估计公司潜力</li></ol></li><li>市净率(PB)=总市值/净资产<ol><li>举例：奶茶店家具店面值20w，你花了80w买，PB=80/20=4，PB也是越低越好</li><li>净资产=总资产-负债</li><li>对于有较多实体的经济估值较准</li></ol></li><li>指数温度计:(PE+PB)/2</li></ol><p>指数基金分类：<br>宽指数基金<br>窄指数基金<br>被动型基金(完全复制)<br>增强指数型(部分复制)</p><p>指数基金选取：</p><ol><li>跟踪误差率(跟踪了多少，以及收益是否高于完全被动型)，产生了多少超额收益</li><li>基金规模：10-以上，越大越好</li><li>购买费率</li><li>成立时间：3年以上</li><li>购买时机，根据指数指标和行业，基金类型及经理人等判断。</li></ol><p>定投策略：</p><ol><li>长期坚持</li><li>不要受主观情绪影响</li><li>红利再投资</li></ol><p>定投额度：<br>普通定投：固定金额<br>AI定投方式：价格越低投入越多<br>个人感觉的定投方式：1000*温度指数(低于整个时期的%)。这样越低投资越多，越高投资越少，避免追涨杀跌。买入时机：温度指数&lt;40%，卖出时机&gt;60%</p><p>风险承受能力计算：(100-当前年龄)/100<br>每月投入金额：(每月存量+每月增量)*风险承受能力<br>每月存量（可用于投资的积蓄）：(总积蓄-应急-保险-日常)/定投时间<br>每月增量：(每月收入-支出)/定投时间<br>按照风险大小，分为风险投资和目标投资</p><p>不需要等到温度很高的时候再卖出，50%以及是小牛市了。<br>可以把高温的基金卖出，买温度低的基金</p><p>资产配置：<br>货币基金：日常资金<br>债券基金：低风险<br>股票基金：高风险<br>比例动态平衡：一年调整一下投入资金，原则就是平衡风险。涨得厉害的卖点买不景气有前景的<br>个人觉得的配置(除去保险和日常)：3(应急):4(低风险):3(高风险)<br>后面熟悉了，可以调整到3:3:4</p><p>投资基金误区：</p><ol><li>图便宜，买便宜的基金，买新基金</li><li>频繁买卖</li><li>只买不卖(根据计划和目标买卖基金)</li><li>盲目追热点(关注长期业绩)</li><li>投资过于分散(一般最多10个,一般1个货币基金，2-3个债券，2-3个股票/混合，2-3个指数)</li><li>热衷打新基金<ol><li>打新基金时，了解费用</li><li>不能保证打中新股票</li><li>申购时间短，要及时购买</li><li>也要长期持有，至少1年以上</li></ol></li></ol><p>基金选择：</p><ol><li>优质基金公司<ol><li>基金公司规模超过2000亿的公司</li><li>经理数量越多越好，40以上</li><li>天天基金上可以进行基金排名</li></ol></li><li>优质基金经理(增强型基金)<ol><li>从业年限，建议5-10年</li><li>管理当前基金超过3年</li><li>擅长领域和当前领域符合</li></ol></li><li>找准投资方向<ol><li>没啥好方法。。。</li></ol></li></ol><h3 id="股票投资"><a class="header-anchor" href="#股票投资"></a>股票投资</h3><p>股票赚钱方式：</p><ol><li>股票分红(看公司是否愿意分红)</li><li>低买高卖</li></ol><p>股票分类：</p><ol><li>蓝概股：市值规模大的公司</li><li>白马股：市值规模中等，但是蒸蒸日上的公司</li><li>黑马股：默默无闻，但是有个时机突然崛起</li><li>妖股：没有实业支撑的暴涨暴跌</li></ol><p>股票涨跌停：</p><ol><li>主板上市第一天：±44%，后续±10%</li><li>创业板：上市前五天无限制，后续±20%</li></ol><p>股票术语：</p><ol><li>抱团股：买一个系列的股票</li><li>踏空：没有抓到股价低的买入时机</li><li>建仓：第一次买入行为</li><li>仓位：现阶段买入多少/计划多少钱买入股票</li><li>割肉：止损</li><li>利好/利空：促使股票上涨/下跌消息</li></ol><p>股票投资：</p><ol><li>选择好行业</li><li>找出好公司</li><li>等待好价格</li></ol><p>公司分类(主要营业额&gt;50%)：</p><ol><li>金融类</li><li>消费类</li><li>成长类<ol><li>和经济周期关联不大，主要受技术发展的新兴类行业</li></ol></li><li>周期类<ol><li>和经济周期关联度大</li></ol></li></ol><p>行业优质赛道：</p><ol><li>第一梯队<ol><li>金融：<ol><li>银行</li><li>保险2</li></ol></li><li>消费：<ol><li>食品饮料</li><li>医疗生物</li><li>家用电器</li><li>轻工制造</li><li>汽车</li><li>农林牧渔</li><li>美容护理</li></ol></li><li>成长：<ol><li>电子</li><li>传媒</li><li>计算机</li><li>国防军工</li></ol></li><li>周期：<ol><li>电力设备</li><li>基础化工</li><li>交通运输</li></ol></li></ol></li><li>第二梯队<ol><li>金融：<ol><li>证券2</li><li>多元金融</li></ol></li><li>消费：<ol><li>社会服务</li><li>纺织服饰</li><li>商贸零售</li></ol></li><li>成长：<ol><li>通信</li></ol></li><li>周期(剩下的都是，太多不写了)：</li></ol></li></ol><p>好公司选择标准：</p><ol><li>ROE<ol><li>ROE(净资产收益率)：净利润/净资产*100%</li><li>ROE看长期稳定，市场决定了ROE不可能一直很高</li><li>3年以上：0-10%(差)，10-15%(中)，15-20%(良)，20-35%(优)</li></ol></li><li>净现比(金融类不适合)<ol><li>定义：(经营现金流入-经营现金流出)/净利润*100%，查看时选择三年以上</li><li>公司净现比长期小于10%谨慎投资，证明长期入不敷出</li><li>净现比在10-70%，证明是很普通的公司</li><li>净现比在70-100%，证明比较健康的公司</li><li>净现比&gt;100%,证明很优秀</li></ol></li><li>资产负债率<ol><li>定义：负债总额/资产总额*100%</li><li>资产总额=自己的钱+借的钱</li><li>分类：有息负债和无息负债</li><li>负债率正常水平：<ol><li>金融类：80%</li><li>其他类型：有息负债率在0-32%</li></ol></li></ol></li><li>总市值<ol><li>定义：股价*股票数量</li><li>总市值=流通股市值+限售股市值</li><li>解禁：限售股票开放售卖。大规模股票解禁一般为利空消息</li><li>股票大小：0-100亿(小盘股)，100-500亿(中盘股)，500亿以上(大盘股)</li><li>小盘股容易被操控，出现异常涨跌，甚至暴跌。大盘股不容易被操控</li><li>建议选择300亿以上的盘进行投资</li></ol></li></ol><p>股票估值：</p><ol><li>内在价值：和公司经营嘻嘻相关，是公司自身价值体现</li><li>市场价格：是人们对公司的期望的价格，即人们觉得他值多少</li><li>市场价格&lt;内在价值，可买入，反之卖出</li><li>估值方法： 相对估值法(就是按照百分比进行计算，而不是绝对值)，估值公司一般超过十年，至少上市三年</li><li>PE估值法：<ol><li>市盈率(PE)：公司股价/每股收益=公司总市值/总净利润</li><li>静态市盈率/动态市盈率/滚动市盈率：区别在于分母的利润的取值不同：最新年报总净利润/对下一年预测的总利润值/最近四个季度的总利润值。滚动市盈率是最佳选择</li><li>PE-TTM扣非：TTM扣非(扣非滚动净利润)，去除非常规获取的利润或者亏损：比如政府补贴，变卖房产等。此方法只适合消费类行业</li><li>估值分位点(十年期，或者上市至今超过三年以上)：当前股票价格处于历史阶段的什么位置。40%以下可以认为被低估，60%以上认为被高估</li></ol></li><li>PS估值法：<ol><li>市销率(PS)=公司股价/每股销售额=公司总市值/主营业务收入， 营业收入=主营业务收入+其他业务收入+营业外收入，市销率越低越好(收入越高，值越小)</li><li>静态/动态/滚动市销率。</li><li>在PE-TTM扣非为负的情况下，或者非消费行业，可以使用PS估值法</li></ol></li><li>如何使用指标：<ol><li>可以纵向查看一个公司的各个指标是否值得投资，进行估值</li><li>查看估值分位点等指标看当下时机是否合适</li><li>横向对比其他公司(主营业务相同)，是否有更好的公司。横向对比时消费类可以用PE-TTM，成长类可以用PS-TTM</li></ol></li></ol><p>买卖黄金法则：</p><ol><li>对公司进行估值，并且计算估值分位点，分位点在40%以下时可以购买，计算出一个合理的股票价格</li><li>进行分仓购买，多次购买一只股票，分位点越低，可以购入越多<ol><li>可以设置建仓价(假设5块)，加仓价(5*(1-10%)=4.5, 又跌了10%)，重仓价(5*(1-20%)=4)</li><li>设计不同阶段的数量，建议使用每阶段总投资等的方式，比如每个阶段都投入2000元，自然股价越低，购买股票数量越多</li></ol></li><li>卖股票的时机：<ol><li>公司基本面恶化</li><li>股票到了目标价格</li><li>有更好的投资机会</li></ol></li><li>买入卖出时都要用最新的估值</li><li>股票配比：<ol><li>分散资金，买入多个公司股票，一般4个以上就足以分散风险，但也别太过分散(4-6只)</li><li>公司的行业要分散，才能避免行业波动带来的风险</li></ol></li></ol><p>股票打新：</p><ol><li>股票打新<ol><li>推荐A股打新</li><li>新股上市95%都是上涨</li><li>代价低，中签后才交钱</li><li>新股申购没有佣金，过户费税费等费用</li><li>打新需要资格，而且深沪不通用，具体资格打新时了解</li></ol></li><li>可转债打新<ol><li>可转债就是日后会转换为该公司股票的债券</li><li>没有门槛(2022.6.18日后新规有限制)</li><li>顶格申购，也就是有多少资格申购多少，一般概率不会全部都中，就算没有中，也可以放弃，只要一个月内放弃不超过3次，就不会拉黑</li><li>上市当天卖出，后面大概率会跌破申购价，卖出价可以等于申购价，因为开盘价格大于卖出价格，会以开盘价卖出。当然也可以持有，或者转换成股票</li></ol></li><li>港股票打新<ol><li>中签率高。A股中签率0.02%，港股：20%-40%</li><li>不需要持仓资格</li><li>收益高，风险低</li><li>避开坑的行业。有可能上市就跌</li></ol></li></ol><p>股票投资的风险和误区：</p><ol><li>风险：<ol><li>风险是导致下跌的因素</li><li>系统性风险(整体社会状况导致的风险)，影响整个市场：<ol><li>政策风险</li><li>周期风险</li><li>利率风险</li><li>购买力风险</li><li>汇率风险</li></ol></li><li>非系统性风险(指企业自身经营等发生的风险)<ol><li>个股风险</li><li>行业风险</li></ol></li><li>规避风险方式<ol><li>系统性风险，可通过资产配置来规避，减少股票资金配比</li><li>非系统性风险，选择优质行业，合理的评估企业健康状态，以及分散投资</li></ol></li></ol></li><li>误区：<ol><li>损失厌恶，亏了想赚回来，因此迟迟不卖掉手里的股票。赚了还想赚，因此不舍得卖。解决方式：集中注意力在系统分析上。</li><li>羊群效应，盲目从众。解决方式：提高自己的分析能力</li><li>偏听偏信，对自己持有的股票有乐观态度。解决方式：客观的从数据上分析，不要管自己是否购买该股票</li></ol></li><li>投资计划：<ol><li>初步选股，通过自己的学习方式选取自己觉得优秀的股票名单，每月筛选一次</li><li>根据行业对所选的股票进行分类，找出2-3只估值更低的股票进行更细致的研究</li><li>细致研究后，选择出不同行业的几只股票</li><li>列出买入原因</li><li>通过资产配置进行有节奏的建仓</li><li>跟踪自己买入股票的相关信息，和对股票基本面的影响，是否还支持自己继续持有或买入。</li></ol></li></ol><p>股票高阶：</p><ol><li>什么时候进场</li><li>选择什么行业</li><li>选择哪只股票</li><li>什么时候卖出</li></ol><p>分清熊市牛市：</p><ol><li>M0=流动现金，M1=M0+存在银行的活期，M2=M1+存在银行的定期</li><li>M1增速-M2增速&gt;0代表居民取存款消费(大概率牛市将来)， &lt;0刚好相反(大概率熊市将来)。</li><li>A股的一个特色：牛市短，熊市长</li><li>M1增速-M2增速差在±6%差距，是熊牛市的分割点</li></ol><p>行业选择：</p><ol><li>优先选择国家十四五提倡的行业</li><li>从行业中细分每个行业的产业链条，选择比较赚钱的一环进行投资</li></ol><p>指数基金投资：<br><a href="https://zhuanlan.zhihu.com/p/138162032" target="_blank" rel="noopener">博格公式</a>：投资收益率=投资初期股息率+市盈率平均年变化率+利润平均年变化率<br>适用范围：绝大多数宽基指数，比如上证50、沪深300、中证100、上证红利、中证红利等。因为这些指数股息率稳定、市盈率波动较小、利润增长预测性比较强。行业宽基指数也可参考，但行业指数受政策影响较大。小盘指数则不适用<br>博格公式预测：未来最好情况：市盈率达到80%，中等：市盈率50%，差：市盈率的20%。如果最差的情况你的收益率是负数，则不建议投资</p><p>主动型基金投资方法：<br>沪深300都跑不过的垃圾就不要选了。<br>北斗七星：<br>收益率：历史收益率越高越好(也要看风险承受能力)<br>基金规模：5-100亿<br>成立时间：3年以上<br>重仓股：看看重仓股是否有问题<br>基金经理：从业时间&gt;3年，历史业绩较好，专业对口<br>评级：较为权威的机构对基金评级，评级一般选5星<br>基金排名：选择排名前25%的基金，重点关注<br>夏普比率(越大越好)：(预期收益率-无风险收益率)/投资组合标准差<br>基金风险：最大回撤(基金最高值-最低值)</p><p>基金规模：<br>小盘：&lt;5亿<br>中盘：5-20亿<br>大盘：&gt;20亿</p><p>工具：<br>理杏仁：各种基金股票数据</p><p>REIT:不动产债券化</p><p>第三课<br>高级基金进阶：</p><ol><li>债券基金： 5-8%<ol><li>分纯债券和股票债券</li><li>买入时机：十年国债收益率&gt; 3.5%，卖出时机：十年国债收益率&lt;2.5%</li></ol></li><li>红利指数基金(能赚钱，爱分红的公司集结) 10%<ol><li>可以通过指数温度来进行基金购买</li></ol></li><li>行业指数(只包含某个行业的指数) 20%<ol><li>看行业历史收益率选择好的行业(消费和医药)，只选择&gt;10%</li><li>看行业后续是否有很大需求，可以考虑直接剔除周期性行业</li><li>行业指数最好使用博格公式来进行估值，指数温度不太适合窄基金</li></ol></li><li>投资风险(主动投资基金)<ol><li>投资风格箱<ol><li>按照盘的大小来判断，盘越大，投资风险越小</li><li>按照类型来判断，风险：成长型&gt;平衡型&gt;价值型</li><li>按照大中小盘，和基金类型形成九宫格的投资风格箱，</li></ol></li><li>按照投资风格箱，进行投资份额分配</li><li>夏普比率评价主动基金的收益</li><li>最大回撤评估基金风险</li></ol></li><li>RETIs投资(不动产基金投资)<ol><li>将不动产证券化(去除商用建筑和民用住宅)</li><li>风险基本处于中高风险</li><li>基金有强制分红，分红在90%以上</li><li>购买基金的选择方式<ol><li>现金分派比例越高越好</li><li>战略投资者占比越高越好</li><li>需要开通债券交易账号</li></ol></li></ol></li><li>QDII基金(海外基金)<ol><li>购买方式和选股方式本质和国内相似</li><li>纳斯达克和国内创业板相似，主要是高科技新兴公司</li><li>风险点：<ol><li>汇率变动</li><li>管理费用较高</li><li>买入和赎回周期更长</li></ol></li></ol></li><li>震荡市场<ol><li>网格交易法，下跌买入(买入阶梯：(第一手买入-&gt;预估的最低买入价)/阶梯数)，上涨卖出(卖出阶梯相同)<ol><li>失效的情况<ol><li>长时间上涨，自己基金都卖完了还在涨</li><li>下跌时间长，全买入还在跌</li><li>震荡过小</li></ol></li><li>适合震荡市场短期赚钱</li><li>选择波动比较大的基金</li><li>适合场内基金，手续费低</li><li>每次买入和卖出都记录表格</li></ol></li></ol></li><li>熊市投资<ol><li>金字塔买入策略(市场下跌X%，买入增加Y%)</li><li>股市温度表，可以初步预测未来的基金走向</li><li>如果买入后就上涨了，就没有必要继续买入，守着等赚钱合适，就卖了。</li><li>股市温度表代表上涨可能性大，下跌X可以设置小一些，反之则大</li></ol></li><li>基金风险配置<ol><li>适合各种市场环境</li><li>按照不同的风险进行债券基金和股票基金</li><li>债券基金和股票基金很少同涨同跌</li><li>适合买股票基金：A股市场平均市盈率-10年国债收益率倒数 &lt; 0</li><li>适合买债券基金：与第四点相反&gt;0</li><li>可以参考股债平衡温度计</li><li>示例：<ol><li>留好应急资金</li><li>查看温度，分配资金购买基金</li><li>留心温度，调整比例</li></ol></li></ol></li><li>投资心态<ol><li>降低投资预期，不要想着赚快钱，不要用赌博心态投资<ol><li>不要用短期使用的资金投资</li><li>不要借钱投资</li><li>不要有明确用途的钱投资</li></ol></li><li>风险控制<ol><li>系统风险无可避免，合理按照股债平衡合理分配</li><li>局部风险，可以通过分散投资消除</li></ol></li><li>人性弱点<ol><li>贪婪和恐惧，避免追涨杀跌</li><li>定期调整基金比例，但也要避免频繁交易</li></ol></li></ol></li></ol><p>从0开始投资：</p><ol><li>分配自己的资金：<ol><li>日常使用(至少3个月)</li><li>应急保险资金(包含购买保险，应急资金)</li><li>目的资金(旅游，买车等)</li><li>投资资金(这部分用于风险投资)</li></ol></li><li>将不同类型的资金进行分类投资：<ol><li>日常使用可以放到货币基金中(类似余额宝一类)</li><li>应急保险资金(应急资金，可以购买国债，黄金或银行定期等)</li><li>目的资金(可能需要平时积攒，看情况放货币基金中，或者定投风险较低的基金(债券占比较高))</li><li>投资资金(可进行风险投资)</li></ol></li><li>对投资资金进行评估<ol><li>投资资金总量明确</li><li>自己能承受风险明确(即可以损失多少钱)</li><li>期望收益明确，通常等同于承受风险值</li><li>根据风险承受能力，划分资金，通常资金比例为4:3:3(低风险，中风险，高风险)</li></ol></li><li>为不同风险资金选择基金<ol><li>每个风险选择2-3个基金即可，可选择指数基金，根据风险承受能力选择指数基金的风险，个人通常认为5%-10%, 20%-30%, 30-50%左右为低，中，高风险</li><li>设定投资目标，比如在盈利多少的情况下退场。</li><li>比较选出优秀基金，比如北斗七星，博格公式等</li><li>选择投资方式，比如定投，还是金字塔等，</li><li>选择入场时机，比如低温或好的时机开始入场</li></ol></li><li>保持投资态度<ol><li>避免追涨杀跌，避免频繁交易</li><li>时常关注，注意股市温度表，及时进行风险比例调整(股债平衡)</li><li>避免赌博心态，有耐心等待出手机会。</li><li>合理止损，如果有更好的投资机会，及时卖出</li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GoF设计模式</title>
      <link href="/2022/05/27/GoF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/05/27/GoF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>GoF的《设计模式》阅读以及基于golang的实现(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em>意指都在快速全面的解决问题，寻找和实现一个最为合适的模式</em></p><a id="more"></a><p>设计模式是做什么的？它的基本原理和意图是什么？它解决的是什么样的特定设计问题？</p><h1>基础</h1><p>四个基本要素：</p><ol><li>模式名称 （pattern name）<br>一个助记名，它用一两个词来描述模式的问题、解决方案和效果。命名一个新的模式增加了我们的设计词汇。设计模式允许我们在较高的抽象层次上进行设计。基于一个模式词汇表，我们自己以及同事之间就可以讨论模式并在编写文档时使用它们。模式名可以帮助我们思考，便于我们与其他人交流设计思想及设计结果。找到恰当的模式名也是我们设计模式编目工作的难点之一。</li><li>问题(problem)<br>描述了应该在何时使用模式。它解释了设计问题和问题存在的前因后果，它可能描述了特定的设计问题，如怎样用对象表示算法等。也可能描述了导致不灵活设计的类或对象结构。有时候，问题部分会包括使用模式必须满足的一系列先决条件。</li><li>解决方案 (solution)<br>描述了设计的组成成分，它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。</li><li>效果(consequences)<br>描述了模式应用的效果及使用模式应权衡的问题。尽管我们描述设计决策时，并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。</li></ol><p>设计模式怎样解决设计问题？<br>寻找合适的对象<br>决定对象的粒度<br>指定对象接口<br>描述对象的实现：确定你的系统时针对接口编程，而不是针对实现。<br>运用复用机制，尽量避免重复代码。<br>关联运行时刻和编译时刻的结构<br>设计应支持变化，拓展和解耦<br>怎样选择设计模式<br>1. 设计模式解决什么样的问题<br>2. 浏览已知模式的设计意图<br>3. 研究模式怎么相互关联<br>4. 检查哪些是需要拓展，需要解耦<br>怎样使用模式<br>1. 大致浏览模式，选择合适你问题的部分<br>2. 选择模式，并放在合适的位置，明确主要部分和协助部分<br>3. 参看示例代码，并明确其上下文意义<br>4. 将模式尝试嵌入到你的实际问题中</p><p>2.3</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《Go101》读书笔记</title>
      <link href="/2022/01/07/%E3%80%8AGo101%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/07/%E3%80%8AGo101%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>姜大佬推荐的一本较为深入理解go细节的书，作为golang学习进阶。(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em>以下内容都是根据书中的章节目录，并且根据自己的缺陷进行记录的。</em><br><em>如果有兴趣，推荐先阅读原著，再看笔记。</em></p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>go语言的查漏补缺。<a href="https://gfw.go101.org/article/101.html" target="_blank" rel="noopener">在线阅读</a></p><h2 id="Go编程入门"><a class="header-anchor" href="#Go编程入门"></a>Go编程入门</h2><h3 id="Go工具链"><a class="header-anchor" href="#Go工具链"></a>Go工具链</h3><p>问题1： 书中说: <em>比如，目前Go不支持任意类型的不变量。这导致很多标准库中一些希望永不被更改的值目前被声明为变量。这是Go程序中的一个潜在安全隐患</em> const 不算常量？</p><h4 id="go-vet"><a class="header-anchor" href="#go-vet"></a>go vet</h4><p><code>go vet</code>可以用来检测可能出现的逻辑错误，使用方法也很简单：</p><ol><li>检测单个文件：<br><code>go vet a.go</code></li><li>检测文件夹：<br><code>go vet ./test/</code>或者可以增加tag<code>go vet -tags=&quot;a&quot; ./test/</code><br><code>go vet</code>检测文件夹的时候，会自动根据文件夹下的go文件去查找对应的依赖关系，并给出相应的检测结果。</li></ol><h3 id="关键字和标识符"><a class="header-anchor" href="#关键字和标识符"></a>关键字和标识符</h3><p>有趣的是，golang中标识符可以是<em>一个以Unicode字母或者_开头并且完全由Unicode字母和Unicode数字组成的单词</em> 这就意味着下面的定义也是合法的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> _status <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> memStat <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> π <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> 一个类型 <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> 변수 <span class="keyword">int</span> </span><br><span class="line"><span class="keyword">var</span> エラー <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>而且一个由大写字符开头的标识符，为导出字符。而大写的定义是<a href="https://www.fileformat.info/info/unicode/category/Lu/list.htm" target="_blank" rel="noopener">Unicode中的大写</a></p><h3 id="常量和变量"><a class="header-anchor" href="#常量和变量"></a>常量和变量</h3><p>常量定义中，<code>=</code>号并不代表赋值，而有点像绑定，类似于c中的<code>#define</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以理解为#define的方式，实际使用的时候，替换为1</span></span><br><span class="line"><span class="keyword">const</span> one = <span class="number">1</span></span><br><span class="line"><span class="comment">//同上，实际使用的时候，替换为int(1)</span></span><br><span class="line"><span class="keyword">const</span> one <span class="keyword">int</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>若干包级变量在声明时刻的依赖关系将影响它们的初始化顺序<br>下面这个例子中的声明的变量的初始化顺序为<code>y = 5、c = y、b = c+1、a = b+1、x = a+1</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y = a+<span class="number">1</span>, <span class="number">5</span>         <span class="comment">// 8 5</span></span><br><span class="line"><span class="keyword">var</span> a, b, c = b+<span class="number">1</span>, c+<span class="number">1</span>, y <span class="comment">// 7 6 5</span></span><br></pre></td></tr></table></figure><p>包级变量在初始化的时候不能相互依赖。比如，下面这个变量声明语句编译不通过。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y = y, x</span><br></pre></td></tr></table></figure><p>变量可被寻址，常量不行。<br>常量的类型转换，不允许溢出，而变量则允许。</p><p>常量和变量的类型推断方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> n = <span class="keyword">uint</span>(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">uint</span>(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//推断为：var a = byte(int(1) &lt;&lt; n / 128)</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">byte</span> = <span class="number">1</span> &lt;&lt; n / <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//推断为：var b = byte(1) &lt;&lt; m / 128</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">byte</span> = <span class="number">1</span> &lt;&lt; m / <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(a, b) <span class="comment">// 2 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a class="header-anchor" href="#函数"></a>函数</h3><p><a href="https://books.studygolang.com/the-way-to-go_ZH_CN/06.5.html" target="_blank" rel="noopener">内置函数</a></p><p><code>switch</code>中，执行时是依次比较每个<code>case</code></p><h3 id="defer"><a class="header-anchor" href="#defer"></a>defer</h3><p>当一个函数调用被延迟后，它不会立即被执行。它将被推入由当前协程维护的一个延迟调用堆栈。 当一个函数调用（可能是也可能不是一个延迟调用）返回并进入它的退出阶段后，所有在此函数调用中已经被推入的延迟调用将被按照它们被推入堆栈的顺序逆序执行。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"The third line."</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"The second line."</span>)</span><br><span class="line">fmt.Println(<span class="string">"The first line."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The first line.</span><br><span class="line">The second line.</span><br><span class="line">The third line.</span><br></pre></td></tr></table></figure><p>defer传参问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"a:"</span>, i) <span class="comment">//执行for的时候，就传入i的参数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//执行函数调用时再传入i的参数</span></span><br><span class="line">fmt.Println(<span class="string">"b:"</span>, i)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a: 2</span><br><span class="line">a: 1</span><br><span class="line">a: 0</span><br><span class="line"></span><br><span class="line">b: 3</span><br><span class="line">b: 3</span><br><span class="line">b: 3</span><br></pre></td></tr></table></figure><p>下面这个例子，则会输出<code>false</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f()</span><br><span class="line">f = <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个延迟调用的实参也是在此调用被推入延迟调用堆栈之前估值的</p><h3 id="panic和recover"><a class="header-anchor" href="#panic和recover"></a>panic和recover</h3><p>一旦一个函数调用产生一个<code>panic</code>，此函数调用将立即进入它的退出阶段，执行<code>defer</code>所定义的延迟函数，这里所有定义的延迟函数都将被执行(逆序)。<br>通过在<code>defer</code>中调用内置函数<code>recover</code>，当前协程中的一个<code>panic</code>可以被消除，从而使得当前协程重新进入正常状况。<br>在一个处于<code>panic</code>状况的协程退出之前，其中的<code>panic</code>不会蔓延到其它协程。 如果一个协程在<code>panic</code>状况下退出，它将使整个程序崩溃。<br>一个协程调用或者延迟调用的实参是在此调用发生时被估值的。更具体地说：</p><ul><li>对于一个延迟函数调用，它的实参是在此调用被推入延迟调用堆栈的时候被估值的。</li><li>对于一个协程调用，它的实参是在此协程被创建的时候估值的。</li></ul><p><strong>一些致命性错误不属于<code>panic</code></strong><br>对于官方标准编译器来说，很多致命性错误（比如堆栈溢出和内存不足）不能被恢复。它们一旦产生，程序将崩溃。</p><h3 id="类型"><a class="header-anchor" href="#类型"></a>类型</h3><p>类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type (</span><br><span class="line">MyInt int</span><br><span class="line">Age   int</span><br><span class="line">Text  string</span><br><span class="line">)</span><br><span class="line">type IntPtr *intgo</span><br></pre></td></tr></table></figure><p>类型定义的一些特点：</p><ol><li>一个新定义的类型和它的源类型为两个不同的类型。</li><li>在两个不同的类型定义中的定义的两个类型肯定为两个不同的类型。</li><li>一个新定义的类型和它的源类型的底层类型（将在下面介绍）一致并且它们的值可以相互显式转换。</li><li>类型定义可以出现在函数体内。</li></ol><p>类型别名声明:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">Name = <span class="keyword">string</span></span><br><span class="line">Age  = <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> table = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> Table = <span class="keyword">map</span>[Name]Age</span><br></pre></td></tr></table></figure><p>类型别名，顾名思义，就是某个类型的另外一个名字。</p><h2 id="Go类型系统"><a class="header-anchor" href="#Go类型系统"></a>Go类型系统</h2><h3 id="指针"><a class="header-anchor" href="#指针"></a>指针</h3><ul><li>一个指针类型的值不能被随意转换为另一个指针类型</li><li>一个指针值不能和其它任一指针类型的值进行比较</li><li>指针值不能进行数值计算，比如有指针<code>p</code>，进行<code>p++</code></li><li><code>unsafe.Pointer</code>可以打破Go对指针的限制<br><strong>在赋值中，底层间接值部将不会被复制</strong><br>意味着所有的间接引用值类型，都共用一个内存值，包括string。由于string的内存是只读状态，因此上面的描述也是正确的。</li></ul><table><thead><tr><th>直接存值</th><th>间接存值</th></tr></thead><tbody><tr><td>布尔类型</td><td>切片类型</td></tr><tr><td>各种数值类型</td><td>映射类型</td></tr><tr><td>指针类型</td><td>通道类型</td></tr><tr><td>非类型安全指针类型</td><td>函数类型</td></tr><tr><td>结构体类型</td><td>接口类型</td></tr><tr><td>数组类型</td><td>字符串类型</td></tr></tbody></table><p>使用内置<code>copy</code>函数来复制切片元素，复制的两个切片类型可以不同，但是底层数据结构必须相同。</p><h3 id="map"><a class="header-anchor" href="#map"></a>map</h3><p>在map的遍历中，单协程是可以对map进行增删改查的，但是注意：</p><ol><li>map遍历是随机的</li><li>在遍历过程中，没有遍历到的目录被删除，则后续也不会被遍历出来</li><li>在遍历过程中，增加新条目，则后续不保证会被遍历出来</li><li>遍历时，会对直接值进行一次拷贝，用于赋值循环变量。比如数组遍历过程中修改原始数组值，是不会在遍历的变量中体现修改。但是切片就会体现。</li><li>遍历中，循环变量也是一个元素备份，对循环变量的修改，也不会体现到原始值中。</li><li>所有被遍历的键值对将被赋值给<strong>同一对</strong>循环变量实例</li></ol><p>类型<code>struct{}</code>的尺寸为零</p><h3 id="string"><a class="header-anchor" href="#string"></a>string:</h3><p>字符串赋值，在底层享用的是同一份数据<br>字符串和切片(字节切片或者码点切片)之间的转换，是需要进行深复制的，原因在于切片是可以被修改的，字符串则不行。<br>用<code>for range</code>遍历字符串的时候，取出的值是一个<code>rune</code>类型的值，但是<code>len(s)</code>得到的却是字符串的字节数</p><p>函数也可以认为是一个值，但是函数是不可比较类型<br>函数值赋值时，内置函数和init不可被用作函数值</p><h3 id="接口"><a class="header-anchor" href="#接口"></a>接口</h3><p>因为任何方法集都是一个空方法集的超集，所以任何类型都实现了任何空接口类型(<code>interface{}</code>)。<br>在Go中，如果类型<code>T</code>实现了一个接口类型<code>I</code>，则类型<code>T</code>的值都可以隐式转换到类型<code>I</code>。 换句话说，类型<code>T</code>的值可以赋给类型<code>I</code>的可修改值。 当一个<code>T</code>值被转换到类型<code>I</code>（或者赋给一个<code>I</code>值）的时候:</p><ul><li>如果类型<code>T</code>是一个非接口类型，则此<code>T</code>值的一个复制将被包裹在结果（或者目标）<code>I</code>值中。 此操作的时间复杂度为<code>O(n)</code>，其中n为<code>T</code>值的尺寸。</li><li>如果类型<code>T</code>也为一个接口类型，则此<code>T</code>值中当前包裹的（非接口）值将被复制一份到结果（或者目标）<code>I</code>值中。 官方标准编译器为此操作做了优化，使得此操作的时间复杂度为<code>O(1)</code>，而不是<code>O(n)</code>。<br>非接口类型和接口类型会在go运行时构建一个全局关系列表，一个非接口值内部只会存储一个指向该列表的一个条目。<br>非接口类型和接口类型对，存在两个部分：</li><li>动态类型（即此非接口类型）的信息。(反射的关键)</li><li>一个方法表（切片类型），其中存储了所有此接口类型指定的并且为此非接口类型（动态类型）声明的方法。(多态的关键)<br>当非接口类型<code>T</code>的一个值<code>t</code>被包裹在接口类型<code>I</code>的一个接口值<code>i</code>中：当方法<code>i.m</code>被调用时，<code>i</code>存储的实现关系信息的方法表中的方法<code>t.m</code>将被找到并被调用</li></ul><h4 id="接口值的比较"><a class="header-anchor" href="#接口值的比较"></a>接口值的比较:</h4><ul><li>比较一个非接口值和接口值。（非接口值会被隐式转化为接口值，进而变为接口值比较）</li><li>比较两个接口值。</li></ul><p>两个接口值的比较结果只有在下面两种任一情况下才为true：</p><ol><li>这两个接口值都为nil接口值。</li><li>这两个接口值的动态类型相同、动态类型为可比较类型、并且动态值相等。</li></ol><p>一个<code>[]T</code>类型的值不能直接被转换为类型<code>[]I</code>，即使类型<code>T</code>实现了接口类型<code>I</code>。只能通过循环来进行转换。</p><h2 id="并发编程"><a class="header-anchor" href="#并发编程"></a>并发编程</h2><h3 id="协程"><a class="header-anchor" href="#协程"></a>协程</h3><p>协程生命周期：<br><img src="/2022/01/07/《Go101》读书笔记/%E5%8D%8F%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt><br>进一步的：<br><img src="/2022/01/07/《Go101》读书笔记/%E5%8D%8F%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E7%BB%86.png" alt></p><p>我们可以调用runtime.GOMAXPROCS函数来获取和设置逻辑处理器的数量。自从Go 1.5之后，默认初始逻辑处理器的数量和逻辑CPU的数量一致。 此新的默认设置在大多数情况下是最佳选择。但是对于某些文件操作十分频繁的程序，设置一个大于<code>runtime.NumCPU()</code>的<code>GOMAXPROCS</code>值可能是有好处的。</p><h3 id="通道"><a class="header-anchor" href="#通道"></a>通道</h3><p>通道类型是可比较类型。<code>len(ch)</code>查询通道长度，返回的是通道内还存在多少个未被接收的元素。同样也存在<code>cap(ch)</code><br>对通道的操作都是并发安全的：</p><ol><li><code>close(ch)</code></li><li><code>len(ch)</code></li><li><code>cap(ch)</code></li><li><code>ch &lt;- v</code></li><li><code>&lt;- ch</code></li></ol><table><thead><tr><th>操作</th><th>一个零值nil通道</th><th>一个非零值但已关闭的双向通道</th><th>一个非零值且尚未关闭的双向通道</th></tr></thead><tbody><tr><td>关闭</td><td>产生恐慌</td><td>产生恐慌</td><td>成功关闭©</td></tr><tr><td>发送数据</td><td>永久阻塞</td><td>产生恐慌</td><td>阻塞或者成功发送(B)</td></tr><tr><td>接收数据</td><td>永久阻塞</td><td>永不阻塞(D)</td><td>阻塞或者成功接收(A)</td></tr></tbody></table><p>关闭一个双向通道时，关闭前的接收协程依旧可以获取缓冲区的值(如果缓冲区没有值则是零值)，如果关闭时存在发送协程则会产生<code>panic</code>。关闭后的接收协程则会永久阻塞。可以通过通道接收的第二个返回值<code>true/false</code>判断接收协程是否正常接收数据，还是关闭后返回的零值</p><p>通道可以看做是一个由数据缓冲区，接收协程队列，发送协程队列组成。<br>我们可以得出如下的关于一个通道的内部的三个队列的各种事实：</p><ul><li>如果一个通道已经关闭了，则它的发送数据协程队列和接收数据协程队列肯定都为空，但是它的缓冲队列可能不为空。</li><li>在任何时刻，如果缓冲队列不为空，则接收数据协程队列必为空。</li><li>在任何时刻，如果缓冲队列未满，则发送数据协程队列必为空。</li><li>如果一个通道是缓冲的，则在任何时刻，它的发送数据协程队列和接收数据协程队列之一必为空。</li><li>如果一个通道是非缓冲的，则在任何时刻，一般说来，它的发送数据协程队列和接收数据协程队列之一必为空， 但是有一个例外：一个协程可能在一个select流程控制中同时被推入到此通道的发送数据协程队列和接收数据协程队列中。</li></ul><p>官方编译器，通道元素最大尺寸为<code>65535</code></p><p><code>for-range</code>循环控制流程也适用于通道。 此循环将不断地尝试从一个通道接收数据，直到此通道关闭并且它的缓冲队列为空为止。 和应用于数组/切片/映射的<code>for-range</code>语法不同，应用于通道的<code>for-range</code>语法中最多只能出现一个循环变量，此循环变量用来存储接收到的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> aChannel &#123;</span><br><span class="line"><span class="comment">// 使用v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的通道aChannel一定不能为一个单向发送通道。 如果它是一个nil零值，则此<code>for-range</code>循环将使当前协程永久阻塞。</p><h3 id="select-case"><a class="header-anchor" href="#select-case"></a>select-case</h3><p>一些特性：</p><ul><li><code>select</code>关键字和<code>{</code>之间不允许存在任何表达式和语句。</li><li><code>fallthrough</code>语句不能被使用.</li><li>每个<code>case</code>关键字后必须跟随一个通道接收数据操作或者一个通道发送数据操作。 通道接收数据操作可以做为源值出现在一条简单赋值语句中。 以后，一个<code>case</code>关键字后跟随的通道操作将被称为一个<code>case</code>操作。</li><li>所有的非阻塞<code>case</code>操作中将有一个被随机选择执行（而不是按照从上到下的顺序），然后执行此操作对应的<code>case</code>分支代码块。</li><li>在所有的<code>case</code>操作均为阻塞的情况下，如果<code>default</code>分支存在，则<code>default</code>分支代码块将得到执行； 否则，当前协程将被推入所有阻塞操作中相关的通道的发送数据协程队列或者接收数据协程队列中，并进入阻塞状态。</li></ul><p>一个非阻塞的发送和接收：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">trySend := <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- v:</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// 如果c的缓冲已满，则执行默认分支。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tryReceive := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v := &lt;-c: <span class="keyword">return</span> v</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">"-"</span> <span class="comment">// 如果c的缓冲为空，则执行默认分支。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">trySend(<span class="string">"Hello!"</span>) <span class="comment">// 发送成功</span></span><br><span class="line">trySend(<span class="string">"Hi!"</span>)    <span class="comment">// 发送成功</span></span><br><span class="line">trySend(<span class="string">"Bye!"</span>)   <span class="comment">// 发送失败，但不会阻塞。</span></span><br><span class="line"><span class="comment">// 下面这两行将接收成功。</span></span><br><span class="line">fmt.Println(tryReceive()) <span class="comment">// Hello!</span></span><br><span class="line">fmt.Println(tryReceive()) <span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// 下面这行将接收失败。</span></span><br><span class="line">fmt.Println(tryReceive()) <span class="comment">// -</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现机制：</strong></p><ol><li>将所有case操作中涉及到的通道表达式和发送值表达式按照从上到下，从左到右的顺序一一估值。 在赋值语句中做为源值的数据接收操作对应的目标值在此时刻不需要被估值。</li><li>将所有分支随机排序。default分支总是排在最后。 所有case操作中相关的通道可能会有重复的。</li><li>为了防止在下一步中造成（和其它协程互相）死锁，对所有case操作中相关的通道进行排序。 排序依据并不重要，官方Go标准编译器使用通道的地址顺序进行排序。 排序结果中前N个通道不存在重复的情况。 N为所有case操作中涉及到的不重复的通道的数量。 下面，通道锁顺序是针对此排序结果中的前N个通道来说的，通道锁逆序是指此顺序的逆序。</li><li>按照上一步中的生成通道锁顺序获取所有相关的通道的锁。</li><li>按照第2步中生成的分支顺序检查相应分支：<ol><li>如果这是一个case分支并且相应的通道操作是一个向关闭了的通道发送数据操作，则按照通道锁逆序解锁所有的通道并在当前协程中产生一个恐慌。 跳到第12步。</li><li>如果这是一个case分支并且相应的通道操作是非阻塞的，则按照通道锁逆序解锁所有的通道并执行相应的case分支代码块。 （此相应的通道操作可能会唤醒另一个处于阻塞状态的协程。） 跳到第12步。</li><li>如果这是default分支，则按照通道锁逆序解锁所有的通道并执行此default分支代码块。 跳到第12步。<br>（到这里，default分支肯定是不存在的，并且所有的case操作均为阻塞的。）</li></ol></li><li>将当前协程（和对应case分支信息）推入到每个case操作中对应的通道的发送数据协程队列或接收数据协程队列中。 当前协程可能会被多次推入到同一个通道的这两个队列中，因为多个case操作中对应的通道可能为同一个。</li><li>使当前协程进入阻塞状态并且按照通道锁逆序解锁所有的通道。</li><li>…，当前协程处于阻塞状态，等待其它协程通过通道操作唤醒当前协程，…</li><li>当前协程被另一个协程中的一个通道操作唤醒。 此唤醒通道操作可能是一个通道关闭操作，也可能是一个数据发送/接收操作。 如果它是一个数据发送/接收操作，则（当前正被解释的select-case流程中）肯定有一个相应case操作与之配合传递数据。 在此配合过程中，当前协程将从相应case操作相关的通道的接收/发送数据协程队列中弹出。</li><li>按照第3步中的生成的通道锁顺序获取所有相关的通道的锁。</li><li>将当前协程从各个case操作中对应的通道的发送数据协程队列或接收数据协程队列中（可能以非弹出的方式）移除。<ol><li>如果当前协程是被一个通道关闭操作所唤醒，则跳到第5步。</li><li>如果当前协程是被一个数据发送/接收操作所唤醒，则相应的case分支已经在第9步中知晓。 按照通道锁逆序解锁所有的通道并执行此case分支代码块。</li></ol></li><li>完毕。</li></ol><h3 id="常见的并发编程错误"><a class="header-anchor" href="#常见的并发编程错误"></a>常见的并发编程错误</h3><p><strong>该加同步的没有加</strong><br>源文件中的代码，在运行时并非总是按照它们出现的顺序被执行。<br>下面这个示例程序犯了两个错误：</p><ul><li>首先，主协程中对变量b的读取和匿名协程中的对变量b的写入可能会产生数据竞争；</li><li>其次，在主协程中，条件b == true成立并不能确保条件a != nil也成立。 编译器和CPU可能会对调整此程序中匿名协程中的某些指令的顺序已获取更快的执行速度。 所以，站在主协程的视角看，对变量b的赋值可能会发生在对变量a的赋值之前，这将造成在修改a的元素时a依然为一个nil切片。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span> <span class="comment">// nil</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span>  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个匿名协程。</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">b = <span class="literal">true</span> <span class="comment">// 写入b</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> !b &#123; <span class="comment">// 读取b</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 在大多数设备上运行良好，但是某些设备上可能会发生恐慌</span></span><br><span class="line">a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>] = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的行为应当使用管道或者锁来保证顺序正确性</p><p><strong>错误复制<code>sync</code>标准库包中的类型的值</strong><br>在实践中，sync标准库包中的类型（除了Locker接口类型）的值不应该被复制。 我们只应该复制它们的指针值。</p><p><strong>确保每个<code>sync.WaitGroup.Add</code>的调用在<code>sync.WaitGroup.Wait</code>之前</strong><br>下面这个示例会返回<code>0~100</code>的任何一个值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int32</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">atomic.AddInt32(&amp;x, <span class="number">1</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"等待片刻..."</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(atomic.LoadInt32(&amp;x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>没留意过多的<code>time.After</code>函数调用消耗了大量资源</strong><br>如果一分钟内，<code>longRunning</code>被调用且有一百万条消息，则<code>time.After</code>会创建一百万个<code>time.Timer</code>值，则有很大的垃圾回收压力</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果某两个连续的消息的间隔大于一分钟，此函数将返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longRunning</span><span class="params">(messages &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Minute):</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更好的做法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longRunning</span><span class="params">(messages &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">timer := time.NewTimer(time.Minute)</span><br><span class="line"><span class="keyword">defer</span> timer.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-timer.C: <span class="comment">// 过期了</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">fmt.Println(msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此if代码块很重要。</span></span><br><span class="line"><span class="keyword">if</span> !timer.Stop() &#123;</span><br><span class="line">&lt;-timer.C</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须重置以复用。</span></span><br><span class="line">timer.Reset(time.Minute)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个典型的<code>time.Timer</code>的使用已经在上例中展示了。一些解释：</p><ul><li>如果一个<code>Timer</code>值已经过期或者已经被终止（<code>stopped</code>），则相应的<code>Stop</code>方法调用返回<code>false</code>。 在此Timer值尚未终止的时候，<code>Stop</code>方法调用返回f<code>alse</code>只能意味着此<code>Timer</code>值已经过期。</li><li>一个<code>Timer</code>值被终止之后，它的通道字段<code>C</code>最多只能含有一个过期的通知。</li><li>在一个<code>Timer</code>终止（<code>stopped</code>）之后并且在重置和重用此<code>Timer</code>值之前，我们应该确保此<code>Timer</code>值中肯定不存在过期的通知。 这就是上一节中的例子中的if代码块的意义所在。</li></ul><p>一个<code>*Timer</code>值的<code>Reset</code>方法必须在对应<code>Timer</code>值过期或者终止之后才能被调用； 否则，此<code>Reset</code>方法调用和一个可能的向此<code>Timer</code>值的<code>C</code>通道字段的发送通知操作产生数据竞争。<br>在多个协程中使用同一个<code>time.Timer</code>值比较容易写出不当的并发代码，所以尽量不要跨协程使用一个<code>Timer</code>值。</p><h2 id="一些专题"><a class="header-anchor" href="#一些专题"></a>一些专题</h2><h3 id="类型隐式转换"><a class="header-anchor" href="#类型隐式转换"></a>类型隐式转换</h3><p><code>T</code>或<code>*T</code>实现的函数，本质上也是<code>T</code>或<code>*T</code>的成员，存在于其结构中。也就是成员函数。因此即使是特定类型的空指针调用方法，也不会出现<code>panic</code>：<code>_ = ((*Age)(nil)).IsNil()</code><br>本质上，成员函数声明都会进行隐式转换，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Book)</span> <span class="title">Pages</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> b.pages</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Book)</span> <span class="title">SetPages</span><span class="params">(pages <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">b.pages = pages</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会隐式转换成下面的结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Book</span>.<span class="title">Pages</span><span class="params">(b Book)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> b.pages <span class="comment">// 此函数体和Book类型的Pages方法体一样</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Book)</span>.<span class="title">SetPages</span><span class="params">(b *Book, pages <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">b.pages = pages <span class="comment">// 此函数体和*Book类型的SetPages方法体一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当你调用<code>b.Pages()</code>，本质上<code>b</code>也会作为一个参数进行拷贝赋值。<br>对于方法调用，如果声明了<code>(T).F</code>，那么<code>(*T).F</code>和<code>(T).F</code>都可以编译通过，并进行转换成正规的结构<code>(T).F</code>。同理：如果声明了<code>(*T).F</code>，那么<code>(*T).F</code>和<code>(T).F</code>也都可以编译通过，并进行转换成正规的结构<code>(*T).F</code>。<br>对于值类型属主还是指针类型属主都可以接受的方法声明，下面列出了一些考虑因素：</p><ul><li>太多的指针可能会增加垃圾回收器的负担。</li><li>如果一个值类型的尺寸太大，那么属主参数在传参的时候的复制成本将不可忽略。 指针类型都是小尺寸类型。 关于各种不同类型的尺寸，请阅读值复制代价一文。</li><li>在并发场合下，同时调用值类型属主和指针类型属主方法比较易于产生数据竞争。</li><li>sync标准库包中的类型的值不应该被复制，所以如果一个结构体类型内嵌了这些类型，则不应该为这个结构体类型声明值类型属主的方法。</li></ul><p>Go中有四种接口相关的类型转换情形：</p><ol><li>将一个非接口值转换为一个接口类型。在这样的转换中，此非接口值的类型必须实现了此接口类型。</li><li>将一个接口值转换为另一个接口类型（前者接口值的类型实现了后者目标接口类型）。</li><li>将一个接口值转换为一个非接口类型（此非接口类型必须实现了此接口值的接口类型）。</li><li>将一个接口值转换为另一个接口类型（前者接口值的类型未实现后者目标接口类型，但是前者的动态类型有可能实现了目标接口类型）。</li></ol><h3 id="断言"><a class="header-anchor" href="#断言"></a>断言</h3><p>断言<code>i.(T)</code>，其中<code>i</code>为一个接口值,<code>T</code>可以为：</p><ul><li>任意一个非接口类型。</li><li>或者一个任意接口类型。<br><code>type-switch</code>:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> aSimpleStatement; v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> TypeA:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> TypeB, TypeC:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>aSimpleStatement;</code>部分是可选的简单语句，<code>v</code>可要可不要(如果要，必须是个短变量声明)，视实际情况而定。不能使用<code>fallthrough</code></p><p>接口直接定义和嵌套效果是一样的，它们只在形式上有差别，实际方法集完全一致。比如下述<code>Ic,Id</code>接口就是一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ia <span class="keyword">interface</span> &#123;</span><br><span class="line">fa()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Ib = <span class="keyword">interface</span> &#123;</span><br><span class="line">fb()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Ic <span class="keyword">interface</span> &#123;</span><br><span class="line">fa()</span><br><span class="line">fb()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Id = <span class="keyword">interface</span> &#123;</span><br><span class="line">Ia <span class="comment">// 内嵌Ia</span></span><br><span class="line">Ib <span class="comment">// 内嵌Ib</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内嵌"><a class="header-anchor" href="#内嵌"></a>内嵌</h3><p>即在结构体声明中，不声明变量名，只有变量类型。<br>编译器对于内嵌变量，会隐式声明一个和变量类型相同的变量。<br>内嵌的限制：</p><ul><li><code>T</code>不能是一个定义的指针类型和基类型是指针接口类型的类型。</li><li><code>*T</code>中的<code>T</code>也同样不能是一个定义的指针类型和基类型是指针接口类型的类型。</li><li>不能内嵌自己</li><li>不能包含两个相同的基类型相同的内嵌</li></ul><p>在调用过程中，内嵌的字段可以省略。比如<code>A.B.func1</code>，其中<code>B</code>是内嵌变量，那么可以写为<code>A.func1</code>。类似其他语言的继承方式(<a href="https://en.wikipedia.org/wiki/Composition_over_inheritance" target="_blank" rel="noopener">两种方式的优劣</a>)。但是要注意：</p><ul><li>如果<code>A</code>也实现了<code>func1</code>，那么<code>A.func1</code>调用只会调用最浅的一层，即<code>A</code>类型的<code>func1</code>。（遮挡）</li><li>如果<code>A</code>类型中同时有<code>B</code>和<code>C</code>同时实现了<code>func2</code>，那么就不能进行省略缩写。（碰撞）</li></ul><p>来自不同库的相同函数名，是不会发生碰撞和遮挡的。<br>内嵌方法获取：</p><ul><li>类型<code>struct{T}</code>和<code>*struct{T}</code>均将获取类型<code>T</code>的所有方法。</li><li>类型<code>*struct{T}</code>、<code>struct{*T}</code>和<code>*struct{*T}</code>都将获取类型<code>*T</code>的所有方法。<br>简化就是有<code>T</code>的就能获取<code>T</code>的方法，有<code>*</code>的，就能获取到<code>*T</code>的方法</li></ul><h3 id="提升方法值的正规化和估值"><a class="header-anchor" href="#提升方法值的正规化和估值"></a>提升方法值的正规化和估值</h3><p>以下面的代码为例：</p><ul><li>提升方法表达式s.M1的完整形式为s.T.X.M1。 将此完整形式中的隐式取地址和解引用操作转换为显式操作之后的结果为(*s.T).X.M1。 在运行时刻，属主实参(*s.T).X被估值并且估值结果的一个副本被存储下来以供后用。 此估值结果为1，这就是为什么调用f()总是打印出1。</li><li>提升方法表达式s.M2的完整形式为s.T.X.M2。 将此完整形式中的隐式取地址和解引用操作转换为显式操作之后的结果为(&amp;(*s.T).X).M2。 在运行时刻，属主实参&amp;(*s.T).X被估值并且估值结果的一个副本被存储下来以供后用。 此估值结果为提升字段s.X（也就是(*s.T).X）的地址。 任何对s.X的修改都可以通过解引用此地址而反映出来，但是对s.T的修改是不会通过此地址反映出来的。 这就是为什么两个g()调用都打印出了2。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> X <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x X)</span> <span class="title">M1</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *X)</span> <span class="title">M2</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(*x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123; X &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123; *T &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t = &amp;T&#123;X: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s = S&#123;T: t&#125;</span><br><span class="line"><span class="keyword">var</span> f = s.M1 <span class="comment">// &lt;=&gt; (*s.T).X.M1</span></span><br><span class="line"><span class="keyword">var</span> g = s.M2 <span class="comment">// &lt;=&gt; (&amp;(*s.T).X).M2</span></span><br><span class="line">s.X = <span class="number">2</span></span><br><span class="line">f() <span class="comment">// 1</span></span><br><span class="line">g() <span class="comment">// 2</span></span><br><span class="line">s.T = &amp;T&#123;X: <span class="number">3</span>&#125;</span><br><span class="line">f() <span class="comment">// 1</span></span><br><span class="line">g() <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非类型安全指针"><a class="header-anchor" href="#非类型安全指针"></a>非类型安全指针</h3><ul><li>非类型安全指针值<code>unsafe.Pointer</code>是指针但<code>uintptr</code>值是整数，虽然<code>uintptr</code>常常用来存放指针值。</li><li>不再被使用的内存块的回收时间点是不确定的，指针值存放在<code>uintptr</code>中，垃圾回收是检测不到的。</li><li>一个值的地址在程序运行中可能改变，比如切片扩容<br><a href="https://golang.google.cn/pkg/unsafe/#Pointer" target="_blank" rel="noopener">正确使用非安全指针的六种模式</a></li></ul><ol><li><p>将类型<code>*T1</code>的一个值转换为非类型安全指针值，然后将此非类型安全指针值转换为类型<code>*T2</code>。比如下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> MyString <span class="keyword">string</span></span><br><span class="line">ms := []MyString&#123;<span class="string">"C"</span>, <span class="string">"C++"</span>, <span class="string">"Go"</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, ms)  <span class="comment">// [C C++ Go]</span></span><br><span class="line"><span class="comment">// ss := ([]string)(ms) // 编译错误</span></span><br><span class="line">ss := *(*[]<span class="keyword">string</span>)(unsafe.Pointer(&amp;ms))</span><br><span class="line">ss[<span class="number">1</span>] = <span class="string">"Rust"</span></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, ms) <span class="comment">// [C Rust Go]</span></span><br><span class="line"><span class="comment">// ms = []MyString(ss) // 编译错误</span></span><br><span class="line">ms = *(*[]MyString)(unsafe.Pointer(&amp;ss))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种类型转换共享底层数据结构，在1.17开始也可以用<code>unsafe.Slice((*string)(&amp;ms[0]), len(ms))</code></p></li><li><p>将一个非类型安全指针值转换为一个uintptr值，然后使用此uintptr值。</p></li><li><p>将一个非类型安全指针转换为一个uintptr值，然后此uintptr值参与各种算术运算，再将算术运算的结果uintptr值转回非类型安全指针。注：<code>Pointer</code>-&gt;<code>uintptr</code>-&gt;<code>Pointer</code>这个过程的转换，应该一行就写完，避免中途变为<code>uintptr</code>时，对应的地址解引用，被垃圾回收；以及一些操作可能导致协程堆栈大小改变，使引用的地址失效。</p></li><li><p>将非类型安全指针值转换为<code>uintptr</code>值并传递给<code>syscall.Syscall</code>函数调用。这个是<code>syscall.Syscall</code>函数特权，它能保证进入这个函数后，改指针对应的地址不被垃圾回收或者被移动。注意从<code>1.15</code>后，调用的参数形式必须是<code>uintptr(anUnsafePointer)</code>，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syscall.Syscall(syscall.SYS_READ, <span class="keyword">uintptr</span>(fd),</span><br><span class="line"><span class="keyword">uintptr</span>(unsafe.Pointer(p)), <span class="keyword">uintptr</span>(n))</span><br></pre></td></tr></table></figure></li><li><p>将<code>reflect.Value.Pointer</code>或者<code>reflect.Value.UnsafeAddr</code>方法的<code>uintptr</code>返回值<strong>立即</strong>转换为非类型安全指针。</p></li><li><p>将一个<code>reflect.SliceHeader</code>或者<code>reflect.StringHeader</code>值的<code>Data</code>字段转换为非类型安全指针，以及其逆转换。这种方式可以直接操作<code>slice</code>和<code>string</code>的底层数据。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"unsafe"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"reflect"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [...]<span class="keyword">byte</span>&#123;<span class="string">'G'</span>, <span class="string">'o'</span>, <span class="string">'l'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'g'</span>&#125;</span><br><span class="line">s := <span class="string">"Java"</span></span><br><span class="line">hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">hdr.Data = <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;a))</span><br><span class="line">hdr.Len = <span class="built_in">len</span>(a)</span><br><span class="line">fmt.Println(s) <span class="comment">// Golang</span></span><br><span class="line"><span class="comment">// 现在，字符串s和切片a共享着底层的byte字节序列，</span></span><br><span class="line"><span class="comment">// 从而使得此字符串中的字节变得可以修改。</span></span><br><span class="line">a[<span class="number">2</span>], a[<span class="number">3</span>], a[<span class="number">4</span>], a[<span class="number">5</span>] = <span class="string">'o'</span>, <span class="string">'g'</span>, <span class="string">'l'</span>, <span class="string">'e'</span></span><br><span class="line">fmt.Println(s) <span class="comment">// Google</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>-gcflags=all=-d=checkptr</code>编译器动态分析选项可以检测很多非类型安全指针的错误使用。<br>关于<code>(*reflect.SliceHeader).Data</code>可能导致指针解引用，导致数据丢失问题，可参考：<a href="https://stackoverflow.com/questions/51187973/how-to-create-an-array-or-a-slice-from-an-array-unsafe-pointer-in-golang" target="_blank" rel="noopener">How to create an array or a slice from an array unsafe.Pointer</a></p><h3 id="泛型"><a class="header-anchor" href="#泛型"></a>泛型</h3><p><strong>定义</strong>：是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，而这种参数类型可以用在<code>类</code>、<code>方法</code>和<code>接口</code>中，分别被称为<code>泛型类</code>、<code>泛型方法</code>、<code>泛型接口</code>。<br><em>注意:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型</em><br><a href="https://zhuanlan.zhihu.com/p/382239048" target="_blank" rel="noopener">可参考</a></p><h3 id="反射"><a class="header-anchor" href="#反射"></a>反射</h3><p>Go反射机制设计的目标之一是任何非反射操作都可以通过反射机制来完成。<br>我们可以通过反射列出一个类型的<strong>所有方法和一个结构体类型的所有（导出和非导出）字段的类型</strong><br>虽然<code>reflect.Type.NumField</code>方法返回一个结构体类型的所有字段（包括非导出字段）的数目，但是<a href="https://pkg.go.dev/reflect#pkg-note-BUG" target="_blank" rel="noopener">不推荐</a>使用方法<code>reflect.Type.FieldByName</code>来获取非导出字段。<br>我们可以通过反射来检视结构体字段的标签信息,可以使用对应的<code>Get</code>和<code>Lookup</code>方法获取检视和获取相应的值。<br><code>reflect</code>代码包也提供了一些其它函数来动态地创建出来一些非定义组合类型。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"reflect"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ta := reflect.ArrayOf(<span class="number">5</span>, reflect.TypeOf(<span class="number">123</span>))</span><br><span class="line">fmt.Println(ta) <span class="comment">// [5]int</span></span><br><span class="line">tc := reflect.ChanOf(reflect.SendDir, ta)</span><br><span class="line">fmt.Println(tc) <span class="comment">// chan&lt;- [5]int</span></span><br><span class="line">tp := reflect.PtrTo(ta)</span><br><span class="line">fmt.Println(tp) <span class="comment">// *[5]int</span></span><br><span class="line">ts := reflect.SliceOf(tp)</span><br><span class="line">fmt.Println(ts) <span class="comment">// []*[5]int</span></span><br><span class="line">tm := reflect.MapOf(ta, tc)</span><br><span class="line">fmt.Println(tm) <span class="comment">// map[[5]int]chan&lt;- [5]int</span></span><br><span class="line">tf := reflect.FuncOf([]reflect.Type&#123;ta&#125;,</span><br><span class="line">[]reflect.Type&#123;tp, tc&#125;, <span class="literal">false</span>)</span><br><span class="line">fmt.Println(tf) <span class="comment">// func([5]int) (*[5]int, chan&lt;- [5]int)</span></span><br><span class="line">tt := reflect.StructOf([]reflect.StructField&#123;</span><br><span class="line">&#123;Name: <span class="string">"Age"</span>, Type: reflect.TypeOf(<span class="string">"abc"</span>)&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(tt)            <span class="comment">// struct &#123; Age string &#125;</span></span><br><span class="line">fmt.Println(tt.NumField()) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射使用的三个限制（截止Go 1.17）：</p><ol><li>我们无法通过反射动态创建一个接口类型。</li><li>使用反射动态创建结构体类型的时候可能会有各种不完美的情况出现。</li><li>我们无法通过反射来声明一个新的类型。</li></ol><p>一个<code>reflect.Value</code>值的<code>CanSet</code>方法将返回此<code>reflect.Value</code>值代表的Go值是否可以被修改（可以被赋值）。 如果一个Go值可以被修改，则我们可以调用对应的<code>reflect.Value</code>值的<code>Set</code>方法来修改此Go值。<br><em>注意：<code>reflect.ValueOf</code>函数直接返回的<code>reflect.Value</code>值都是不可修改的。</em></p><p><code>reflect</code>标准库包中也提供了一些对应着内置函数或者各种非反射功能的函数。 下面这个例子展示了如何利用这些函数将一个自定义泛型函数绑定到不同的类型的函数值上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"reflect"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InvertSlice</span><span class="params">(args []reflect.Value)</span> []<span class="title">reflect</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">inSlice, n := args[<span class="number">0</span>], args[<span class="number">0</span>].Len()</span><br><span class="line">outSlice := reflect.MakeSlice(inSlice.Type(), <span class="number">0</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">element := inSlice.Index(i)</span><br><span class="line">outSlice = reflect.Append(outSlice, element)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []reflect.Value&#123;outSlice&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bind</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;, </span></span></span><br><span class="line"><span class="function"><span class="params">f <span class="keyword">func</span> ([]reflect.Value)</span> []<span class="title">reflect</span>.<span class="title">Value</span>)</span> &#123;</span><br><span class="line"><span class="comment">// invert代表着一个函数值。</span></span><br><span class="line">invert := reflect.ValueOf(p).Elem()</span><br><span class="line">invert.Set(reflect.MakeFunc(invert.Type(), f))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> invertInts <span class="function"><span class="keyword">func</span><span class="params">([]<span class="keyword">int</span>)</span> []<span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">Bind</span><span class="params">(&amp;invertInts, InvertSlice)</span></span></span><br><span class="line"><span class="function"><span class="title">fmt</span>.<span class="title">Println</span><span class="params">(invertInts([]<span class="keyword">int</span>&#123;2, 3, 5&#125;)</span>) // [5 3 2]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">invertStrs</span> <span class="title">func</span><span class="params">([]<span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">Bind</span><span class="params">(&amp;invertStrs, InvertSlice)</span></span></span><br><span class="line">fmt.Println(invertStrs([]string&#123;"Go", "C"&#125;)) // [C Go]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：非导出结构体字段值不能用做反射函数调用中的实参</em><br><code>reflect.Value</code>类型的<code>TrySend</code>和<code>TryRecv</code>方法对应着只有一个<code>case</code>分支和一个<code>default</code>分支的<code>select</code>流程控制代码块。也就是非阻塞发送和接收。<br>我们可以使用<code>reflect.Select</code>函数在运行时刻来模拟具有不定<code>case</code>分支数量的<code>select</code>流程控制代码块。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"reflect"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">vc := reflect.ValueOf(c)</span><br><span class="line">succeeded := vc.TrySend(reflect.ValueOf(<span class="number">123</span>))</span><br><span class="line">fmt.Println(succeeded, vc.Len(), vc.Cap()) <span class="comment">// true 1 1</span></span><br><span class="line"></span><br><span class="line">vSend, vZero := reflect.ValueOf(<span class="number">789</span>), reflect.Value&#123;&#125;</span><br><span class="line">branches := []reflect.SelectCase&#123;</span><br><span class="line">&#123;Dir: reflect.SelectDefault, Chan: vZero, Send: vZero&#125;,</span><br><span class="line">&#123;Dir: reflect.SelectRecv, Chan: vc, Send: vZero&#125;,</span><br><span class="line">&#123;Dir: reflect.SelectSend, Chan: vc, Send: vSend&#125;,</span><br><span class="line">&#125;</span><br><span class="line">selIndex, vRecv, sentBeforeClosed := reflect.Select(branches)</span><br><span class="line">fmt.Println(selIndex)         <span class="comment">// 1</span></span><br><span class="line">fmt.Println(sentBeforeClosed) <span class="comment">// true</span></span><br><span class="line">fmt.Println(vRecv.Int())      <span class="comment">// 123</span></span><br><span class="line">vc.Close()</span><br><span class="line"><span class="comment">// 再模拟一次select流程控制代码块。因为vc已经关闭了，</span></span><br><span class="line"><span class="comment">// 所以需将最后一个case分支去除，否则它可能会造成一个恐慌。</span></span><br><span class="line">selIndex, _, sentBeforeClosed = reflect.Select(branches[:<span class="number">2</span>])</span><br><span class="line">fmt.Println(selIndex, sentBeforeClosed) <span class="comment">// 1 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Go 1.17开始，一个切片可以被转化为一个相同元素类型的数组的指针类型:<code>Value.ConvertibleTo(T Type)</code>。 同时引入了一个<code>Value.CanConvert(T Type)</code>方法，用来检查一个转换是否会成功（即不会产生恐慌）</p><h3 id="函数退出方式"><a class="header-anchor" href="#函数退出方式"></a>函数退出方式</h3><ol><li>正常返回，<code>return</code></li><li><code>panic</code>，能被<code>recover</code>捕获，阻止传播。</li><li>调用<code>runtime.Goexit</code>，退出函数，并传播到父函数，直到整个进程退出。</li></ol><p>当函数调用中产生多次<code>panic</code>(比如<code>defer</code>里又产生了<code>panic</code>，或者子协程<code>panic</code>，主协程又<code>panic</code>)则新的<code>panic</code>将覆盖旧的<code>panic</code></p><p>在下面的情况下，recover函数调用的返回值为nil(即空操作)：</p><ul><li>传递给相应panic函数调用的实参为nil；</li><li>当前协程并没有处于恐慌状态；</li><li>recover函数并未直接在一个延迟函数调用中调用。</li></ul><p>一些recover调用相当于空操作（No-Op）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>() <span class="comment">// 空操作</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>() <span class="comment">// 空操作</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>() <span class="comment">// 空操作</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">recover</span>() <span class="comment">// 空操作</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>() <span class="comment">// 空操作</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">recover</span>()       <span class="comment">// 空操作</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">recover</span>() <span class="comment">// 空操作</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"bye"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>() <span class="comment">// 将恢复恐慌"byte"</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"bye"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在任何时刻，一个协程中只有最新产生的恐慌才能够被恢复。</p><p>代码块：<br><img src="/2022/01/07/《Go101》读书笔记/%E4%BB%A3%E7%A0%81%E5%9D%97.png" alt></p><h3 id="表达式估值顺序规则"><a class="header-anchor" href="#表达式估值顺序规则"></a>表达式估值顺序规则</h3><p>一个表达式将在其所依赖的其它表达式估值之后进行估值<br>比如下面的代码将打印<code>yzxw</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">_ = f(<span class="string">"w"</span>, x)</span><br><span class="line">x = f(<span class="string">"x"</span>, z)</span><br><span class="line">y = f(<span class="string">"y"</span>)</span><br><span class="line">z = f(<span class="string">"z"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(s <span class="keyword">string</span>, deps ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f(<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>白皮书中关于估值的描述：<br><em>当估值一个表达式、赋值语句或者函数返回语句中的操作数时，所有的函数调用、方法调用和通道操作将按照它们在代码中的出现顺序进行估值。</em><br>其中有个示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y[z.f()], ok = g(h(a, b), i()+x[j()], &lt;-c), k()</span><br></pre></td></tr></table></figure><p>在此赋值语句中，</p><ul><li><code>c</code>是一个通道表达式，它将被估值为一个通道值；</li><li><code>g</code>、<code>h</code>、<code>i</code>、<code>j</code>和<code>k</code>是一些函数表达式，它们将被估值为一些函数值；</li><li><code>f</code>是表达式<code>z</code>值的一个方法。<br>综合考虑上一节和本节上面已经提到的规则，编译器应该保证下列在运行时刻的估值顺序：</li><li>此赋值中涉及到的函数调用、方法调用和通道操作必须按照这样的顺序执行：<code>z.f()→h()→i()→j()→&lt;-c→g()→k()</code>；</li><li>调用<code>h()</code>在表达式<code>h</code>、<code>a</code>和<code>b</code>估值之后调用；</li><li><code>y[]</code>在方法调用<code>z.f()</code>执行之后被估值；</li><li>方法调用<code>z.f()</code>在表达式<code>z</code>估值之后执行；</li><li><code>x[]</code>在调用<code>j()</code>执行之后被估值。<br>然而，下列次序在Go白皮书中未指定，它们依赖于具体编译器实现：</li><li>表达式<code>y</code>、<code>z</code>、<code>g</code>、<code>h</code>、<code>a</code>、<code>b</code>、<code>x</code>、<code>i</code>、<code>j</code>、<code>c</code>和<code>k</code>之间的相对估值顺序；</li><li>表达式<code>y[]</code>、<code>x[]</code>和<code>&lt;-c</code>之间的相对估值顺序。</li></ul><p>变量赋值阶段描述：<br><em>一条赋值语句的执行分为两个阶段。 首先，做为目标值的元素索引表达式中的容器值表达式和索引值表达式、做为目标值的指针解引用表达式中的指针值表达式、以及此赋值语句中的其它非目标值表达式将按照上述通常估值顺序估值。 然后，各个单值赋值将按照从左到右的顺序执行。</em><br>可以看一个示例：<code>a, b = b, a</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 估值阶段</span></span><br><span class="line">P0 := &amp;a; P1 := &amp;b</span><br><span class="line">R0 := a; R1 := b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最基本形式：*P0, *P1 = R0, R1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实施阶段</span></span><br><span class="line">*P0 = R0</span><br><span class="line">*P1 = R1</span><br></pre></td></tr></table></figure><p>但是一些同优先级的估值顺序却没有明确，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := <span class="function"><span class="keyword">func</span> <span class="params">(p *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">*p = <span class="number">99</span></span><br><span class="line"><span class="keyword">return</span> *p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x := <span class="number">0</span></span><br><span class="line">y, z := x+<span class="number">1</span>, f(&amp;x)</span><br><span class="line">fmt.Println(y, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码，输出<code>100 99</code>和<code>1 99</code>都是合理的，不同编译器实现方式不同。</p><p><code>switch-case</code>估值顺序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"f(%v) is called.\n"</span>, n)</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> x := f(<span class="number">3</span>); x + f(<span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">case</span> f(<span class="number">5</span>):</span><br><span class="line"><span class="keyword">case</span> f(<span class="number">6</span>), f(<span class="number">7</span>), f(<span class="number">8</span>):</span><br><span class="line"><span class="keyword">case</span> f(<span class="number">9</span>), f(<span class="number">10</span>):</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(3) is called.</span><br><span class="line">f(4) is called.</span><br><span class="line">f(5) is called.</span><br><span class="line">f(6) is called.</span><br><span class="line">f(7) is called.</span><br></pre></td></tr></table></figure><p><code>select-case</code>估值顺序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">c &lt;- <span class="number">0</span></span><br><span class="line">fchan := <span class="function"><span class="keyword">func</span><span class="params">(info <span class="keyword">string</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(info)</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line">fptr := <span class="function"><span class="keyword">func</span><span class="params">(info <span class="keyword">string</span>)</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(info)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> *fptr(<span class="string">"aaa"</span>) = &lt;-fchan(<span class="string">"bbb"</span>, <span class="literal">nil</span>): <span class="comment">// blocking</span></span><br><span class="line"><span class="keyword">case</span> *fptr(<span class="string">"ccc"</span>) = &lt;-fchan(<span class="string">"ddd"</span>, c):   <span class="comment">// non-blocking</span></span><br><span class="line"><span class="keyword">case</span> fchan(<span class="string">"eee"</span>, <span class="literal">nil</span>) &lt;- *fptr(<span class="string">"fff"</span>):  <span class="comment">// blocking</span></span><br><span class="line"><span class="keyword">case</span> fchan(<span class="string">"ggg"</span>, <span class="literal">nil</span>) &lt;- *fptr(<span class="string">"hhh"</span>):  <span class="comment">// blocking</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bbb</span><br><span class="line">ddd</span><br><span class="line">eee</span><br><span class="line">fff</span><br><span class="line">ggg</span><br><span class="line">hhh</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure><p>注意：以通道接收操作做为源值的赋值语句中的目标值表达式只有在此通道接收操作被选中之后才会被估值。</p><h3 id="值复制成本"><a class="header-anchor" href="#值复制成本"></a>值复制成本</h3><p><code>值尺寸（value size）</code><br>一个值的尺寸表示此值的直接部分在内存中占用多少个字节，它的间接部分（如果存在的话）对它的尺寸没有贡献。意味着：任何一个特定类型的所有值的尺寸都是相同的。所以我们也常说一个值的尺寸为此值的类型的尺寸。(至少1.17的官方编译器是如此)<br>一般来说，不超过4个原生字(计算机位数*4)，都是小尺寸赋值，代价较小。对于标准编译器来说，除了大尺寸的结构体和数组类型，其它类型均为小尺寸类型。</p><h3 id="通道关闭原则"><a class="header-anchor" href="#通道关闭原则"></a>通道关闭原则</h3><p>不要在数据接收方或者在有多个发送者的情况下关闭通道</p><p>多个接收者和发送者进行通道关闭：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> Max = <span class="number">100000</span></span><br><span class="line"><span class="keyword">const</span> NumReceivers = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">wgReceivers.Add(NumReceivers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// stopCh是一个额外的信号通道。它的发送</span></span><br><span class="line"><span class="comment">// 者为中间调解者。它的接收者为dataCh</span></span><br><span class="line"><span class="comment">// 数据通道的所有的发送者和接收者。</span></span><br><span class="line">toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// toStop是一个用来通知中间调解者让其</span></span><br><span class="line"><span class="comment">// 关闭信号通道stopCh的第二个信号通道。</span></span><br><span class="line"><span class="comment">// 此第二个信号通道的发送者为dataCh数据</span></span><br><span class="line"><span class="comment">// 通道的所有的发送者和接收者，它的接收者</span></span><br><span class="line"><span class="comment">// 为中间调解者。它必须为一个缓冲通道。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stoppedBy <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间调解者</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">stoppedBy = &lt;-toStop</span><br><span class="line"><span class="built_in">close</span>(stopCh)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送者</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">value := rand.Intn(Max)</span><br><span class="line"><span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 为了防止阻塞，这里使用了一个尝试</span></span><br><span class="line"><span class="comment">// 发送操作来向中间调解者发送信号。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> toStop &lt;- <span class="string">"发送者#"</span> + id:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处的尝试接收操作是为了让此发送协程尽早</span></span><br><span class="line"><span class="comment">// 退出。标准编译器对尝试接收和尝试发送做了</span></span><br><span class="line"><span class="comment">// 特殊的优化，因而它们的速度很快。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使stopCh已关闭，如果这个select代码块</span></span><br><span class="line"><span class="comment">// 中第二个分支的发送操作是非阻塞的，则第一个</span></span><br><span class="line"><span class="comment">// 分支仍很有可能在若干个循环步内依然不会被选</span></span><br><span class="line"><span class="comment">// 中。如果这是不可接受的，则上面的第一个尝试</span></span><br><span class="line"><span class="comment">// 接收操作代码块是必需的。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(strconv.Itoa(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收者</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 和发送者协程一样，此处的尝试接收操作是为了</span></span><br><span class="line"><span class="comment">// 让此接收协程尽早退出。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使stopCh已关闭，如果这个select代码块</span></span><br><span class="line"><span class="comment">// 中第二个分支的接收操作是非阻塞的，则第一个</span></span><br><span class="line"><span class="comment">// 分支仍很有可能在若干个循环步内依然不会被选</span></span><br><span class="line"><span class="comment">// 中。如果这是不可接受的，则上面尝试接收操作</span></span><br><span class="line"><span class="comment">// 代码块是必需的。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> value := &lt;-dataCh:</span><br><span class="line"><span class="keyword">if</span> value == Max<span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// 为了防止阻塞，这里使用了一个尝试</span></span><br><span class="line"><span class="comment">// 发送操作来向中间调解者发送信号。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> toStop &lt;- <span class="string">"接收者#"</span> + id:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(strconv.Itoa(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">wgReceivers.Wait()</span><br><span class="line">log.Println(<span class="string">"被"</span> + stoppedBy + <span class="string">"终止了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：信号通道toStop的容量必须至少为1。 如果它的容量为0，则在中间调解者还未准备好的情况下就已经有某个协程向toStop发送信号时，此信号将被抛弃。</p><h2 id="内存相关"><a class="header-anchor" href="#内存相关"></a>内存相关</h2><h3 id="内存空间分配："><a class="header-anchor" href="#内存空间分配："></a>内存空间分配：</h3><p><a href="https://www.cnblogs.com/mayanan/p/16012426.html" target="_blank" rel="noopener">变量逃逸分析</a><br>分析逃逸的编译参数：<code>go run -gcflags &quot;-m -l&quot; main.go</code><br><code>开辟在堆的好处</code>：</p><ul><li>从栈上开辟内存块比在堆上快得多，并且不会产生内存碎片。</li><li>开辟在栈上的内存块不需要被垃圾回收；</li><li>开辟在栈上的内存块对CPU缓存更加友好。</li></ul><p>使用内置<code>new</code>函数开辟的内存可能开辟在堆上，也可能开辟在栈上。<br>当一个协程的栈的大小改变时，一个新的内存段将申请给此栈使用。原先已经开辟在老的内存段上的内存块将很有可能被转移到新的内存段上，或者说这些内存块的地址将改变。 相应地，引用着这些开辟在此栈上的内存块的指针（它们同样开辟在此栈上）中存储的地址也将得到刷新。示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">int</span> <span class="comment">// 防止f被内联</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">1</span>&lt;&lt;<span class="number">20</span>]<span class="keyword">byte</span> <span class="comment">// 使栈增长</span></span><br><span class="line"><span class="keyword">return</span> a[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line"><span class="built_in">println</span>(&amp;x)</span><br><span class="line">f(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">println</span>(&amp;x)<span class="comment">//该地址和上面的地址不一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存块儿回收时机"><a class="header-anchor" href="#内存块儿回收时机"></a>内存块儿回收时机</h3><ul><li>为包级变量的直接部分开辟的内存块永远不会被回收。</li><li>每个协程的栈将在此协程退出之时被整体回收。</li><li>开辟在堆上的不再被使用的内存块将在以后某个时刻被垃圾回收器回收掉。</li></ul><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><p>如果你已经初步学习过golang，这本书也可以作为进阶的一本书阅读。但是个人不推荐这本书。整体来说一些知识点的表达不是很清醒，也不够明朗。但是其中一些知识点，倒是可以学习学习。</p><h3 id="相关"><a class="header-anchor" href="#相关"></a>相关</h3><p><a href="https://draveness.me/golang/" target="_blank" rel="noopener">go语言设计与实现</a> 和这本书定位一样，属于golang进阶的书，但是这本书感觉更好(虽然我还没有怎么看)</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《原则》读书笔记</title>
      <link href="/2021/10/28/%E3%80%8A%E5%8E%9F%E5%88%99%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/28/%E3%80%8A%E5%8E%9F%E5%88%99%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>教会你如何建立自己的原则，构建属于完美独特的自我(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>主题：教你做事<br>类别：人文社科-&gt;实用性<br>概要：俗话说的鸡汤书，如果是个能实用的鸡汤书，并且你能照着做，那么就很棒了。</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>人们所拥有的知识相比未知的知识是少的可怜的，知道自己的无知是难能可贵的事情。重要的是，当你遇到一个未知的事务、场景或者困惑时，如何进行处理，则是你原则存在的重要意义。而本书则是让你明确和构建你自己的原则，并加以实施。</p><h2 id="拥有你自己的原则"><a class="header-anchor" href="#拥有你自己的原则"></a>拥有你自己的原则</h2><ol><li>独立思考并决定：<ol><li>你想要什么；</li><li>事实是什么；</li><li>面对事实，你如何实现自己的愿望</li></ol></li><li>要保持谦逊和心胸开阔，以便你能动用自己的最佳思维</li><li>写下你的原则，保持你的原则做事</li><li>时间就像一条河流，载着我们顺流而下，遇到现实，需要决策，但我们无法停留，也无法回避，只能以最好的方式应对。</li><li>每日坚持做一些事情，总有你意想不到的收获。</li><li>“我是对的”到“我怎么知道我是对的”：<ol><li>找到与我观点不同的最聪明的人，以便自己能够努力理解他们的推理。</li><li>知道自己在什么时候不能有明确的意见，不急于下结论。</li><li>逐步归纳永恒和普适的原则，对其进行测试，将其系统化。</li><li>通过平衡风险来保持较大的回报，并降低下行波动</li></ol></li><li>有时生活会给你当头一棒，不要失去信念。重新站起来的你会更加强大。</li><li>我发现如果我拥有15—20个良好的、互不相关的回报流，我就能大大降低我的风险，同时又不减少我的预期收益。</li><li>任何组织成功的关键都是人和文化。</li><li>塑造者：在某一方面拥有宏达而独特的愿景，并能使其成为现实。</li><li>良好的原则是应对现实的方法。</li><li>每个人都需要花很多时间来思考和摸索适合自己的原则。</li><li>考察影响你的那些事物的规律，从而理解其背后的因果关系，并学习有效应对这些事物的原则。</li><li>我认为一切事情的发生都是由于反复出现、不断演进的因果关系。</li></ol><h2 id="生活原则"><a class="header-anchor" href="#生活原则"></a>生活原则</h2><ol><li>拥抱现实，应对现实<ol><li>做一个超级现实的人<ol><li>梦想+现实+决心=成功的生活</li></ol></li><li>真相（或者更精确地说，对现实的准确理解）是任何良好结果的根本依据</li><li>做到头脑极度开放、极度透明<ol><li>对于快速学习和有效改变而言，头脑极度开放、极度透明是价值无限的。</li><li>不要担心其他人的看法，使之成为你的障碍</li><li>拥抱极度求真和极度透明将带来更有意义的工作和更有意义的人际关系</li></ol></li><li>观察自然，学习现实规律<ol><li><strong>自上而下</strong>：努力找到这些东西背后的唯一驱动法则或规律。例如，在理解市场时，人可以研究影响所有经济和市场的普适法则，如供求关系；在理解物种时，人可以集中了解基因密码是如何对所有物种发生作用的。</li><li><strong>自下而上</strong>：研究每种具体情况及其背后的法则或规律，例如，小麦市场独特的法则或规律，或者使鸭子区别于其他物种的基因序列。</li><li>不要固守你对事物“应该”是什么样的看法，这将使你无法了解真实的情况</li><li>什么是好什么是坏？ 一个东西要“好”，就必须符合现实的规律，并促进整体的进化，这能带来最大的回报</li><li>进化是宇宙中最强大的力量，是唯一永恒的东西，是一切的驱动力</li><li>进化是生命最大的成就和最大的回报<ol><li>个体的激励机制必须符合群体的目标</li><li>现实为了整体趋向最优化，而不是为了个体</li><li>通过快速试错以适应现实是无价的</li><li>意识到你既是一切又什么都不是，并决定你想成为什么样子</li><li>你的未来取决于你的视角</li></ol></li><li>理解自然提供的现实教训<ol><li>把你的进化最大化</li><li>记住“没有痛苦就没有收获”</li><li>自然的一项根本法则是，为了赢得力量，人必须努力突破极限，而这是痛苦的。</li></ol></li><li>痛苦+反思=进步<ol><li>迎接而非躲避痛苦<ol><li>找到、接受，并学会如何应对你的弱点；</li><li>更喜欢周围的人对你坦诚，而不是隐瞒对你的负面看法；</li><li>展现真实的自我，而不是强行把弱点伪装成优势</li></ol></li><li>接受严厉的爱</li></ol></li><li>考虑后续与再后续的结果</li><li>接受结果</li><li>从更高的层次俯视机器<ol><li>把自己想象成一部在大机器里运转的小机器，并明白你有能力改变你的机器以实现更好的结果</li><li>通过比较你实现的结果和你的目标，你就能确定如何改进你的机器</li><li>区别作为机器设计者的你和作为机器中工作者的你</li><li>大多数人犯下的最大错误是不客观看待自己以及其他人，这导致他们一次次地栽在自己或其他人的弱点上</li><li>成功的人能超越自身，客观看待事物，并管理事物以塑造改变</li><li>在你不擅长的领域请教擅长的其他人，这是一个你无论如何都应该培养的出色技能，这将帮助你建立起安全护栏，避免自己做错事</li><li>因为客观看待自身很困难，所以你需要依赖其他人的意见，以及全部证据</li><li>如果你的头脑足够开放，足够有决心，你几乎可以实现任何愿望。找到一条适合自己的路。</li></ol></li><li>帮助你鼓起勇气克服自身弱点的方式：<ol><li>不要混淆你的愿望和事实。</li><li>不要为自身形象担心，只需关心能不能实现你的目标。</li><li>不要过于重视直接结果而忽视后续、再后续的结果。</li><li>不要让痛苦妨碍进步。</li><li>不要把不好的结果归咎于任何人，从自己身上找原因</li></ol></li></ol></li><li><strong>实现目标的五步法</strong>(你要成功就必须做好每一步，而且必须按顺序一步步来，不要交叉)：<ol><li>有明确的目标<ol><li>排列优先顺序，你不可能得到所有东西，你只能选择其中一部分。</li><li>不要混淆目标和欲望</li><li>调和你的目标和欲望，以明确你在生活中真正想要的东西</li><li>不要把成功的装饰误认为成功本身(以为自己买了名牌包包，就觉得自己很牛B)</li><li>永远不要因为你觉得某个目标无法实现就否决它</li><li>谨记伟大的期望创造伟大的能力(如果你定的目标能轻易实现，自我要求就太低了)</li><li>知道如何对待挫折(控制损失)和知道如何前进一样重要。</li></ol></li><li>找到阻碍你实现这些目标的问题，并且不容忍问题<ol><li>把令人痛苦的问题视为考验你的潜在进步机会</li><li>不要逃避问题，因为问题根植于看起来并不美好的残酷现实</li><li>要精准地找到问题所在</li><li>不要把问题的某个原因误认为问题本身</li><li>区分大问题和小问题</li><li>找出一个问题之后，不要容忍问题</li></ol></li><li>准确诊断问题，找到问题的根源<ol><li>先把问题是什么弄明白，再决定怎么做</li><li>区分直接原因和根本原因，消灭根本原因才是王道。</li><li>认识到了解人（包括你自己）的特性，有助于对其形成合理预期</li></ol></li><li>规划可以解决问题的方案<ol><li>前进之前先回顾</li><li>把你的问题看作一部机器产生的一系列结果</li><li>谨记实现你的目标通常有很多途径，你只需要找出有效的一条</li><li>把你的方案设想为一个电影剧本，然后循序渐进地思考由谁来做什么事</li><li>把你的方案写下来，让所有人都能看到，并对照方案执行</li><li>要明白，规划一个好方案不一定需要很多时间，避免浪费大量的时间也避免草草决定。</li></ol></li><li>做一切必要的事来践行这些方案，实现成果<ol><li>规划做得再好，不执行也无济于事。规划执行中，谨记与目标之间的联系。</li><li>良好工作习惯的重要性常被大大低估。</li><li>建立清晰的衡量标准来确保你在严格执行方案<br>注：谨记，这五步中的每一步都源自你的价值观。你的价值观决定了你想要什么，即你的目标。同时谨记，这五步是层层递进的。每完成一步，你都会获得一定的信息，很可能有助于你改进其他步骤。这五步都完成后，你可以设定一个新目标，再做一遍。如果这个流程行之有效，你的目标会比你的规划改变得慢，你的规划会比你的任务改变得慢<br><strong>如果你找到了解决方案，弱点是不重要的</strong></li></ol></li></ol></li><li>有些人擅长自己思考解决问题，有些人擅长学习请教他人而解决问题。通常你两个方面都需要。</li></ol></li><li>做到头脑极度开放<ol><li>认识你的两大障碍<ol><li>自我意识<ol><li>潜意识的自我防卫，比如恐惧，需要生存，怕孤独</li><li>总是存在两个我在进行斗争。理性的我和感谢的我</li></ol></li><li>思维盲点<ol><li>你只能看到事务的一面，而不能都看全，人总会有思维的盲点。</li></ol></li></ol></li><li>奉行头脑极度开放<ol><li>诚恳地相信你也许并不知道最好的解决办法是什么，并认识到，与你知道的东西相比，能不能妥善处理“不知道”才是更重要的。</li><li>认识到决策应当分成两步：先分析所有相关信息，然后决定</li><li>不要担心自己的形象，只关心如何实现目标</li><li>认识到你不能“只产出不吸纳”</li><li>认识到为了能够从他人的角度看待事物，你必须暂时悬置判断，只有设身处地，你才能合理评估另一种观点的价值</li><li>谨记，你是在寻找最好的答案，而不是你自己能得出的最好答案</li><li>水平相当的人才应当争论，而水平相差比较大的人，应当先学习。</li></ol></li><li>领会并感激：深思熟虑的意见分歧<ol><li>站着理性的基础上和值得探讨的人一起讨论，分析其中的分歧。</li><li>为最坏的情况做准备，以尽量使其不那么糟糕</li></ol></li><li>识别你应当注意的头脑封闭和头脑开放的不同迹象<ol><li>大脑封闭的人不喜欢自己的观点被挑战…</li><li>头脑开放的人更想了解为什么出现分歧…</li></ol></li><li>如何做到头脑极度开放<ol><li>利用痛苦来引导自己进行高质量的思考</li><li>将头脑开放作为一种习惯</li><li>认识自己的思维盲点</li><li>假如很多可信的人都说你正在做错事，只有你不这么看，你就要想想自己是不是看偏了</li><li>冥想，静下心来好好思考和整理一些事情，站在更高位维度看待一些东西。</li><li>重视证据，并鼓励其他人也这么做</li><li>尽力帮助其他人也保持头脑开放</li><li>使用以证据为基础的决策工具</li><li>知道什么时候应当停止为自己的观点辩护，信任自己的决策程序</li></ol></li><li>人一生最大的决策在于是否愿意去追逐真像。</li></ol></li><li>理解人与人的不同<ol><li>明白你与其他人的思维方式能带来的力量</li><li>我们拥有各种天生特征，既可能帮助自己也可能伤害自己，取决于如何应用</li><li>理解大脑里的主要斗争，以及如何控制这些斗争，以实现“你”的愿望<ol><li>要明白，意识与潜意识在不断斗争</li><li>要知道最常发生的斗争是情绪和思考的斗争</li><li>调和你的情绪和思考</li><li>善择你的习惯</li><li>坚持友善地训练“较低层次的你”，以养成好的习惯</li><li>理解右脑思维和左脑思维的差别，也就是线性思维和发散思维的区别。</li><li>理解大脑可以改变的程度</li></ol></li><li>认识自己和他人的特性<ol><li>创造者:提出新想法、新概念。他们喜欢非结构化、抽象的活动，喜欢创新和不走寻常路。</li><li>推进者:传递这些新想法并推进。他们喜欢感觉和人际关系，管理各种人的因素。他们非常善于激发工作热情。</li><li>改进者:挑战想法。他们分析计划以寻找缺陷，然后以很客观、符合逻辑的方式改进计划。他们喜欢事实和理论，以系统性的方式工作。</li><li>贯彻者:也可以叫作执行者。他们确保重要的工作得到执行，目标被实现。他们关注细节和结果。</li><li>变通者:是以上4种类型的结合。他们能根据特定需求调整自身，并能从各种各样的视角看待问题。</li></ol></li><li>大自然塑造万事万物皆有目的。你最需要的勇气不是驱使你战胜别人的勇气，而是不管其他人对你有何冀望，你始终坚持做最真实的自我的勇气。</li><li>无论你要实现什么目标，让合适的人各司其职以支持你的目标，是成功的关键<ol><li>一些决策你应该自己做，一些则应该让更可信的人代理。利用自知之明区分这两种情况，是成功的关键，不管你追求什么</li></ol></li></ol></li><li>学习如何有效决策<ol><li>影响好决策的最大威胁是有害的情绪；决策时先问问自己，我冷静么?</li><li>决策是一个两步流程（先了解后决定）,确定自己了解所有知识了么？</li><li>综合分析眼前的形式：<ol><li>你能做的最重要的决定之一是决定问谁</li><li>不要听到什么信什么</li><li>所有东西都是放在眼前看更大</li><li>不要过度分析细节</li></ol></li><li>综合分析变化中的形势<ol><li>始终记住改善事物的速度和水平，以及两者的关系，你不能在很长的时间里改善某个事情。</li><li>不必过于精确，有些时候不用过于精准，只需要大概估计</li><li>谨记“80/20法则”，并明白关键性的“20%”是什么</li><li>不要做完美主义者</li></ol></li><li>高效地综合考虑各个层次，举个栗子：<ol><li>高层次的全局：我想要能学到很多东西的有意义的工作。<ol><li>次一级的理念：我想成为一名医生。<ol><li>次一级的点：我需要上医学院。<ol><li>再次一级的点：我需要在科学课程上取得好成绩。<ol><li>再再次一级的点：我今晚需要在家学习。</li></ol></li></ol></li></ol></li></ol></li><li>明白你们在谈论细节还是谈论要点</li><li>谨记，决策需要在合理的层次做出，但也应在各层次之间保持一致</li></ol></li><li>综合分析现实、理解如何行动的最好工具是逻辑、理性和常识</li><li>根据预期价值计算做决策：(成功概率-失败概率)*本机<ol><li>不管你押对的概率已经有多大，提高你的押对概率始终有价值</li><li>知道什么时候不要去押注，和知道什么注值得押同样重要</li><li>最好的选择是好处多于坏处的选择，不是毫无坏处的选择</li></ol></li><li>比较更多信息带来的价值和不做决定造成的成本，决定优先顺序<ol><li>先把你的“必做之事”做完，再做你的“想做之事”</li><li>你很可能没有时间处理不重要的事，那最好将它留着，以免自己没有时间处理重要的事</li><li>不要把概率当作可能性</li></ol></li></ol></li><li>成为好决策者的捷径<ol><li>简化</li><li>很多事情都是相似的，你可以用相同的原则来处理。这个原则可以是你自己的，也可以是别人的，好使就行。</li><li>对你的决策进行可信度加权。把你的决策拉出去和可信的人讨论，增加你决策的可信度。</li><li>计算机或其他工具能够更好的帮助你决策。</li><li>任何工具都只是辅助，做决策的主要还是人。</li></ol></li><li>总结：<ol><li>要知道最好的决策时什么，并有勇气做出最好的决策。</li><li>拥抱现实并妥善应对现实。</li><li>你从哪里获得这些原则并不重要，拥有原则、持之以恒地运用原则、不断改进完善原则才最重要。</li><li>做了决策，不行动，和不做一样。</li></ol></li></ol><h2 id="工作原则"><a class="header-anchor" href="#工作原则"></a>工作原则</h2><ol><li>任何组织或机构若想正常运转，其工作原则必须与其成员的生活原则相契合。</li><li>一个机构就像一部机器，主要由两组部件构成：文化和人<ol><li>优秀的机构拥有优秀的人和优秀的文化</li><li>优秀的人具备高尚的品格和出色的能力</li><li>优秀的文化不掩盖问题和分歧，而是公开妥善解决，喜欢让想象力驰骋且愿意开创先河<ol><li>当结果与目标出现不一致时，管理者能否及时发现问题、及时调整工作方案并组织员工弥补缺陷，是其机构能否脱颖而出并在竞争中取胜的关键</li></ol></li><li>严厉之爱有助于成就优异的工作业绩和建立良好的人际关系<ol><li>为了成就伟大事业，对不应妥协的事情就必须坚持立场、寸步不让</li></ol></li><li>基于可信度加权的创意择优是实现有效决策的最佳模式</li><li>极度求真和极度透明</li><li>创意择优=极度求真+极度透明+可信度加权的决策</li><li>原则不能凌驾于常识之上，要知道原则也有不适用的时候。</li></ol></li><li>让热情与工作合二为一，并与志同道合者倾力推进<ol><li>如果人想学到应对不利局面的本领，就需要面对残酷和不确定的现实</li><li>不要惧怕了解事实</li><li>为人要正直，也要求他人保持正直<ol><li>若不想当面议论别人，背地里也不要说，要批评别人就当面指出来</li><li>不要因忠诚于个人而阻碍追求事实和整个机构的利益</li></ol></li><li>营造一种氛围，让每个人都有权了解合理之事，不可保持异议却缄默不语<ol><li>表达出来，并对你的观点负责，否则就走人</li><li>切记要绝对开诚布公</li><li>切莫轻信不诚实之人</li></ol></li><li>要保持极度透明<ol><li>在尽可能做到彻底透明的同时，也要保持必要的谨慎</li><li>要向善于管理信息的人透明，对那些不善管理信息的人，要么不透明，要么将其清除出公司队伍</li></ol></li></ol></li><li>做有意义的工作，发展有意义的人际关系<ol><li>忠于共同的使命，而非对此三心二意之人</li><li>要认识到机构规模过大会对建立有意义的人际关系构成威胁</li><li>要记住很多人只是假装为你工作，而实际上是在追求一己私利</li><li>珍视诚实、能力强、表里如一的员工</li></ol></li><li>打造允许犯错，但不容忍罔顾教训、一错再错的文化<ol><li>意识到错误是事物演变过程中的自然连带部分<ol><li>把失败变成好事</li><li>不要为你自己或他人的错误而懊恼，要珍爱它</li></ol></li><li>不要纠结于一时的成败，要放眼于达成目标</li><li>观察错误模式，判断是否因缺点引起</li><li>记住在经历痛苦后要反思<ol><li>痛苦+反思=进步</li><li>要知道，没有人能客观地看待自己</li><li>教导并强化“吃一堑、长一智”的道理</li><li>知道哪些错误可以接受，哪些错误无法容忍，不要让你的员工犯不可接受的错误</li></ol></li></ol></li><li>求取共识并坚持<ol><li>持开放心态，同时也要坚定果断</li><li>确保工作负责人以开放的心态对待问题和他人的意见</li><li>认识到求取共识是双向的责任<ol><li>有一些很简单的技巧会很有用，比如重复一遍你刚听到的别人的观点，确保你理解正确</li></ol></li><li>自己要通情达理，也期待别人通情达理</li><li>如果由你主持会议，应把握好对话<ol><li>明确会议的主持人和会议的服务对象</li><li>表述要清晰准确，以免造成困惑</li><li>根据目标和优先次序来确定采用什么样的沟通方式，以及相应的人选。</li><li>主持讨论时要果断、开明</li><li>在不同层面的讨论对话中穿梭对照</li><li>谨防“跑题”</li><li>坚持对话的逻辑性，避免情绪化</li><li>注意不要因集体决策而丧失个人责任</li><li>运用两分钟法则避免持续被别人打断</li><li>让对话善始善终，总结会议和对话。</li></ol></li><li>伟大的合作如同爵士乐演奏</li><li>珍惜志同道合者</li><li>如果你发现自己无法调和相互间的主要分歧——尤其是价值观层面的——要考虑是否值得维持这种关系</li></ol></li><li>做决策时要从观点的可信度出发<ol><li>加权投票策略，在大众投票上，为投票加上权重。更有经验的人，解决更多这种类型问题的人，权重越高。</li><li>采用创意择优，需要你了解每个人观点的长处<ol><li>如果你自己无法成功完成某件事，就不要想着指导别人该如何完成</li><li>要知道每个人都有自己的观点，但通常不是什么好点子。(只要集大成的点子才是好点子)</li></ol></li><li>关注可信度最高、与你观点不一致的人，尽量理解其推理过程<ol><li>要分析人们的可信度，以评价其观点正确的可能性</li><li>较可信的观点很可能出自以下两种人：（1）至少曾经三次成功解决过相关问题；（2）对所得结论的因果关系分析很有道理</li><li>若某人并无经验，但其所讲道理似乎符合逻辑且可经受压力测试，则一定要试一试</li><li>要更关注发言人的推理过程，而非其结论</li><li>没经验的人也不乏好点子，有时远远胜过有经验的人</li><li>每个人都应在表达观点时信心满满</li></ol></li><li>考虑好你要扮演老师、学生、同事中的哪个角色…你应该去说教、提问还是辩论<ol><li>学生理解老师比老师理解学生更重要，尽管二者都重要</li><li>每个人都有权利和责任尽力了解重要的事情，还必须保持谦逊和非常开放的心态</li></ol></li><li>要了解人们提出意见的过程和逻辑<ol><li>无论你向谁提问，对方一般都会提供“答案”，所以要仔细考虑要向谁提问</li><li>让每个人都可肆意评论其他人的观点，此举低效且浪费时间</li><li>提防以“我以为…”为开头的发言</li><li>系统梳理员工的工作记录，评估其发言的可信度</li></ol></li><li>处理分歧务必高效<ol><li>知道适时终结辩论，推动就下一步措施形成共识</li><li>可信度加权可以作为工具，但不能取代责任人的决策。但决策者推翻了加权决策结果，那么就要负责任。</li><li>如果你自己没有时间全面检视每个人的想法，则要明智选取具有可信度的观点</li><li>若由你负责做决策，要把可信度加权后得出的结论和你自己的想法做比较</li></ol></li><li>每个人都有权利和义务去设法了解重要的事情<ol><li>沟通是为了获得最佳回应，故应与最相关的人沟通</li><li>以教育或促成共识为目的的沟通，不仅仅是为了获得最佳答案，故应让更多的人参与</li><li>要认识到你没有必要凡事都做出判断。自己不知道的事情，就不要表态。</li></ol></li><li>要更关注决策机制是否公允，而非是否如你自己所愿</li></ol></li><li>知道如何超越分歧<ol><li>要牢记：相互达成协议时不能忽视原则<ol><li>每个人都要遵守相同的行为原则</li></ol></li><li>不要让大家把发牢骚、提建议、公开辩论的权利与决策权相混淆<ol><li>对决策本身以及决策者提不同意见时，要有大局意识</li></ol></li><li>不要对重大分歧不闻不问<ol><li>专心协商大事时，别被琐事烦扰</li><li>不要被分歧束缚住   ——要么提交上级裁定，要么投票表决</li></ol></li><li>一旦做出决定，任何人都必须服从，即便个人可能有不同意见<ol><li>着眼大局</li><li>不要让创意择优变成无法无天</li><li>不要容忍暴民手段</li></ol></li><li>如果创意择优与机构的利益相冲突，就难免会造成危害<ol><li>创意优先是为了能让机构运转的更好。</li><li>当心可能有人会提出为了“机构的利益”而临时放弃创意择优</li><li>要知道一旦有权做决定的人不想依原则行事，规矩就会被破坏</li></ol></li></ol></li><li>关于用人<ol><li>人和公司文化是相容共生的。</li><li>给他们配备能使他们在岗位上施展才华的工具和信息，而不是事无巨细地对他们进行微观管理。如果他们在受训后仍无法胜任，那就辞掉；如果能胜任，就提拔</li><li>比做什么事更重要的是找对做事的人<ol><li>记住目标是什么</li><li>把目标布置给能胜任它的人</li><li>让他们尽职尽责</li><li>如果在你培训他们并给其时间学习之后，他们还无法胜任工作，就辞掉他们</li></ol></li><li>你最重要的决策是选好工作的责任人<ol><li>最重要的责任人是在最高层负责订立目标、规划成果和组织实施的人</li><li>负最终责任的人应是对行为后果承担责任的人</li><li>确保每个人都有上级领导,即每个人都可以被问责。</li></ol></li><li>要记住事情背后是人的力量</li><li>要用对人，因为用人不当的代价高昂<ol><li>让合适的人做合适的事，是有事情，才需要找人，不要因人设职</li><li>要考虑你寻找的人应具备什么样的价值观、能力和技艺（按此顺序）</li><li>要用系统性思维和科学方法招聘人才</li><li>注意：人与职责要相匹配，把合适的人放到合适的位置。</li><li>要找出色的人，而不是“此类即可”</li><li>不要凭借你的影响力帮别人找工作</li></ol></li><li>要记住人与人存在差异，认识不同、思维不同使不同的人适合不同工作<ol><li>明白如何进行个性评估，并清楚结果含义。岗位上选择适合个性的人，能发挥更大的作用。</li><li>人容易选择与自己相似的人，因此安排面试官要确保其能发现你想招的人。想什么样的人，就安排什么样的面试官</li><li>选用那些能客观认识自己的人</li><li>要记住人一般不会随岁月有太大变化</li></ol></li><li>对待你的团队要像体育界管理者那样：没人能靠一己之力单独取胜，但每个人都必须战胜对手</li><li>关注人的过往经历<ol><li>核查情况，不能光听应聘者的一家之言。</li><li>学习成绩不能充分证明这个人是否具备你想要的价值观和能力</li><li>概念思维能力强固然最佳，但经验丰富、业绩出众也很重要</li><li>警惕不切实际的理想主义者</li><li>不要假定在别处获得成功的人也同样能胜任你所要求的工作</li><li>确保你选用的人要品格好、能力强</li></ol></li><li>找人不仅是干份具体工作，你还要愿意与其分享你的生活<ol><li>选那些会问很多好问题的人</li><li>让求职者知道这份工作的阴暗面</li><li>合作者必是意趣相投之人，但也须是诤友</li></ol></li><li>考虑薪酬时，要提供稳定性也要让人看到机会<ol><li>依人发薪，而非依工作岗位发薪</li><li>薪酬至少要大体上与业绩测评结果挂钩</li><li>薪酬要高于一般水平</li><li>要更多想着如何把蛋糕做大，而非怎样切蛋糕才能使自己获得最大的一块</li></ol></li><li>要记住维系伟大的合作关系，比金钱更重要的是体贴和宽厚</li><li>出色的人不容易找，所以要想着怎样留住人</li></ol></li><li>当你了解一个人时，就会知道可从他那里得到什么<ol><li>持续培训、测试、评估和调配员工<ol><li>要懂得你和你的下属将经历个人成长<ol><li>认清优缺点后，个人会飞速成长</li><li>培训引导个人发展</li><li>授人以渔，而不是授人以鱼，即便这意味着会使他们犯些错</li><li>经验会形成内化的学习，这是书本学习无法替代的</li></ol></li><li>不断提供反馈</li><li>准确评价人，不做“好好先生”<ol><li>到最后，准确和善意是一回事</li><li>正确运用褒贬</li><li>考虑准确度，而非后果。重视批评的准确度，而不是被批评后的后果</li><li>做出准确评价</li><li>要像从成功中学习一样从失败中学习</li><li>多数人做过的事和他们正在做的事，并不像他们认为的那么重要</li></ol></li><li>严厉的爱既是最难给的，也是最重要的爱（因为它很不受欢迎）<ol><li>虽然多数人爱听好话，但准确的批评更加难得</li></ol></li><li>对人的观察不要讳莫如深<ol><li>从具体细节中综合判断，依据事实和数据</li><li>从点数中发掘有用信息</li><li>对某个点数挖掘别太过度</li><li>采取业绩调查、绩效指标和正式考核等评价工具来记录一个人的所有表现</li></ol></li><li>让学习过程变得开放、有成长性和不断重复<ol><li>绩效指标要清晰公正</li><li>鼓励员工客观反思自己的业绩</li><li>要有全局观</li><li>对业绩考核要从具体案例开始，找出规律，与被考核人一起探究证据以求取共识</li><li>评估人时，你可能犯的两个最大错误是：对自己的评估过度自信，无法取得共识</li><li>达成评估共识不能以等级论</li><li>通过针对错误及其根源的坦诚对话来了解你的员工，也让员工了解你</li><li>确保员工做好工作，不必事无巨细进行监督</li><li>改变是很难的</li><li>通过发现人的缺点来帮人渡过难关</li></ol></li><li>了解人们怎样处事和判断这种处事方式能否取得好结果，这比了解他们做了什么更重要<ol><li>如果一个人工作干得不怎么样，要考虑这是由于学习不够，还是能力不足</li><li>培训和测试一个业绩不佳的员工时，常见的错误在于，只看其是否掌握所需技能，而不是评估他们的能力</li></ol></li><li>如果你跟某人真的就他们的缺点取得共识，这些缺点可能真的存在<ol><li>评判员工时，不必达到“没有一丝疑点”的境界</li><li>用不了一年时间，你就能了解一个人是什么样的人，他们是否适合其岗位</li><li>在员工任职期间持续评估</li><li>要像评估应聘者一样严格评估员工</li></ol></li><li>培训、保护或辞退员工，不要修复(价值观不和或能力不足 )<ol><li>不要让员工尸位素餐。辞退人或重新委派任务不是大事，把一个人留在不适合的岗位上才更糟糕</li><li>准备好“朝你爱的人开枪”(辞退)</li><li>某个人“不适合某个岗位”时，要考虑是否有更适合他的空缺，还是你需要让他们离开公司</li><li>要慎重对待把不称职的员工换到新岗位</li></ol></li><li>换岗是为了人尽其才，有利于整个团队</li><li>不要降低标准</li></ol></li></ol></li><li>严厉的爱最难给，也最重要<ol><li>改进机器的5个原则：<ol><li>树立目标</li><li>发现问题</li><li>诊断并发现问题根源</li><li>设计改进方案并解决问题</li><li>完成任务</li></ol></li><li>像操作一部机器那样进行管理以实现目标<ol><li>从高层面俯视你的机器和你自己</li><li>不断把结果和你的目标进行对照</li><li>出色的管理者就是一家机构的工程师</li><li>制定量化评价工具</li><li>要注意别把精力过多用于应付各种事务，而忽视你的机器</li><li>别被突发事件分散注意力</li></ol></li><li>应对每个问题的手段都要服务于两种目的.<ol><li>让你与目标更为接近</li><li>能够对机器（人和设计）进行培训和测试</li><li>经历的每件事都是一个案例，进行抽象总结归类。</li><li>如果出现问题，要在两个层面进行讨论<ol><li>机器层面（该结果怎样产生）</li><li>案例层面（如何应对）</li></ol></li><li>制定规则时，要解释清楚背后的原则</li><li>你的政策应当是你的原则的自然延伸，以原则为中心。</li><li>尽管好的原则、政策几乎都会提供良好的指南，但要记住每条规则都会有例外</li></ol></li><li>了解管理、微观管理和不管理的区别<ol><li>管理者必须确保自己负责的领域运转有效</li><li>管理你的下属就好比是在“一起滑雪”</li><li>优秀的滑雪者当滑雪教练要比新手当教练强</li><li>你应当把具体工作授权给员工做你应当把具体工作授权给员工做</li></ol></li><li>了解员工及其工作的动力，因为人是你最重要的资源<ol><li>经常了解那些对你和公司重要的人</li><li>对员工的信心应通过了解而来，而不是随意猜测</li><li>根据你的信心大小进行不同程度的调查了解</li></ol></li><li>明确职责<ol><li>记住谁负什么责任</li><li>防止“角色错位”</li></ol></li><li>深入探究你的机器以了解你能从它那里期待些什么<ol><li>获取足够程度的理解,对你所管理的领域和员工了解足够多</li><li>不要保持太远的距离</li><li>利用“每日报告”来了解团队成员的行为和思想</li><li>持续关注以了解问题会不会突然发生</li><li>问责过程要触及你直接下属的下一级</li><li>允许你下属的下属随时越级向你汇报</li><li>别想当然地认为员工的答案都是正确的</li><li>要学会明察秋毫</li><li>让问责过程透明，而非私下问责</li><li>欢迎被问责</li><li>对事物的看法和思维方式截然不同的人，相互间的沟通通常不畅</li><li>不放过一个可疑线索</li><li>解决问题有很多办法</li></ol></li><li>像公司的拥有者那样思考，要求你的同事也这样做<ol><li>休假也不应忘记责任</li><li>强迫自己和员工做困难的事，客服困难，使你和员工都会取得进步。</li></ol></li><li>承认并应对好关键人物风险，防止关键人物离职导致业务运转不顺。</li><li>不要对所有人等同视之，要合理对待、有所区别<ol><li>别轻易被迫让步</li><li>关心员工</li></ol></li><li>优秀的领导一般不是表面上看起来那么简单<ol><li>最有效的领导者的工作目的在于：<ol><li>开明地寻找最佳答案；</li><li>带领他人一道进行寻找</li></ol></li><li>既要弱，又要强</li><li>不要担心你的员工是不是喜欢你，不要让他们告诉你要如何做事, 追寻最好的决策，并有勇气做出决定。</li><li>不要发号施令让别人服从你，要努力为人所理解并理解他人，以达成共识</li></ol></li><li>确保你和你的员工承担相应的责任，也欢迎别人监督你负起责任<ol><li>如果你已经与别人就某事的做法达成一致，要确保其按此操作，除非你们就改变做法已形成共识</li><li>区分两种不同的失败情况，一种是没有遵守约定，第二种是根本没立约定</li><li>避免下沉现象。这是指管理者被迫去做下属的工作，而没有意识到这是一个问题</li><li>当心那些混淆目标和任务的人，因为如果他们分不清楚，你就不能信任他们并给他们委派职责。一种测试方法是：问一个高层次的问题：“目标XYZ的进展如何？”</li><li>当心缺乏重点、徒劳无益的“理论上应当”。并且明确责任人。</li><li>清楚地传达计划，用明确的量化指标对进展予以评估</li></ol></li><li>在无法充分完成职责时，将问题提交给上级解决…让你的下属也积极主动这样做</li></ol></li><li>发现问题，不容忍问题<ol><li>如果你不担心，你就要担心了；如果你担心，你就不必担心</li><li>对机器进行设计和监督，确保能发现哪些事情做得好、哪些不够好，否则就自己动手做<ol><li>指定员工负责发现问题，给他们时间进行审查，确保他们有独立的报告路线能够反映问题，而不必担心揭丑的后果</li><li>当心“温水煮青蛙综合征”</li><li>当心从众心理。即便没有人担心，也不表明没有问题存在</li><li>发现问题时，要把结果与目标相对照，如果结果没有达到目标，很有可能你会一直原地踏步。</li><li>“尝尝汤的味道”，产品给别人用时，首先自己用用。</li><li>尽量让更多双眼睛来寻找问题</li><li>最熟悉工作的人最有发言权</li></ol></li><li>在分析问题时要非常具体，不要泛泛而谈<ol><li>不要用“我们”“他们”这种不指名道姓的说法，以掩盖个人责任</li><li>不要害怕解决难题</li><li>必须理解，那些有良好解决方案的问题不同于没有解决方案的问题</li><li>以机器的方式来发现问题<ol><li>发现问题</li><li>确定谁是解决问题的责任人</li><li>决定什么时间适合进行讨论</li><li>贯彻执行</li></ol></li></ol></li></ol></li><li>诊断问题，探究根源<ol><li>无法准确诊断问题的原因:<ol><li>把遇到的问题当成一时的差错</li><li>不把问题和责任人挂钩</li><li>未能把此次问题和之前的教训联系起来</li></ol></li><li>为了做好诊断，要先问以下问题<ol><li>结果是好是坏？谁对结果负责？</li><li>如果结果不好，是因为责任人能力不够还是机器设计有问题</li><li>机器应该如何运转？(蓝图形式呈现，避免纠结细节)</li><li>机器是在以理想状态运转吗？是或否。如果答案为否，究竟是哪些地方运转不正常？出了什么故障？排查方式也很简单：<ol><li>某人完成任务了么？</li><li>未完成及时向上级反馈了么？</li></ol></li><li>为什么事情没有朝预想的方向发展</li><li>问题的根源是否带有规律性</li><li>在此情况下，员工或机器如何改进？<ol><li>是否有些职责需要分配或进一步澄清？</li><li>是否需要重新对机器进行设计？</li><li>是否要对某些员工的岗位匹配度进行重新评估</li></ol></li><li>进行问题诊断的一些注意事项：<ol><li>问自己：“还有人能以别的方式完成这个工作吗？”</li><li>找出流程中的哪一步出了问题</li><li>找出哪些原则被违反了</li><li>避免“事后诸葛亮”</li><li>不要把某人所处环境的优劣与其应对方法的优劣混为一谈</li><li>要认识到这样的事实，别人不知道怎么做，并不意味着你就能知道怎么做。在检测某个人是否善于解决问题时，要看：（1）他能够逻辑清晰地表达出如何处理相关问题；（2）他曾经在过去成功解决过类似问题。</li><li>问题的根源不是一次行动而是一个原因</li><li>为了分清楚哪些是人手不足的问题，哪些是能力不够的问题，要考虑如果在特定岗位上人手充足会把工作做得如何</li><li>要记住管理者通常出于以下5个原因之一（或更多）而失败或未能达成目标。<ol><li>他们离问题太远。</li><li>他们在辨别低素质、低质量方面能力欠缺。</li><li>他们已经感受不到问题的严重性，因为他们对问题已经习惯了。</li><li>他们对工作太自负（或自我意识过强），不愿意承认解决不了自己的问题。</li><li>他们对承认失败的不利后果感到害怕</li></ol></li></ol></li></ol></li><li>通过持续诊断来保持综合判断的与时俱进，并且诊断应当有成果</li><li>使用如下的“深挖”技巧，对出现问题的部门或下级部门形成一个基于80/20法则的印象<ol><li>列举问题，具体到事情和人</li><li>找出问题的根源，大多数问题都有可能是一下两种原因导致：<ol><li>不清楚谁是责任人</li><li>责任人没有很好地履行职责</li></ol></li><li>制订计划。具体任务，成功，责任人，跟踪考核指标，时间表</li><li>执行计划。定时检查报告。</li></ol></li><li>诊断是实现进步和建立良好人际关系的基础</li></ol></li><li>改进机器，解决问题<ol><li>设计你的机器并使之系统化<ol><li>建造你的机器</li><li>把原则和落实原则的方法系统化<ol><li>认真思考你做决策所依据的标准，据此建造优秀的决策机器</li></ol></li><li>好的计划应该像一部电影脚本<ol><li>让自己一段时间置身于“痛苦的位置”，更深入地理解你为了什么而设计。要亲身经历</li><li>设想其他可能的备选机器及其运行的结果，然后做出选择</li><li>不仅要考虑第一轮的后果，更要考虑第二、第三轮的后果</li><li>定期召开会议，保重要的交流互动和未来规划不被忽略，以及提高效率。</li><li>一部好的机器要考虑人可能并不完美这一因素</li></ol></li><li>设计是一个循环往复的过程，在不满意的“现在”与美好的“未来”之间有一个“不断努力”的阶段</li><li>在设计组织结构时，要围绕目标而不是围绕任务<ol><li>自上而下地建设组织</li><li>每个人都必须由一位具有可信度的、奉行高标准的人来监督</li><li>在设计组织时，运用五步流程是通往成功的捷径，不同员工能在不同步骤发挥良好作用</li><li>不要让一个机构去适应员工</li><li>要考虑机构的规模多大为宜</li><li>按照“万有引力”定律(拥有共同目标)，以最合乎逻辑的办法来划分业务部门及其下属部门</li><li>让各部门尽可能自给自足，以便控制所需的资源</li><li>为保证联络和沟通顺利，高级管理人员与基层管理人员的比例、基层管理人员与其直接下属的比例应当控制在一定范围，一般在1:10-1:5之间</li><li>在设计中要考虑继任计划和培训安排</li><li>不要仅盯着你自己的工作，还要关注如果你不在场，工作会如何开展</li><li>为确保正确完成关键任务，宁要“做两遍“(两个人独立完成同一个任务)而不要“二次确认”(第二个人什么都只是确认，不干活)</li><li>使用顾问要明智，防止过度依赖顾问。聘用顾问时需要考虑的因素：<ol><li>质量控制</li><li>经济上是否划算(招人还是外包)</li><li>知识的体制化</li><li>安全</li></ol></li></ol></li><li>描绘一幅金字塔形的组织架构图，任何两条由塔顶向下连接塔底的线不应产生交叉<ol><li>当遇到跨部门或跨附属部门的问题时，让金字塔交汇点上的人来处理</li><li>不要替别的部门的人完成工作，也不要从其他部门抽人来为你工作，除非你征得该部门管理者的同意</li><li>防止“部门错位”。部门目标和他干的事情偏离</li><li>必要时可建立“护栏”，但最好不要有“护栏”。“护栏”本质上就是帮助员工完成他的本职工作。</li><li>不要指望人们能意识到并消除自己的盲点</li><li>考虑“三叶草”式的设计。类似三个臭皮匠定个诸葛亮</li></ol></li><li>保持战略规划不变，在环境允许的情况下可以进行适当的战术微调<ol><li>不要让权宜之计超越战略目标</li><li>同时考虑大局和细节，理解二者之间的联系</li></ol></li><li>保持适当的监控，让谎言没有可乘之机<ol><li>进行调查并让员工知道你将开展调查</li><li>要知道如果没有警察（审计人员），法律就毫无意义</li><li>当心橡皮图章，意味着你需要对你的审计人员进行审计</li><li>按你的要求花钱的人在花钱上可能会大手大脚</li><li>通过“杀鸡儆猴”阻止不良行为</li></ol></li><li>报告路线和职责描述要尽可能清晰<ol><li>不要根据头衔，而要根据工作流程设计和人员的能力分配职责</li><li>要不断思考如何产生以小博大的杠杆效应，可以参考50:1的效果，即1小时讨论工作，下属要50小时完成。怎么样做的杠杆效果越高，就越成功。</li><li>雇用少数聪明人才并赋予他们最好的技术手段，要远胜于雇用大量普通人并配给一般的技术</li><li>使用助手来提高效率</li></ol></li><li>要知道几乎做每件事所花费的时间和资金都比你预期的要多</li></ol></li></ol></li><li>按既定计划行事<ol><li>朝着令你和你的机构振奋的目标去奋斗<ol><li>要考虑怎样把任务与那些目标挂钩</li><li>协调一致激励大家前行</li><li>别冲动，磨刀不误砍柴工</li><li>寻找有创意、聪颖的解决方案，有时有意想不到的效果</li></ol></li><li>要意识到每个人都忙得不可开交，除了更长时间工作，还可以：<ol><li>通过优先排序或直接拒绝来减少工作量</li><li>授权给合适的人去做</li><li>提高工作效率</li></ol></li><li>不要灰心丧气</li><li>使用检查清单</li><li>要留出时间休整</li><li>鸣钟庆祝；当你和你的团队达成目标，就开始庆祝吧！</li></ol></li><li>运用工具和行为准则指导工作。<ol><li>把系统化的原则嵌入工具对践行创意择优具有特别重要的价值<ol><li>为了促进真正的行为改变，必须内化学习或养成习惯</li><li>利用工具搜集数据，经过处理形成结论和行动</li><li>把原则阐述清楚，运用各种工具和行为准则来推进实施，形成信任、公平的氛围，使任何结论都可以通过跟踪其背后的逻辑和数据来加以评估</li></ol></li></ol></li><li>千万别忽视了公司治理<ol><li>为了取得成功，所有机构都必须建立制衡机制</li><li>即使在创意择优下，靠观点胜出也不是分派责任和权力的唯一决定因素</li><li>要确保公司里没有任何人比体系更强大，也没有任何人重要到不可替代</li><li>当心出现诸侯割据</li><li>设计一个机构的组织架构和规则时，要确保制衡机制能发挥作用</li><li>确保报告路线清晰</li><li>决策权归属要清晰</li><li>要确保从事履职评估的人<ol><li>有时间掌握被评估对象工作情况的全面信息</li><li>有能力实施评估</li><li>有利害冲突阻碍其有效行使监督权</li></ol></li><li>决策者能够接触做决策所需的信息，但必须守信用、妥善安全保管信息</li><li>在创意择优下，CEO单人决策没有集体决策好</li><li>原则、规矩、制衡等组成的治理体系不能取代出色的伙伴关系</li></ol></li><li>与他人合作可得三大益处<ol><li>共同努力比单打独斗能更强、更好地完成既定使命；</li><li>出色的人际关系会造就优秀的团队；</li><li>积累财富以实现和满足我们及他人生活所需</li></ol></li><li>让创意择优发挥作用，需要人们做三件事：<ol><li>坦陈自己最诚实的想法，让大家公开讨论；</li><li>理性地表达分歧，以便大家进行高质量的辩论，拓展思路，尽量形成最优的集体决策；</li><li>用创意择优来处理所有不同意见（例如可信度加权决策）</li></ol></li><li>对工作有益的建议<ol><li>你能将工作和激情有机结合在一起；</li><li>你能与同事为了共同的使命而奋斗，收获成果；</li><li>你能尽情享受奋斗和成果带来的欢乐；</li><li>你将迅速改善和进化，成就斐然</li></ol></li><li>由你自己决定希望从生活中得到什么和给予什么<ol><li>人们在带有情绪(高兴或沮丧)都会导致做出不是最佳的决定。</li></ol></li><li>当形成一定的原则过后，需要一定的工具来帮助自己完成目标。</li></ol><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><p>原则一书，可以说很清晰的阐述了作者在工作和生活中奉行的行为和思考方式。阅读完后，可以看到一套清晰的为人处世的原则框架，公司结构管理框架，对于我而言也是收获颇丰。但是最为关键的是，无论你在个人生活中，还是工作管理中，如果不在实践中思考这些原则，并加以实现，那么本书依旧相当于没有看。反之，如果你在寻找自己的原则，或在实践原则的过程中遇到了疑问，那么本书能够给予你很好的参考。–献给懒惰的我</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《贫穷的本质》读书笔记</title>
      <link href="/2021/09/21/%E3%80%8A%E8%B4%AB%E7%A9%B7%E7%9A%84%E6%9C%AC%E8%B4%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/21/%E3%80%8A%E8%B4%AB%E7%A9%B7%E7%9A%84%E6%9C%AC%E8%B4%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>看看我为啥这么穷(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>主题： 如题，探究贫穷的本质<br>类别：经济学-&gt;实用性+理论性论述书-&gt;贫穷经济学<br>概要：尝试阐述是什么因素导致的贫穷，穷人的生活究竟如何，怎样的援助才能使穷人脱贫。</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>作者想通过一些例子和实验数据，来表明是什么导致了贫穷，贫穷是否应该援助，怎样的援助或者引导能更加有效。</p><h2 id="主要观点"><a class="header-anchor" href="#主要观点"></a>主要观点</h2><h3 id="贫穷陷阱"><a class="header-anchor" href="#贫穷陷阱"></a>贫穷陷阱</h3><p>如果没有大量的原始投资助其解决这些地方性问题，这些国家很难提高自己的生产力。然而，这些国家却因为贫穷，无法支付投资回报——这就是经济学家们所谓的“贫穷陷阱”</p><ol><li>一个人需要一定的助力才能脱困，但本身贫穷无法产生助力。陷入贫穷循环的“贫穷陷阱”</li><li>人们总能比昨天有更好的收入，因此日子会越过越好，不存“贫穷陷阱”<br><img src="/2021/09/21/《贫穷的本质》读书笔记/%E6%9C%89%E8%B4%AB%E7%A9%B7%E9%99%B7%E9%98%B1%E6%9B%B2%E7%BA%BF.png" alt="拥有贫穷陷阱的收入曲线"><br><img src="/2021/09/21/《贫穷的本质》读书笔记/%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%B4%AB%E7%A9%B7%E9%99%B7%E9%98%B1%E6%9B%B2%E7%BA%BF.png" alt="没有贫穷陷阱的收入曲线"><br>有些地方有些领域存在贫穷陷阱，而有些缺不存在，需要进行合理分析。</li></ol><p>人在摄入不能满足消耗的时候，会陷入“贫穷陷阱”。因为没有吃饱，所以没有力气干活，因为没有力气干活，所以吃不饱。</p><h3 id="为何穷人会穷"><a class="header-anchor" href="#为何穷人会穷"></a>为何穷人会穷</h3><ol><li>穷人们饭都快吃不饱，为何还要买奢侈的食物。每年微量支出的加碘盐都不会买，而是去做其他消费？<ol><li>穷人更注重眼前的利益和享受。（没有向前看的思想）</li><li>穷人教育受限，接收消息受限，很难发现哪些对他们更有益。（没有向前看的机会）</li><li>教育受限，通信受限，限制穷人对有益事务的判断而导致贫穷，而贫穷又会导致教育和通信受限。贫穷陷阱</li></ol></li><li>很多时候，穷人不是不想富有，而是不知道怎么做，或者样儿不想那么费力。</li><li>固化的信念很难得到改变，受教育的程度使得他们很难理解一些有益的事务。</li><li>想改变穷人的观念，要不进行利益上的补足，要不进行思想上的劝导。</li><li>助推和默认选项可以增加某个选项的选择比例。</li><li>穷人和普通人遇到的困扰都相似：缺乏信念，信念不坚定，拖延。</li><li>教育投资<ol><li>父母对子女教育的投资量，有一部分是源于教育的回报量</li><li>教育也需要供给政策和需求政策，或者强制政策</li><li>对于人群种类的划分和固有印象，会导致教育期望偏差，教育资源倾斜。</li><li>要想建立一个能够向每个孩子提供机会的学校体系，首要的一步或许就是，认识到学校的服务对象是其现有的学生，而不是他们可能想要的学生。</li></ol></li><li>穷人每天面临的风险要比富人多许多。</li><li>穷人抵御风险的能力更弱</li><li>穷人的工作种类更加多元化</li><li>越穷的人贷款越难，由于增加信息采集和监督成本，违约后处理的收益率低。</li><li>穷人的自我控制能力越弱，因为满足自己的欲望需要的代价更大。比如吃一顿好的。</li><li>三大问题：意识形态、无知和惯性。</li><li>良政和良策相辅相成</li></ol><h3 id="总结"><a class="header-anchor" href="#总结"></a>总结</h3><p>导致穷人贫困的几个方面：</p><ol><li>穷人通常缺少信息来源，相信那些错误的事情。</li><li>穷人肩负着生活中的多种责任。</li><li>一些服务于穷人的市场正在消失，或是在这些市场中，穷人处于不利地位。</li><li>贫穷的国家因为贫穷或其不堪回首的历史而丧失改革信心和意识。</li><li>人们很难拥有改变自身的意识和决心。</li></ol><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><p>导致贫穷的原因有非常的多，这里主要讲了一些导致贫穷的普遍原因：比如环境因素，抗风险的能力，无知，惯性和意识形态等问题。<br>但这里针对的普遍是极度贫困的那么一群人，虽然中产阶级依旧存在无知，惯性和意识形态问题，但是相对来说，有了更强的抗风险能力，有一定的知识积累，和有机会越过贫困陷阱的s型曲线。但对于中产来说，更多是拥有一定的收入，能有较好的生活物质条件，能够有基本的医疗和意外保障。但是大部分却没有机会积累资产，或者只是积累少额固定资产，让资产产生更多的价值，或许这也是他们停留在中产的原因吧。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用nginx搭建linux的http代理</title>
      <link href="/2021/08/23/%E4%BD%BF%E7%94%A8nginx%E6%90%AD%E5%BB%BAlinux%E7%9A%84http%E4%BB%A3%E7%90%86/"/>
      <url>/2021/08/23/%E4%BD%BF%E7%94%A8nginx%E6%90%AD%E5%BB%BAlinux%E7%9A%84http%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>想在linux上使用http代理，方便拉代码和装软件依赖。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><a id="more"></a><h2 id="序"><a class="header-anchor" href="#序"></a>序</h2><p>首先你需要准备一个能够访问外网的服务器，作为流量跳板使用。如果没有，可以去买一个。<br>搭建代理就两步：</p><ol><li>在服务器上安装配置nginx</li><li>配置linux客户端上的proxy代理。</li></ol><h2 id="服务端"><a class="header-anchor" href="#服务端"></a>服务端</h2><p>别人写的挺好的，我就不抄了。如果你想实际从源码编译，可以参考下面的链接：<br><a href="https://lvjianzhao.gitee.io/lvjianzhao/2020/06/25/%E9%85%8D%E7%BD%AEnginx%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener">配置nginx正向代理</a><br><a href="https://blog.csdn.net/luChenH/article/details/107553493" target="_blank" rel="noopener">nginx 正向代理https配置</a></p><p>我这里提供一下我编译好的nginx包：<br>centos7.5:  <a href="/download/nginx_centos.tar.gz">nginx_centos</a><br>Ubuntu 7.3:  <a href="/download/nginx_ubuntu.tar.gz">nginx_ubuntu</a></p><p>对应的配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">user www-data;</span><br><span class="line">worker_processes auto;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line">#include /etc/nginx/modules-enabled/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">worker_connections 768;</span><br><span class="line"># multi_accept on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">sendfile on;</span><br><span class="line">tcp_nopush on;</span><br><span class="line">tcp_nodelay on;</span><br><span class="line">keepalive_timeout 65;</span><br><span class="line">types_hash_max_size 2048;</span><br><span class="line"># server_tokens off;</span><br><span class="line"></span><br><span class="line"># server_names_hash_bucket_size 64;</span><br><span class="line"># server_name_in_redirect off;</span><br><span class="line"></span><br><span class="line">include /etc/nginx/mime.types;</span><br><span class="line">default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">access_log /var/log/nginx/access.log;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line"></span><br><span class="line">gzip on;</span><br><span class="line"></span><br><span class="line">#set http and https proxy</span><br><span class="line">server &#123;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    resolver_timeout 5s;</span><br><span class="line">    listen 7080;</span><br><span class="line"></span><br><span class="line">    proxy_connect;</span><br><span class="line">    proxy_connect_allow            all;</span><br><span class="line">    proxy_connect_connect_timeout  10s;</span><br><span class="line">    proxy_connect_read_timeout     10s;</span><br><span class="line">    proxy_connect_send_timeout     10s;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass $scheme://$host$request_uri;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_buffers 256 4k;</span><br><span class="line">        proxy_max_temp_file_size 0;</span><br><span class="line">        proxy_connect_timeout 30;</span><br><span class="line">        proxy_cache_valid 200 302 10m;</span><br><span class="line">        proxy_cache_valid 301 1h;</span><br><span class="line">        proxy_cache_valid any 1m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端"><a class="header-anchor" href="#客户端"></a>客户端</h2><p>非常简单，设置环境变量就行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://xxx.xxx.xxx.xxx:7080</span><br><span class="line">export https_proxy=http://xxx.xxx.xxx.xxx:7080</span><br></pre></td></tr></table></figure><h3 id="观点2"><a class="header-anchor" href="#观点2"></a>观点2</h3><h3 id="观点3"><a class="header-anchor" href="#观点3"></a>观点3</h3><h2 id="其他"><a class="header-anchor" href="#其他"></a>其他</h2><p><strong>参考：</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《go语言程序设计》读书笔记</title>
      <link href="/2021/08/03/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/03/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>传说中的go语言圣经，得看一看(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>主题：GO语言学习<br>类别：计算机-&gt;实用性+理论性论述书-&gt;golang<br>概要：从语法，特性，接口，工具，测试等方面系统性介绍go语言。总体来说是针对语言本身特性来进行介绍的。</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>最近在设计一个项目的框架，所使用的就是golang语言，期望多看看书以及学习一些源码，从而有更优雅的架构设计。<br>书中有许多的练习程序，手动写代码，跑程序也是很重要的。</p><h2 id="主要内容"><a class="header-anchor" href="#主要内容"></a>主要内容</h2><p>太过于基础的语法，并不会在笔记中出现，这里主要记录一些go语言编写中需要注意的点。</p><h3 id="基础语法"><a class="header-anchor" href="#基础语法"></a>基础语法</h3><p>主要包含一些语法和关键语句特性相关内容。</p><ol><li><p>如果传参使用<code>map</code>或者<code>slice</code>实际传递的是引用的拷贝，也就是指针的拷贝，那么函数里对map的操作对调用者来说也是可见的。比如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertMap</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    m[<span class="number">1</span>] = <span class="string">"1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>switch</code>中的值会和每一个<code>case</code>进行比较，直到找到匹配的值。因此不要在<code>case</code>中放耗时的操作。<code>select</code>也是同样如此。</p></li><li><p>短变量声明一般用作局部变量中。示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in,err := os.Open(file)<span class="comment">//声明两个变量in,err</span></span><br><span class="line">out,err := os.Open(out)<span class="comment">//声明变量out，赋值变量err</span></span><br><span class="line">out,err := os.Open(out1)<span class="comment">//报语法错误</span></span><br></pre></td></tr></table></figure></li><li><p>多重赋值的时候，会先完全计算完右边的值，再赋值给左边。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x,y = x-y, x+y<span class="comment">//可以完全得到预想的值，即x=x[旧]-y[旧], y=x[旧]+y[旧]</span></span><br></pre></td></tr></table></figure></li><li><p>字符串<code>string</code>是不可变字节序列，不可越界，不可修改，运算只能产生新的变量，而非修改原有值。</p></li><li><p>无类型常量<code>const</code>往往拥有更高的精度和更广的取值范围，并且能够适用于很多地方。</p></li><li><p>数组的长度也是数组类型的一部分。</p><ol><li>数组初始化：</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q := [...]int&#123;1,2&#125;//同r类型，...会自己根据初始化数据个数填入</span><br><span class="line">r := [2]int&#123;1,2&#125;</span><br><span class="line">c := [...]int&#123;99:-1&#125;//len(c)=100, 除去c[99] = -1，其他都是0</span><br></pre></td></tr></table></figure></li><li><p>数组直接传递，是值传递，不同其他语言是引用传递。如果想使用引用传递，需要定义成指针类型：<code>func zero(a *[32]int)</code></p></li><li><p><code>slice</code>为空的判断，使用<code>len(s) == 0</code> 而不是<code>s == nil</code></p></li><li><p>go语言有可变长度的栈，最大可以达到1G，能更加安全的使用递归</p></li><li><p><code>defer</code>函数的实际执行顺序以调用顺序的倒叙执行。</p><ol><li>当发生<code>panic</code>时，所有<code>defer</code>也将以倒叙执行。</li></ol></li><li><p>内置函数<code>recover</code>只能在<code>defer</code>中调用，并且当发生<code>panic</code>时能终止当前的宕机，并且从发生<code>panic</code>的位置正常返回(不会往下执行)。</p><ol><li>通常情况下，不建议在<code>recover</code>中进行程序恢复，这样更容易掩盖程序中的bug</li><li>常用<code>recover</code>的方式是提供一些更加有用的信息。</li></ol></li></ol><h3 id="函数及变量作用域"><a class="header-anchor" href="#函数及变量作用域"></a>函数及变量作用域</h3><ol><li><p>作用域：</p><ol><li>整个程序级别：<code>int</code>, <code>new</code>等内置类型或函数</li><li>包级别：同一个包的任何地方引用，比如包里的全局变量</li><li>文件级别：只有导入了该包才能使用的。比如<code>fmt.Print</code></li><li>块儿级别：函数内部，循环内部等。</li></ol></li><li><p>函数作为参数的时候，传递的作用域问题，本质上函数参数传递的是指针，那么使用的时候也是直接使用指针指向的函数，只要指针本身有效(不是野指针)，函数都能正常执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := SendVar&#123;</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   func_scope.CallBack(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"inner call back func"</span>, s.inner, s.Out)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;)</span><br><span class="line">   func_scope.CallBack(<span class="built_in">print</span>) </span><br><span class="line">   func_scope.CallBack(s.<span class="built_in">print</span>) <span class="comment">//这里如果，s对象不存在了过后，容易导致函数指针读取错误。导致panic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s SendVar)</span> <span class="title">print</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"call back print func"</span>, s.inner, s.Out)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"call back print func"</span>, i)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同第三点所说，当结构体作为参数的时候，其他包是否有权限读取内部变量。类似json这种结构体中的内部变量就不会进行转换。实际上，直接读取肯定是无法读取的，写代码都编译不过。但可以通过反射获取，示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   vs := var_scope.VS&#123;Out: <span class="number">1</span>&#125;</span><br><span class="line"> fmt.Println(<span class="string">"Print var_scope VS"</span>, vs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var_scope包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VS <span class="keyword">struct</span> &#123;</span><br><span class="line">   Out   <span class="keyword">int</span></span><br><span class="line">   inner <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这种情况会输出：<code>Print var_scope VS {1 0}</code>，意思是<code>fmt.Println</code>可以读取到包内部变量。实际看源码我们发现，在<code>fmt.Println</code>中实际使用<code>reflect.Value.Int()</code>函数直接获取值(其他类型有对应转换函数)，是能获取到内部变量的，如果使用<code>reflect.Value.Interface()</code>来获取值，就会进行安全检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> safe &amp;&amp; v.flag&amp;flagRO != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Do not allow access to unexported values via Interface,</span></span><br><span class="line"><span class="comment">// because they might be pointers that should not be</span></span><br><span class="line"><span class="comment">// writable or methods or function that should not be callable.</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"reflect.Value.Interface: cannot return value obtained from unexported field or method"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们看下面的示例：<br>var_scope包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintOtherStruct</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   val := reflect.ValueOf(data)</span><br><span class="line">   typeOfTstObj := val.Type()</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">      fieldType := val.Field(i)</span><br><span class="line">      <span class="comment">//fieldType.Interface() 函数提示不能返回域外的值的panic，可以通过CanInterface函数来判断</span></span><br><span class="line">      <span class="comment">//fieldType.Int() 直接转换成对应类型的值，不会检测。</span></span><br><span class="line">      fmt.Printf(<span class="string">"object field %d key=%s value=%v type=%s \n"</span>,</span><br><span class="line">         i, typeOfTstObj.Field(i).Name, fieldType.Int(),</span><br><span class="line">         fieldType.Type())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">"var scope print"</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SendVar <span class="keyword">struct</span> &#123;</span><br><span class="line">   Out   <span class="keyword">int</span></span><br><span class="line">   inner <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := SendVar&#123;</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   var_scope.PrintOtherStruct(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>匿名函数，func关键字后没有变量的函数，例如：<code>strings.Map(func(r rune) rune{return r + 1}, &quot;HAL-9000&quot;)</code>。匿名函数有一些特性</p><ol><li>匿名函数能够获取到整个词法环境，里层能够使用外层的变量。</li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func squares() func() int &#123;</span><br><span class="line">   var x int</span><br><span class="line">   return func() int &#123;</span><br><span class="line">      x++</span><br><span class="line">      return x * x</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   f := squares()</span><br><span class="line">   fmt.Println(f()) //1</span><br><span class="line">   fmt.Println(f()) //4</span><br><span class="line">   fmt.Println(f()) //9</span><br><span class="line"></span><br><span class="line">   f2 := squares()</span><br><span class="line">   fmt.Println(f2()) //1</span><br><span class="line">   fmt.Println(f2()) //4</span><br><span class="line">   fmt.Println(f2()) //9</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的匿名函数是能够使用外层的变量x的。并且变量x在调用<code>squares</code>返回后亦然存在(虽然是隐藏在变量f中，有点像<code>var x int; func()int{...}</code>整个一体为<code>f</code>变量一样)。<br>2. 匿名函数作为递归，必须先申明再赋值，直接声明赋值会导致未定义错误：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">visitAll := func(items []string)&#123;</span><br><span class="line">   //...</span><br><span class="line">   visitAll(m[item]) //compile error: undefind visitAll</span><br><span class="line">   //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>匿名函数在for循环中的外部变量引用，先看示例：</li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var rmdirs []func()</span><br><span class="line">dirs := tmpdirs()</span><br><span class="line">for i:=0;i&lt;len(dirs);i++&#123;</span><br><span class="line">   //a := i //后面os.RemoveAll(dirs[i])替换为os.RemoveAll(dirs[a])才正确</span><br><span class="line">   os.MkdirAll(dirs[i],0755)</span><br><span class="line">   rmdirs = append(rmdirs, func()&#123;</span><br><span class="line">      os.RemoveAll(dirs[i])//不正确</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环里(指<code>for</code>开始到<code>{</code>中间)创建的变量，都是共享相同的变量，意味着匿名函数在使用的时候都是指向的一个地方。而如果内部声明的变量,如<code>a:=i</code>里的<code>a</code>则每次都会声明一个变量，隐藏在匿名函数中，而不会释放。</p></li><li><p>指针类型成员函数，使用非指针类型成员也能正常调用，golang会自动对指针和指针指向的值进行转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">   Num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span>&#123;</span><br><span class="line">   A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span><span class="title">set</span><span class="params">(num <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   a.Num = num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := A&#123;&#125;</span><br><span class="line">   a.set(<span class="number">222</span>)</span><br><span class="line">   fmt.Printf(<span class="string">"A:%v\n"</span>,a)</span><br><span class="line">   b := B&#123;&#125;</span><br><span class="line">   b.set(<span class="number">11</span>)</span><br><span class="line">   fmt.Printf(<span class="string">"B:%v\n"</span>,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:&#123;222&#125;</span><br><span class="line">B:&#123;&#123;11&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="接口和反射"><a class="header-anchor" href="#接口和反射"></a>接口和反射</h3><ol><li><p><code>nil</code>也可以作为类方法的接收者，比如<code>var a *NewStruct= (* NewStruct)(nil)</code>，但是通常不会这样使用。</p></li><li><p>接口就是提取一系列具体类型的共性而构成的。很多的常用系统函数都是提供接口值传递，支持自定义的类型传递(实现接口就行)。</p></li><li><p>接口值由两部分组成：类型和动态值。</p><ol><li>如果动态值可以比较(不是map或者slice这类)，那么接口值也是可以比较的。</li><li><code>var w *io.writer = os.Stdout</code>。接口值里的类型是<code>*os.File</code>，对应值是<code>&amp;os.File{fd=1}</code></li><li>注意含有空指针的非空接口：</li></ol>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a *os.File</span><br><span class="line">   check(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(w *io.writer)</span></span>&#123;</span><br><span class="line">   <span class="comment">//注意，这个地方传入的w，其接口值不为空。因为接口值存在非空类型值`*os.File`</span></span><br><span class="line">   <span class="keyword">if</span> w == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"w is nil"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>error</code>是一个接口，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span>&#123;</span><br><span class="line">   Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>断言：<code>f, ok := x.(T)</code></p></li><li><p>有些函数包可以通过断言<code>error</code>的类型来判断错误类型。</p></li><li><p>可以通过断言来判断某个接口里是否包含某个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeString</span><span class="params">(w *io.Writer, s <span class="keyword">string</span>)</span><span class="params">(<span class="keyword">int</span>, error)</span></span>&#123;</span><br><span class="line">   <span class="keyword">type</span> stringWriter <span class="keyword">interface</span>&#123;</span><br><span class="line">      WriteString(<span class="keyword">string</span>)(<span class="keyword">int</span>, error)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> sw, ok := w.(WriteString); ok&#123;</span><br><span class="line">      <span class="keyword">return</span> sw.WriteString(s)</span><br><span class="line">   &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反射<code>reflect</code></p><ol><li>反射由两部分构成：Type和Value。对应着interface的类型值和类型值(实际数据)</li></ol>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个反射的示例</span></span><br><span class="line"><span class="keyword">package</span> goreflectexample</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"reflect"</span></span><br><span class="line">   <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatAtom</span><span class="params">(v reflect.Value)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">   <span class="keyword">case</span> reflect.Invalid:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Invalid"</span></span><br><span class="line">   <span class="keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16,</span><br><span class="line">      reflect.Int32, reflect.Int64:</span><br><span class="line">      <span class="keyword">return</span> strconv.FormatInt(v.Int(), <span class="number">10</span>)</span><br><span class="line">   <span class="comment">//....简化起见，省略浮点数和复数</span></span><br><span class="line">   <span class="keyword">case</span> reflect.Bool:</span><br><span class="line">      <span class="keyword">return</span> strconv.FormatBool(v.Bool())</span><br><span class="line">   <span class="keyword">case</span> reflect.String:</span><br><span class="line">      <span class="keyword">return</span> v.String()</span><br><span class="line">   <span class="keyword">case</span> reflect.Chan, reflect.Func, reflect.Ptr,</span><br><span class="line">      reflect.Slice, reflect.Map:</span><br><span class="line">      <span class="keyword">return</span> v.Type().String() + <span class="string">" 0x"</span> +</span><br><span class="line">         strconv.FormatUint(<span class="keyword">uint64</span>(v.Pointer()), <span class="number">16</span>)</span><br><span class="line">   <span class="keyword">default</span>: <span class="comment">//reflect.Array, reflect.Struct, reflect.Interface</span></span><br><span class="line">      <span class="keyword">return</span> v.Type().String() + <span class="string">" value"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(path <span class="keyword">string</span>, v reflect.Value)</span></span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">   <span class="keyword">case</span> reflect.Invalid:</span><br><span class="line">      fmt.Printf(<span class="string">"%s = Invalid\n"</span>, path)</span><br><span class="line">   <span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.Len(); i++ &#123;</span><br><span class="line">         display(fmt.Sprintf(<span class="string">"%s[%d]\n"</span>, path, i), v.Index(i))</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">         feildPath := fmt.Sprintf(<span class="string">"%s.%s"</span>, path, v.Type().Field(i).Name)</span><br><span class="line">         display(feildPath, v.Field(i))</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">case</span> reflect.Map:</span><br><span class="line">      <span class="comment">// 另外一个遍历map的方式</span></span><br><span class="line">      <span class="comment">// iter := v.MapRange()</span></span><br><span class="line">      <span class="comment">// for iter.Next() &#123;</span></span><br><span class="line">      <span class="comment">// k := iter.Key()</span></span><br><span class="line">      <span class="comment">// va := iter.Value()</span></span><br><span class="line">      <span class="comment">// display(fmt.Sprintf("%s[%s]\n", path, formatAtom(k)), va)</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> _, key := <span class="keyword">range</span> v.MapKeys() &#123;</span><br><span class="line">         display(fmt.Sprintf(<span class="string">"%s[%s]\n"</span>, path, formatAtom(key)), v.MapIndex(key))</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">case</span> reflect.Ptr:</span><br><span class="line">      <span class="keyword">if</span> v.IsNil() &#123;</span><br><span class="line">         fmt.Printf(<span class="string">"%s = Nil\n"</span>, path)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">         fmt.Printf(<span class="string">"%s.type = %s\n"</span>, path, v.Elem().Type())</span><br><span class="line">         display(path+<span class="string">".value"</span>, v.Elem())</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">default</span>: <span class="comment">// 基本类型、通道、函数</span></span><br><span class="line">      fmt.Printf(<span class="string">"%s = %s\n"</span>, path, formatAtom(v))</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Display</span><span class="params">(name <span class="keyword">string</span>, x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"Display %s (%T)\n"</span>, name, x)</span><br><span class="line">   display(name, reflect.ValueOf(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，上述函数还有优化点，对于多处字符串<code>+</code>的操作，使用<code>bytes.Buffer</code>则更能提升性能。<br>2.  我们可以通过<code>(Value).Set</code>函数来对可寻址的变量进行赋值。是否可寻址(获取变量指针)可以用<code>(Value).CanAddr()</code>来确定。当然也可以通过取地址+断言的方式来获取指针，进行赋值:<code>px := x.Addr().Interface().(*int); *px=3</code><br>3.  反射可以获取到未导出字段的值，但是不能通过反射来更新这些值。<br>4.  可以通过反射获取<code>结构体字段标签</code>比如json中使用的<code>json:&quot;name&quot;</code>可以通过<code>reflect.StructField.Tag.Get(&quot;json&quot;)</code>来获取相应的值。<br>5.  可以通过反射获取相应方法：<code>(Value).Method(i)</code>，函数数量可以通过<code>(Value).NumMethod()</code>来获取。</p></li><li><p>使用反射的注意事项(总结：没有必要用反射，就不要用反射)：</p><ol><li>反射代码是很脆弱的，很容易出bug，并且bug是在遇到对应类型的时候以<code>panic</code>的方式抛出。</li><li>反射无法做静态类型检测，特别是<code>interface{}</code>或<code>reflect.Value</code>参数时，一定要说明参数访问和其他限制。并且大量使用反射也不便于理解。</li><li>使用反射是比特定类型优化的函数低一两个数量级。有些关键性的核心函数，还是要避免使用反射。</li></ol></li><li><p><code>unsafe</code>包中包含了许多接近底层的一些操作，当然这些操作在C语言里面可能是常见的。如果不是很有必要，并不建议使用unsafe包，unsafe包会导致更不易察觉的错误，以及削弱代码可移植性。</p><ol><li><code>unsafe.Pointer</code>指向一个<code>T</code>类型的指针，类似C里的<code>void *</code>。<code>unsafe.Pointer</code>可以转换为<code>uintptr</code>,然后对指针进行数值计算。但是注意如果使用<code>uintptr</code>作为中间变量，由于其类型为一个数据，那么其对应的值所指向的值可能被垃圾回收移动或者回收，导致不易发现的错误。如：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pT := <span class="keyword">uintptr</span>(unsafe.Poniter(<span class="built_in">new</span>(T))) <span class="comment">//语句执行后，创建的T就要被回收，pT值就变成野指针。</span></span><br></pre></td></tr></table></figure><p>如果要使用uintptr，需要谨慎使用，保证使用的最小范围。</p></li><li><p><code>reflect.DeepEqual</code>深度比较，会进行两个任意数据的类型，长度，和数据的比较。</p></li><li><p>在<strong>接口</strong>上调用方法时，必须有和方法定义时相同的接收者类型或者是可以根据具体类型 <code>P</code> 直接辨识的：</p><ul><li>指针方法可以通过指针调用</li><li>值方法可以通过值调用</li><li>接口接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li><li>接口接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li></ul></li></ol><h3 id="goroutine和通道"><a class="header-anchor" href="#goroutine和通道"></a>goroutine和通道</h3><ol><li><p>协程之间是没有父子关系的，所有子协程都是一个等级，挂在main函数下。</p><ol><li>父协程退出，子协程不会退出</li><li>函数退出，函数内的协程不会退出(main函数除外)</li></ol></li><li><p>管道类型<code>chan T</code>和<code>map</code>类似，传递都是进行指针传递。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x, ok := &lt;- ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">   fmt.Fatal(<span class="string">"channel closed."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>管道可以手动关闭(也可以让gc自己回收)，关闭后任何向管道里写入的操作都会崩溃，读取操作能够正常执行，读取完管道值后再读取的值就会零值。</li><li>单向通道：类型<code>chan&lt;- T</code>只能发送的的通道，类型<code>&lt;-chan T</code>只能接收的通道。类型<code>chan T</code>传值给单向通道的时候，都会进行隐式转换到相应的结构。</li><li>带有缓冲的通道，通道的数据存取类似于管道，先进先出。如果粗暴的在一个goroutine中将管道作为队列使用，可能会出现永久阻塞的风险。</li><li>在<code>select</code>中，如果通道是<code>nil</code>，则改分支永远不会被选中，该特性可以用来启用或禁用某些特性。</li><li>可以在goroutine中使用管道作为令牌桶，控制goroutine的并发量：</li></ol>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tokens := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++&#123;</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> tokens &lt;- <span class="keyword">struct</span>&#123;&#125;: <span class="comment">//获取令牌</span></span><br><span class="line">         <span class="keyword">case</span> &lt;-done: <span class="comment">//用于控制进程取消操作。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; &lt;- tokens &#125;() <span class="comment">//释放令牌</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">   &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不要通过共享内存来通信，应该使用通信来共享内存。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deposits = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//存钱</span></span><br><span class="line"><span class="keyword">var</span> balances = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//查余额</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(mony <span class="keyword">int</span>)</span></span> &#123; deposits &lt;- mony &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> &lt;-balances&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">teller</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> balance <span class="keyword">int</span> <span class="comment">//限制在一个goroutine内，不会读写冲突</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> mony := &lt;-deposits:</span><br><span class="line">            balance += mony</span><br><span class="line">         <span class="keyword">case</span> balances &lt;- balance:</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun init()&#123;</span><br><span class="line">   <span class="keyword">go</span> teller() <span class="comment">//启动teller</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>避免数据读写冲突的方法：</p><ol><li>初始化后，变量只读</li><li>避免多个<code>goroutine</code>访问同一变量。比如30的例子，用管道通信的方式，避免了多<code>goroutine</code>的同时读写。</li><li>使用互斥锁。</li></ol></li><li><p>读写锁只有在竞争激烈时效果才比一般锁好，单个执行是不如一般锁，这是由于读写锁实现更复杂。</p></li><li><p>一些导致并行数据冲突的原因：</p><ol><li>读写冲突导致</li><li>cpu缓存会导致并发的时候读到错误的缓存值，而锁操作可以把缓存刷入内存。多核cpu会分配并发线程到不同cpu，而每个cpu都有自己的缓存，会读到过期的数据</li><li>并行程序在相互之间没有变量逻辑关联的时候，编译器可能会交换执行顺序。</li></ol></li><li><p>延迟互斥初始化<code>sync.Once</code></p><ol><li>一种延迟初始化的示例：</li></ol>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> memo <span class="keyword">struct</span>&#123;</span><br><span class="line">   mem <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">   mu sync.Mutex</span><br><span class="line">   ready <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">//mem 准备好后关闭</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *memo)</span><span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   m.mu.Lock()</span><br><span class="line">   <span class="keyword">if</span> m.mem == <span class="literal">nil</span>&#123;</span><br><span class="line">      <span class="comment">//假设初始化的时候没有进行make</span></span><br><span class="line">      <span class="comment">//第一次get数据时，进行初始化。</span></span><br><span class="line">      m.mem = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">      m.mu.Unlock()</span><br><span class="line">      <span class="built_in">close</span>(m.ready)<span class="comment">//广播数据准备完毕，并且只需要广播一次。</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      m.mu.Unlock()</span><br><span class="line">      <span class="comment">//由于第一次广播数据时，关闭了消息，后续的访问，都不会阻塞。</span></span><br><span class="line">      &lt;-m.ready</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> m.mem[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以使用竞态检测器<code>race deleteor</code>来检测代码中是否有数据竞态的情况。使用方法在编译时增加<code>-race</code>参数</p></li><li><p>goroutine和线程的差别</p><ol><li>goroutine有可增长的栈，而OS里的线程一般只有固定大小的2MB。goroutine栈的增长也是以2倍增长，通常初始值在2KB，最大一般可以到1GB</li><li>线程调度需要涉及到CPU上下文切换，而goroutine调度通常是由go调度器处理，而调度技术成为<code>m:n调度</code>(把m个goroutine调度到n个线程)</li><li>goroutine没有标识，而OS线程通常都有线程标识。</li></ol></li><li><p><code>GOMAXPROCS</code>值表示：使用多少个OS线程来执行goroutine。正在休眠的goroutine不占用线程，阻塞IO、其他系统调用执行中或非go语言写的函数这些goroutine需要一个独立的OS线程。</p></li></ol><h3 id="测试"><a class="header-anchor" href="#测试"></a>测试</h3><ol><li><p>测试函数比如导入<code>testing</code>包，除去开头函数，可选后缀必须大写开头。</p></li><li><p>测试部分的代码，通常使用<code>_test.go</code>来进行区分，而包通常在一个里。</p></li><li><p>测试中<code>-run</code>命令后面跟的是正则表达式，运行匹配的函数。匹配字符里，可以忽略<code>Test</code>头</p></li><li><p>测试中的<code>t.Fatal</code>函数必须he<code>Test</code>在同一个<code>goroutine</code>中。错误消息的一般格式&quot;f(x)=y, want z&quot;</p></li><li><p>随机测试，构建符合模式的随机输入，来探测程序的边界。</p></li><li><p>测试程序和被测试程序，虽然都定义在一个包里，但是实际执行<code>go test</code>和执行主程序时，都是分开的。</p></li><li><p>测试程序中，不要调用<code>log.Fatal</code>或<code>os.Exit</code>，这些调用会阻止跟踪的过程。通常认为这两个是main函数的特权调用。</p></li><li><p>白盒测试可以通过修改一些全局量来达到测试部分功能的目的，比如代码中使用了全局函数指针<code>var sendMsg = fun(string) error{...}</code>，我们可以在白盒测试中修改改指针，来避免发送出错。</p></li><li><p>外部测试包，通常用于外部调用来测试相应包，无法访问包内部变量（会单独存在一个包，package命名使用<code>&lt;package&gt;_test</code>）。其他则和内部测试相同。</p></li><li><p>有时候，外部测试包需要拥有对内部包的特殊访问权限，我们可以约定声明一个特殊的测试文件<code>export_test.go</code>，而其存放的内容，仅仅是把包内部功能暴露。如<code>fmt</code>包中的<code>export_test.go</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"><span class="keyword">var</span> IsSpace = isSpace</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>如果我们要看我们自己编写的测试程序覆盖了多少源码，可以使用<code>go test -coverprofile=c.out ./</code>来查看。使用<code>go tool cover</code>可以查看<code>cover</code>的帮助。c.out会输出程序中哪些代码被覆盖，哪些没覆盖。</p></li><li><p>基准测试<code>Benchmark</code>，执行命令<code>go test -bench=&lt;name&gt;</code>，同样<code>&lt;name&gt;</code>使用正则匹配。如果不指定<code>-bench</code>，则不执行基准测试。<code>-benchmem</code>可以看到内存的操作消耗。详细测试可<a href="https://geektutu.com/post/hpg-benchmark.html" target="_blank" rel="noopener">参考</a></p></li><li><p>我们可以通过<code>go test</code>做代码的性能剖析，不同的报告类别告诉我们不同的性能情况：</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test -cpuprofile=cpu.out <span class="comment">//CPU占用</span></span><br><span class="line"><span class="keyword">go</span> test -blockprofile=block.out <span class="comment">//阻塞操作</span></span><br><span class="line"><span class="keyword">go</span> test -memprofile=mem.out <span class="comment">//内存占用</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">一个显示CPU性能的示例：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="keyword">go</span> test -run=NONE -bench=ClientServerParallelTLS64 -cpuprofile=cpu.log net/http</span><br><span class="line"><span class="keyword">go</span> tool pprof -text -nodecount=<span class="number">10</span> ./http.test cpu.log</span><br></pre></td></tr></table></figure><p>其中<code>http.test</code>是执行<code>go test</code>时产生的中间文件(如果<code>go test</code>不带性能分析参数，那么就会删掉该中间文件) <code>-nodecount=10</code>限制输出10行</p></li><li><p><code>Example</code>函数也会被<code>go test</code>视为特殊函数。该函数必须通过语法编译，并且会关联<code>Example</code>同名后缀的函数，并在文档中以示例的方式展示。也可以执行<code>Example</code>函数，并且<code>go test</code>会自动将执行结果，和你函数最后的带有<code>// 输出：</code>后的注释进行比较，判断输出正确性。</p></li></ol><h3 id="环境及工具"><a class="header-anchor" href="#环境及工具"></a>环境及工具</h3><ol><li>工作空间<code>GOPATH</code>依赖的源码，现在通常都是通过<code>go mod</code>来进行管理。环境变量<code>GOROOT</code>，指定go的版本。<code>go env</code>能配置这些变量。</li><li>进行<code>go build</code>时，后面的相对路径前必须加<code>./</code>或<code>../</code>之类的，否则就会识别为参数。</li><li><code>go build</code>和<code>go install</code>非常相似，区别在于<code>go install</code>不会丢弃编译代码和命令。它们对于没有修改过的包都不会进行重新编译。</li><li>可以通过<code>go doc</code>来查看函数结构体等声明和注释，使用方法:<code>go doc time</code>, <code>go doc time.Since</code>等。当然我们自己也在包开发的时候也鼓励编写函数和包注释。</li><li><code>godoc</code>和<code>go doc</code>功能一样，差别在于提供http的服务供网页查看。如<code>godoc -http :8000</code>。<code>-analysis=type</code>和<code>-analysis=pointer</code>提供更丰富的文档。</li><li>内部包是以<code>internal</code>为父目录的目录下的包，只能提供给<code>internal</code>的父目录使用，其他地方无法使用。</li><li><code>go list</code>可以进行可用包的查询，<code>...</code>为通配符。<code>-json</code>参数可以让包已json格式输出，<code>-f</code>可以通过<code>text/template</code>模板来定义输出格式。</li><li>go的标准文件和<code>_test.go</code>文件在<code>go test</code>时会分成两个包进行编译。你可以通过<code>go list -json &lt;package&gt;</code>来查看包里的构成，<code>GoFiles</code>包含的内容在<code>go build</code>时用到，而<code>TestGoFiles</code>则只会在<code>go test</code>的时候用到。``XTestGoFiles`通常指外部测试列表</li><li>包的空导入<code>import _ image/png</code>，其作用是利用包中的<code>init</code>函数进行相关组件的注册。同理，我们也可以通过<code>init</code>函数来进行函数注册和模块注册。</li></ol><h3 id="约定及习惯"><a class="header-anchor" href="#约定及习惯"></a>约定及习惯</h3><ol><li>包名原则上和父目录的文件夹名称一致。如果不一致也能干活儿，但是你引用的<code>import git.com/pkg/A</code>的包，使用A路径下文件里函数的时候却是<code>B.xxFunc</code>，不觉得这么干有病么。</li><li>如果类的方法使用的是指针接收者，那么所有的方法都建议使用指针接收者，如果方法使用结构体接收者，那么所有有方法建议都用结构体接收者。</li><li>接口命名通常是动词+er,比如<code>writer</code>, <code>controller</code>等</li><li>golang提倡平铺式结构，不提倡继承关系的结构。</li><li>程序结构，根据需求，以核心逻辑为主，细节由接口实现。</li><li>如果要提公共接口，公共接口往往专注一个能力，干一件事。不宜过长。</li><li>一个不错的接口设计经验：仅设计你所需要的接口</li><li>golang命名建议：<ol><li>变量、函数、结构体等建议驼峰命名</li><li>包名小写拼接，比如<code>strconv</code>，不建议<code>str_conv</code></li><li>文件名看个人习惯，通常是小写拼接或者小写<code>_</code>拼接。基本除了驼峰类型，其他的都行。</li></ol></li><li>好的测试程序：<ol><li>测试程序也需要健壮性，和秩序跟进维护</li><li>测试程序要尽可能多的报告出错误信息，要尝试一次运行中报多个错误。</li><li>覆盖率</li></ol></li><li>测试的约定函数名：<ol><li>Test开头，代表功能测试</li><li>Benchmark开头，代表性能测试</li><li>Example开头，代表示例函数</li></ol></li></ol><h3 id="Cgo"><a class="header-anchor" href="#Cgo"></a>Cgo</h3><ol><li><p><code>cgo</code>用于在go中调用c的函数，当然如果你的c库很小，可以考虑移植它，如果性能对我们来说不是很关键，那么也可以用<code>os/exec</code>来执行c的可执行程序。<code>cgo</code>只用于复杂且对性能有所要求的C库。<br>一个C写的程序：</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bzlib.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bz2compress(bz_stream *s, <span class="keyword">int</span> action, </span><br><span class="line">   char *in, unsigned *inlen, char *out, unsigned *outlen)&#123;</span><br><span class="line">   s-&gt;next_in = in;</span><br><span class="line">   s-&gt;avail_in = *inlen;</span><br><span class="line">   s-&gt;next_out = out;</span><br><span class="line">   s-&gt;avail_out = *outlen;</span><br><span class="line">   <span class="keyword">int</span> r = BZ2_bzCompress(s,action);</span><br><span class="line">   *inlen -= s-&gt;avail_in;</span><br><span class="line">   *outlen -= s-&gt;avail_out;</span><br><span class="line">   <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应cgo部分的代码。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#cgo CFLAGS: -I/usr/include</span></span><br><span class="line"><span class="comment">#cgo LDFLAGS: -L/usr/lib -lbz2</span></span><br><span class="line"><span class="comment">#include &lt;bzlib.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int bz2compress(bz_stream *s, int action,</span></span><br><span class="line"><span class="comment">   char *in, unsigned *inlen, char *out, unsigned *outlen);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//标识加入cgo，程序会分析注释中的相关内容</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"io"</span></span><br><span class="line">   <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> writer <span class="keyword">struct</span> &#123;</span><br><span class="line">   w      io.Writer</span><br><span class="line">   stream *C.bz_stream</span><br><span class="line">   outbuf [<span class="number">64</span> * <span class="number">1024</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewWriter 对于bzip2压缩的流返回一个wirter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(out io.Writer)</span> <span class="title">io</span>.<span class="title">WriteCloser</span></span> &#123;</span><br><span class="line">   <span class="keyword">const</span> (</span><br><span class="line">      blockSize  = <span class="number">9</span></span><br><span class="line">      verbosity  = <span class="number">0</span></span><br><span class="line">      workFactor = <span class="number">30</span></span><br><span class="line">   )</span><br><span class="line">   w := &amp;writer&#123;w: out, stream: C.bz2alloc()&#125;</span><br><span class="line">   C.BZ2_bzCompressInit(w.stream, blockSize, verbosity, workFactor)</span><br><span class="line">   <span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *writer)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> w.stream == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"closed"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">len</span>(data) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      inlen, outlen := C.<span class="keyword">uint</span>(<span class="built_in">len</span>(data)), C.<span class="keyword">uint</span>(<span class="built_in">cap</span>(w.outbuf))</span><br><span class="line">      C.bz2compress(w.stream, C.BZ_RUN,</span><br><span class="line">         (*C.char)(unsafe.Pointer)(&amp;data[<span class="number">0</span>]), &amp;inlen,</span><br><span class="line">         (*C.char)(unsafe.Pointer)(&amp;w.outbuf), &amp;outlen)</span><br><span class="line">      total += <span class="keyword">int</span>(inlen)</span><br><span class="line">      data = data[inlen:]</span><br><span class="line">      <span class="keyword">if</span> _, err := w.w.Write(w.outbuf[:outlen]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> total, err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> total, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><p>作为golang语言的半入门者，看完这本书，算是入门了。总的来说，书还是很不错的，看完过后，可以让你对golang有个整体的概念，更加熟悉语言本身的特性，以及学习到一些使用技巧。值得入门级别的go语言学习者仔细阅读，其中的一些疑惑可以自己编写代码执行来深入了解。<br>注：这个笔记本身没有什么阅读学习价值，读书笔记对于我来说是在我学习的时候更加帮助我记忆和理解，以及后续遇到某个问题时的快速查阅。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《代码整洁之道》读书笔记</title>
      <link href="/2021/07/17/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/17/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>提升代码能力(•̀⌄•́)  可惜是比较针对java，我又不懂java，只能借鉴一下思想了。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>主题：如何编写好的代码<br>类别：计算机-&gt;实用性-&gt;提升代码编写能力<br>概要：如何定义优秀的代码，如何编写优秀的代码，给出示例具体分析。</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>写过有几年的代码了，最近在代码架构设计，函数设计，类设计等方面总是不那么通透，期望寻找一些较好的理论和原则，写出更加优雅的代码。期望阅读完本书后，能有一些代码设计编写方面的体会和收获，给出一些理念和原则。</p><h2 id="怎样区分好和差代码"><a class="header-anchor" href="#怎样区分好和差代码"></a>怎样区分好和差代码</h2><h3 id="程序员的职业操守"><a class="header-anchor" href="#程序员的职业操守"></a>程序员的职业操守</h3><p>应当自己为自己的code负责，应尽力写出整洁优雅的代码，当有狗屎需求来，或者要求效率赶工的时候，应当提出自己的反对观点，指出其后续缺陷影响。要是领导还是让那么干，就屎上堆屎吧，堆不动了就溜了吧。😎</p><h3 id="怎么样判断是否是好代码"><a class="header-anchor" href="#怎么样判断是否是好代码"></a>怎么样判断是否是好代码</h3><p>让人改无所改，没有可优化的余地，尝试改了一圈，还是回到原点。</p><h3 id="一些好代码的特性"><a class="header-anchor" href="#一些好代码的特性"></a>一些好代码的特性</h3><ol><li>能通过所有测试</li><li>没有重复的代码</li><li>体现设计中的全部思想理念，而且尽量简单的体现。</li><li>包括尽量少的实体，比如方法，类，函数等。（主要体现系统架构和逻辑，就是系统只做某一类事情，而不是某一件事情）</li><li>写代码的过程中，读写的比例是10:1，因此让你的代码更易读，可以帮助你自己，也能帮助他人</li><li>时时保持代码的整洁。每次修改代码时，或许你只需要清除无用的代码，修改变量名，清除一点重复的代码……</li></ol><h3 id="良好的命名"><a class="header-anchor" href="#良好的命名"></a>良好的命名</h3><ol><li>良好的命名能够帮助你很多，一旦发现好的命名，就要替换旧的命名。好的命名，能一眼看出你想干什么，你代表什么。</li><li>避免误导性的命名，比如fp, socket等，或者语言特定称呼，比如xxxList,除非真的是list类型，不然最好用其他命名。</li><li>做有意义的区分，而不是一些含义相同，拼写不同的命名。比如productInfo和productData</li><li>不要自己造单词，或者不可读单词。比如什么gmssssasl这种乱七八糟的</li><li>避免使用一些编码和数字，而是用一些宏定义替代它。</li><li>类名和变量名，都应该是名词；函数都应该是动词。</li><li>同一个概念应该对应同一个词汇。</li></ol><h3 id="函数"><a class="header-anchor" href="#函数"></a>函数</h3><ol><li>函数应该做一件事情，做好这一件事情。并且只做这一件事情。</li><li>判断函数是否做一件事情的方法，是函数是否还能拆分，从而改变其抽象层级。</li><li>每个函数中应当只包含一个抽象层级。</li><li>使用表述性词汇，即能描述出函数的功能。而且越精简的函数越好命名。</li><li>尽量少的传递参数，如果超过了三个以上的参数，就需要考虑用类封装了。</li><li>标识参数异常丑陋，因为这表明函数不止做一件事情。</li><li>函数尽量不要暗含其他操作。如果有最好进行说明</li></ol><h3 id="注释"><a class="header-anchor" href="#注释"></a>注释</h3><ol><li>优美易读的代码不需要注释。</li><li>有用的注释：<ol><li>法律信息</li><li>提供一些信息，比如wiki链接</li><li>提供意图，为何这么干</li><li>进行一些补充说明</li><li>一些警告，比如前置条件一类</li><li>TODO</li></ol></li><li>避免一些误导性注释，以及一些废话。</li><li>避免循环性注释，也就是每个函数都加什么参数说明这种注释。</li><li>注释也要讲求精炼。</li></ol><h3 id="格式"><a class="header-anchor" href="#格式"></a>格式</h3><p>良好的格式更易于阅读。</p><ol><li>适当的缩进和换行</li><li>被调用的函数写在更下面，以方便顺序阅读。C这种有语言限制的除外。</li><li>水平对齐，更方便查看。</li><li>团队应当保持统一的编码风格。</li></ol><h3 id="对象和数据结构"><a class="header-anchor" href="#对象和数据结构"></a>对象和数据结构</h3><ol><li>面向过程的代码，便于在已有的数据结构下添加新的函数， 这是以数据结构为中心。 面向对象，便于在已有的函数下添加新的类，以函数为中心，也就是接口为中心。</li><li>什么时候使用面向对象，什么时候使用面向过程，都是值得考虑。而混用是否导致混乱和不必要，也需要进行考虑。比如go中封装的db库，即把它当成一个对象，来操作其方法，又直接获取其子成员包含方法。即没有把对象内部细节屏蔽，又使用了对象的封装，以求实现屏蔽细节。矛盾，需要细细思考。TODO</li><li>对象暴露行为，隐藏数据。数据结构暴露数据，没有什么行为。在合适的地方使用合适的结构。(个人理解，如果提供一种能力，那么则可以使用对象。如果是提供一种状态，则可以使用数据结构。对外提供能力，对内传输数据。向上提供接口，向下读写数据。)</li></ol><h3 id="边界"><a class="header-anchor" href="#边界"></a>边界</h3><ol><li>如何应对第三方接口的修改？<ol><li>在第三方接口上进行封装。但是其能力会降低？</li><li>编写相关测试代码，测试第三方程序。以及相应的更新文档。以确定新版本的改动。(风险只能降低，不能避免)</li></ol></li><li>对于还不存在的代码，我们可以先定义其行为和交互的数据。给一个统一的接口，代码来了直接装填就能用。</li><li>编写代码前，我们应当清晰的定义出软件的边界，以及哪些地方可扩展。对于可扩展的地方要小心谨慎对待，系统对接的地方也是如此，以便以后尽量少的改动我们的代码。</li></ol><h3 id="单元测试"><a class="header-anchor" href="#单元测试"></a>单元测试</h3><ol><li>测试应当随着代码的开发跟进开发</li><li>太久不维护测试代码，会导致测试代码失效，导致修改代码的故障率增加，以至于不想不敢去改原始代码。比如我写的AAD模块。</li><li>测试代码覆盖的越全面，你就能更加轻易的修改功能代码。</li><li>测试代码要求简单、精悍、足具表达力。</li><li>一类测试应当有一个断言。</li><li>测试应当是一类作为一个测试，而测试数据应当想办法独立，以保障最大的覆盖面。</li><li>整洁的测试还遵循以下5条规则：<ol><li>快速（Fast）测试应该够快。测试应该能快速运行。测试运行缓慢，你就不会想要频繁地运行它。如果你不频繁运行测试，就不能尽早发现问题，也无法轻易修正，从而也不能轻而易举地清理代码。最终，代码就会腐坏。</li><li>独立（Independent）测试应该相互独立。某个测试不应为下一个测试设定条件。你应该可以单独运行每个测试，及以任何顺序运行测试。当测试互相依赖时，头一个没通过就会导致一连串的测试失败，使问题诊断变得困难，隐藏了下级错误。</li><li>可重复（Repeatable）测试应当可在任何环境中重复通过。你应该能够在生产环境、质检环境中运行测试，也能够在无网络的列车上用笔记本电脑运行测试。如果测试不能在任意环境中重复，你就总会有个解释其失败的接口。当环境条件不具备时，你也会无法运行测试。</li><li>自足验证（Self-Validating）测试应该有布尔值输出。无论是通过或失败，你不应该查看日志文件来确认测试是否通过。你不应该手工对比两个不同文本文件来确认测试是否通过。如果测试不能自足验证，对失败的判断就会变得依赖主观，而运行测试也需要更长的手工操作时间。</li><li>及时（Timely）测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，代码难以测试。你可能会认为某些生产代码本身难以测试。你可能不会去设计可测试的代码。</li></ol></li></ol><h3 id="类"><a class="header-anchor" href="#类"></a>类</h3><ol><li>类应当尽量短小，一个类不要承载过多的公共函数和变量。</li><li>一个类应当遵循单一原则，只有一个修改原因。</li><li>应当对类加以组织，减少修改带来的影响。</li></ol><h3 id="系统"><a class="header-anchor" href="#系统"></a>系统</h3><ol><li>系统的构建和运行应当分离，意思是系统架构和实际运行的功能应当分离。</li><li>主系统在执行的时候，默认实际运行的功能已经是ok的，主程序不依赖任何实际运行的功能。</li><li>依赖注入，一种强大的机制可以实现分离构造与使用。在依赖管理情景中，对象不应负责实体化对自身的依赖。反之，它应当将这份权责移交给其他“有权力”的机制，从而实现控制的反转。</li><li>扩容是系统必须考虑的事情之一。但是无法一次性规划好系统，只需要持续将关注面进行切分。个人觉得，netfilter的架构是扩展性很好的架构。</li><li>模块化和关注面切分成就了分散化管理和决策。</li></ol><h3 id="迭代"><a class="header-anchor" href="#迭代"></a>迭代</h3><p>Kent Beck关于简单设计的四条规则：</p><ol><li>运行所有测试<ol><li>不可测试的系统，不可验证，不可验证的系统不能上线</li><li>良好的测试能促使进一步完善代码。</li></ol></li><li>不要有重复</li><li>表达程序员意图</li><li>尽可能的减少方法和类<br>良好的遵循以上四条规则，能够更好的帮助你重构某个不合理的模块，迭代增加新的功能。</li></ol><h3 id="并发编程"><a class="header-anchor" href="#并发编程"></a>并发编程</h3><p>并发是一种时机上的解耦</p><ol><li>并发并不总能提高性能。</li><li>并发可能伴随很大程度上的系统改造。</li><li>并发可能需要对系统有更加深入的理解。</li><li>并发开发建议：<ol><li>分离并发代码和其他代码</li><li>严谨控制数据的作用域</li><li>尽量使用副本。比如内存池和线程池。</li><li>线程应当尽可能独立。</li><li>详细了解基本的并发之间的基础模型：读写模型，生产者消费者模型，哲学家圆桌模型。</li><li>明确读写锁，死锁，互斥，线程饥饿等概念。</li><li>警惕同步方法之间的依赖，保持同步区域的微小。</li><li>考虑子线程死锁后如何退出线程。TODO</li><li>偶发性错误可能是多线程之间隐藏的难易发现的错误，也要重视。尝试稳定复现。</li><li>编写可插拔的线程代码：可控线程数量，可控线程运行速度，可配置程序运行环境。</li></ol></li></ol><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><p>总的来说，在有一定开发经验的基础上来阅读本书，是很有帮助的，其中最让我受益的是重新理解了测试的重要性，以及一些使代码整洁的基本原则。<br>可惜了是java为主的代码示例，让我有些看不懂，或者感触不深，毕竟毫无java开发经验。</p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx源码阅读</title>
      <link href="/2021/07/11/nginx%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2021/07/11/nginx%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>nginx源码阅读分析(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>本人主要使用的nginx源码是<a href="http://nginx.org/download/nginx-1.0.15.tar.gz" target="_blank" rel="noopener">nginx-1.0.15</a>，以降低阅读难度，毕竟需要了解的是大体框架和原理。最新的版本，代码量太大，会增加阅读理解难度，没有必要。而本文的阅读方法，也按照<strong>基本使用-&gt;简单示例-&gt;示例在源码中如何工作-&gt;相关联版块实现逻辑-&gt;结构化整理nginx逻辑框架</strong>的方法来写文档。其核心思路围绕:<strong>什么功能-&gt;功能如何实现</strong>来进行分析，反复循环改过程以理解整个nginx源码。最后会提出一个实际问题，通过阅读源码后来提出相应的解决方案。<br>有必要可以增加一个如何编写nginx的module的文章，单开篇，就不在这里写了。</p><a id="more"></a><h2 id="序"><a class="header-anchor" href="#序"></a>序</h2><p>首先你必须要有一定的C功底，linux功底，以及初步了解过nginx最好也初步使用过，本文对于这几项会几乎略过，当然会给出一个基本使用示例。<br>由于本人也是才工作不久的新人，初次阅读源码，菜是自然的，有问题的地方，欢迎讨论。<br>其他：本文的客户端(浏览器)在windows上，使用Chrome；服务器在linux(centos 7.6)上，其他平台的编译执行请自行处理。</p><h2 id="nginx应用示例"><a class="header-anchor" href="#nginx应用示例"></a>nginx应用示例</h2><p>我们第一步很简单，先把它用起来。这里我们给出两个nginx的经典应用场景，1. 作为web服务器，即在服务器放一个html文件，然后浏览器通过nginx访问该html的网页。2. 作为反向代理，即在服务器A上安装一个nginx做反向代理到服务器B，客户端通过服务器A访问服务器B资源。我们先配置场景1<br>在此之前，先干下面的事情：</p><ol><li>下载nginx源码</li><li>编译</li><li>修改配置文件</li><li>执行nginx，并测试场景1成功</li></ol><h3 id="源码下载编译"><a class="header-anchor" href="#源码下载编译"></a>源码下载编译</h3><p>更加详细的编译和配置可以参考：<a href="https://zhuanlan.zhihu.com/p/92995126" target="_blank" rel="noopener">最全Nginx 配置文件详解及安装</a><br>下载：<a href="http://nginx.org/download/nginx-1.0.15.tar.gz" target="_blank" rel="noopener">nginx-1.0.15</a><br>编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.0.15.tar.gz</span><br><span class="line">tar -xzvf nginx-1.0.15.tar.gz</span><br><span class="line">cd nginx-1.0.15/</span><br><span class="line">./configure --with-debug --prefix=/&lt;your_path&gt;/nginx_learning/</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>不出意外就成功了，如果有错误，自行解决。相应的可执行程序在<code>objs/nginx</code></p><h3 id="配置场景"><a class="header-anchor" href="#配置场景"></a>配置场景</h3><h4 id="环境准备"><a class="header-anchor" href="#环境准备"></a>环境准备</h4><p>我们安装的时候，把可执行文件<code>install</code>到了一个新目录：<code>nginx_learning</code><br>不出意外，结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># tree</span><br><span class="line">.</span><br><span class="line">|-- conf</span><br><span class="line">|   |-- fastcgi.conf</span><br><span class="line">|   |-- fastcgi.conf.default</span><br><span class="line">|   |-- fastcgi_params</span><br><span class="line">|   |-- fastcgi_params.default</span><br><span class="line">|   |-- koi-utf</span><br><span class="line">|   |-- koi-win</span><br><span class="line">|   |-- mime.types</span><br><span class="line">|   |-- mime.types.default</span><br><span class="line">|   |-- nginx.conf</span><br><span class="line">|   |-- nginx.conf.default</span><br><span class="line">|   |-- scgi_params</span><br><span class="line">|   |-- scgi_params.default</span><br><span class="line">|   |-- uwsgi_params</span><br><span class="line">|   |-- uwsgi_params.default</span><br><span class="line">|   `-- win-utf</span><br><span class="line">|-- html</span><br><span class="line">|   |-- 50x.html</span><br><span class="line">|   `-- index.html</span><br><span class="line">|-- logs</span><br><span class="line">`-- sbin</span><br><span class="line">    `-- nginx</span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a class="header-anchor" href="#修改配置文件"></a>修改配置文件</h4><p>上述完成后，我们进行场景1和2的配置文件修改，得到<code>nginx.conf</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8080;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">root /data/www;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        location /proxy &#123;</span><br><span class="line">            proxy_pass   http://127.0.0.1:8000/;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件的<code>root</code>配置根据个人情况修改。<br><em>注意：<code>www</code>目录位置，注意权限问题，详情可查看日志<code>logs/error.log</code>。权限问题处理方式可参考：<a href="https://stackoverflow.com/questions/6795350/nginx-403-forbidden-for-all-files" target="_blank" rel="noopener">Nginx 403 forbidden for all files</a>，翻不了墙的同学，自行百度</em></p><h4 id="构建资源"><a class="header-anchor" href="#构建资源"></a>构建资源</h4><p>然后我们在<code>www</code>目录下新建一个<code>index.html</code>文件，作为场景1的服务端资源：<br>index.html:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt; Hello nginx &lt;/h1&gt;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">对于场景2，我们需要构建反向代理的后端服务，可以自己启动一个http的文件服务器。比如：</span><br></pre></td></tr></table></figure><p>nohub python3 -m http.server --bind 127.0.0.1 8000 &amp;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以本地curl一下以验证启动效果：</span><br></pre></td></tr></table></figure><p>curl <a href="http://127.0.0.1:8000" target="_blank" rel="noopener">http://127.0.0.1:8000</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后我们启动nginx：</span><br></pre></td></tr></table></figure><p>nginx_learning/nginx -p /&lt;your_path&gt;/nginx_learning/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#### 测试效果</span><br><span class="line">我们可以看下场景1的展示效果：</span><br><span class="line">![场景1](./nginx源码阅读/场景1效果.png)</span><br><span class="line">我这里使用的是我自己的一个桩。访问效果如下：</span><br><span class="line">![场景2](./nginx源码阅读/场景2效果.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 场景1源码分析</span><br><span class="line">我们上面已经实现了场景1和场景2的展示，那么现在开始分析场景1的流程。</span><br><span class="line">### 源码分析</span><br><span class="line">按照惯例，我们可以从main函数开始，先分析程序启动，再一步一步的分析场景1是如何实现的。分析过程中，遇到变量结构太复杂可以先记录下来，跳过，等实际应用的时候再回头分析。记住，这时候我们的主要目的是梳理出整个执行逻辑，而不是细节，不必在对流程不重要的细节上花费太多时间，以阻碍主流程梳理进度。</span><br><span class="line">#### main函数</span><br><span class="line">**mian函数局部变量定义：**</span><br><span class="line">找到main函数，一开始就是四个数据结构：</span><br></pre></td></tr></table></figure><pre><code>ngx_int_t         i;ngx_log_t        *log; //猜测用于日志记录ngx_cycle_t      *cycle, init_cycle; //猜测是个贯穿整个流程重要的数据结构，里面包含的东西很多，暂时不管ngx_core_conf_t  *ccf;//猜测配置相关内容，细节再说</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">可以大致看一看，猜测一下它们作用。大致看一下各个数据结构类型。我这里好奇它的[命名习惯](#nginx中的命名习惯)，因此初步进行梳理。`ngx_cycle_t`和`ngx_core_conf_t`结构有些多，后面梳理(你也可以提前看看[nginx中数据结构](#nginx中数据结构))。</span><br><span class="line">**初始化和参数分析：**</span><br><span class="line">1. `ngx_strerror_init`初始化了一个自己的errnum 列表。关于error number，有这样一个解释：[参考](https://blog.csdn.net/baishuwei/article/details/2535484)</span><br><span class="line">   &gt;在没有解释这些错误定义之前，先让我们看看为什么要知道这些常用error number？ 对于写C程序的人来说，errno并不是一个陌生的变量，无论你是在用户态还是在内核态。简短来说，errno是用来保存错误信息，这些信息反应了相应错误原因。因此，一个小小errno就可以连接user space programmer 与 kernel space programmers，可见其重要性。但是，我们的programmers确又常常忽略这些，他们往往只看中正确与错误，而不是去访问强大的errno获取更多的信息。对于普通的程序，为此可能仅仅是&quot;没关系，大不了可以重启&quot;。但是，对于一些重要的任务，重启可能意味着灾难的发生，尤其是在重要的领域。为此，这里我想给大家列出常见的errno，提醒大家在处理设备时，&quot;check errno when your routine failed!&quot;.</span><br><span class="line"></span><br><span class="line">   和[手册](https://man7.org/linux/man-pages/man3/errno.3.html)中的描述差距不大：</span><br><span class="line">   &gt;The &lt;errno.h&gt; header file defines the integer variable errno,</span><br><span class="line">       which is set by system calls and some library functions in the</span><br><span class="line">       event of an error to indicate what went wrong.</span><br><span class="line">2. `ngx_get_options`参数分析，nginx主要依赖配置文件，因此命令行参数很简单。</span><br><span class="line">3. `ngx_time_init`初始化nginx中时间记录格式。</span><br><span class="line">4. `ngx_regex_init`(可先跳过)</span><br><span class="line">5. `ngx_log_init`(可先跳过)</span><br><span class="line">6. `ngx_ssl_init`(可先跳过)</span><br><span class="line">7. `ngx_create_pool`知道是初始化内存池的就行。</span><br><span class="line">8. `ngx_save_argv`(可先跳过)</span><br><span class="line">9. `ngx_process_options`(可先跳过) </span><br><span class="line">10. `ngx_os_init`获取一些系统相关信息</span><br><span class="line">11. `ngx_crc32_table_init`(可先跳过)</span><br><span class="line">12. `ngx_add_inherited_sockets`(可先跳过)看起来像获取NGINX系统变量，然后干些事情，和主流程似乎不影响。毕竟有`inherited == NULL`这种判断</span><br><span class="line">13.  </span><br><span class="line">14. `ngx_init_cycle`这个玩意儿，里面包含了很多东西，粗看一眼，牵涉到系统socket监听，配置文件分析，和主流程是紧密相关，不能跳过了。看 一下其流程</span><br><span class="line">    1. 分配一些内存池，更新一些时间戳，以及一些链表。</span><br><span class="line">    2. `ngx_conf_param` 读取配置文件外的全局内容，实际工作方式调用`ngx_conf_parse`</span><br><span class="line">    3. `ngx_conf_parse(&amp;conf, &amp;cycle-&gt;conf_file)` 读取配置文件内容</span><br><span class="line">        1. `if (filename)` 判断是打开配置文件以及获取基本信息。</span><br><span class="line">        2. `for ( ;; )`中的`ngx_conf_read_token`进行每一个token的分析。这里1个`;`所包含的为一个token</span><br><span class="line">            1. 当找到完整的有用的单词，就会标记`found = 1`,然后进行下面的赋值处理：</span><br><span class="line">            ```c</span><br><span class="line">                if (found) &#123;</span><br><span class="line">                //每当找到一个可用配置，比如‘worker_processes  1;’</span><br><span class="line">                //就会先后将‘worker_processes’和‘1’放到cf-&gt;args中，</span><br><span class="line">                //至于这个ngx_array_t结构如何,待后续分析。TODO</span><br><span class="line">                word = ngx_array_push(cf-&gt;args);</span><br><span class="line">                if (word == NULL) &#123;</span><br><span class="line">                    return NGX_ERROR;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //分配相应内存给数据</span><br><span class="line">                word-&gt;data = ngx_pnalloc(cf-&gt;pool, b-&gt;pos - start + 1);</span><br><span class="line">                if (word-&gt;data == NULL) &#123;</span><br><span class="line">                    return NGX_ERROR;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //拷贝找到的值</span><br><span class="line">                for (dst = word-&gt;data, src = start, len = 0;</span><br><span class="line">                     src &lt; b-&gt;pos - 1;</span><br><span class="line">                     len++)&#123;</span><br><span class="line">                         ....</span><br><span class="line">                     &#125;</span><br><span class="line">                if (ch == &apos;;&apos;) &#123;</span><br><span class="line">                    return NGX_OK;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><pre><code>        2. `ngx_conf_handler`用于将命令行参数载入扩展module。TODO细节4. `for (i = 0; ngx_modules[i]; i++)` 赋值相应的配置变量给扩展的module5. `ngx_create_pathes`创建文件夹路径6. `part = &amp;cycle-&gt;open_files.part; file = part-&gt;elts; for (i = 0; /* void */ ; i++) {` 打开要用到的文件。7. `part = &amp;cycle-&gt;shared_memory.part; shm_zone = part-&gt;elts;`创建共享内存8. `if (old_cycle-&gt;listening.nelts)`赋值相关监听所需值9. `ngx_open_listening_sockets`启动监听10. 释放一些不用的内存，打开的文件，以及socket11. `failed`出错处理，配置回滚。</code></pre><ol start="15"><li><p><code>ngx_signal_process</code>(可先跳过)</p></li><li><p><code>ngx_init_signals</code>注册信号量的回调函数，信号量和回调函数的关联关系在<code>signals</code>全局量中。控制相关标记位来间接控制master进程中的动作</p></li><li><p><code>ngx_os_status</code>打印系统状态</p></li><li><p>获取配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ccf = (ngx_core_conf_t *) ngx_get_conf(cycle-&gt;conf_ctx, ngx_core_module);</span><br></pre></td></tr></table></figure></li><li><p>标识是否是master进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (ccf-&gt;master &amp;&amp; ngx_process == NGX_PROCESS_SINGLE) &#123;</span><br><span class="line">    ngx_process = NGX_PROCESS_MASTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ngx_daemon</code>fork进程，具体操作后续继续阅读</p></li><li><p><code>ngx_create_pidfile</code>创建pidfile</p></li><li><p>创建worker进程或者master进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (ngx_process == NGX_PROCESS_SINGLE) &#123;</span><br><span class="line">    ngx_single_process_cycle(cycle);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ngx_master_process_cycle(cycle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>结构流程：</strong><br>从上面的函数大概分析，我们基本能够梳理出整个main函数的逻辑：</p><pre class="mermaid">flowchart TDA(初始化errnum)B(解析命令行传入参数)C1(时间格式,SSL,内存池初始化)C2(获取系统的一些信息)C3(其他一些不影响的初始化)D1(读取解析额外配置)D2(读取解析配置文件)D3(赋值配置到module)D4(创建文件夹,打开需要使用的文件)D5(创建共享内存)D6(启动监听)D7(释放多余内存,文件,状态)D8(错误处理和配置回滚)E{标识是否为master}F1(创建子进程)F2(创建主进程)    subgraph C [其他初始化]        C1 --> C2         C2 --> C3    end    subgraph D [初始化cycle]        D1 --> D2        D2 --> D3        D3 --> D4        D4 --OK--> D5        D5 --OK--> D6        D6 --OK--> D7        D7 --> D8        D6 --failed-->D8        D5 --failed-->D8        D4 --failed-->D8    end    A --> B    B --> C    C --> D    D -->E    E --否--> F1    E --是--> F2</pre><p>从上述流程图，基本可以了解到主函数所做的工作。接下来就开始梳理master进程和worker进程分别做了什么工作。</p><h4 id="master进程"><a class="header-anchor" href="#master进程"></a>master进程</h4><ol><li>注册许多的信号量，并设置成阻塞，延后处理。<a href="https://blog.csdn.net/ShaoLiang_Ge/article/details/57984123" target="_blank" rel="noopener">sigprocmask</a>函数讲解</li><li>设置进程标记</li><li><code>ngx_start_worker_processes</code>控制子进程启动(这里的fork干嘛用的？)<ol><li><code>for ngx_get_cpu_affinity</code>循环子进程个数</li><li><code>ngx_spawn_process</code>创建和子进程通信的套接字。<ol><li><code>ngx_worker_process_cycle</code>回调函数，具体作用是解析收到的消息，放到状态机里处理。消息从何而来？未知，主要是fork函数作用？</li></ol></li><li><code>ngx_pass_open_channel</code>往套接字里发送消息，消息转发给子进程。</li></ol></li><li><code>ngx_start_cache_manager_processes</code>, 其抽象作用和<code>ngx_start_worker_processes</code>差不多，都是发送消息给子进程，只是功能作用上是进行cache的管理启动。主要调用的也是下面两个函数：<ol><li><code>ngx_spawn_process</code> 内容是：‘cache manager process’</li><li><code>ngx_pass_open_channel</code></li></ol></li><li>主进程的主要<code>for ( ;; )</code><ol><li>是否进行delay<ol><li>使用<code>setitimer</code>控制进程延时</li></ol></li><li><code>sigsuspend</code>恢复之前的sigprocmask阻塞信号的处理</li><li>根据接收到的信号(用户或系统发送)，修改标记位来控制相应的子进程，给子进程发送相应的信号，或者套接字消息(类似上面的ngx_start_worker_processes的方式)。<br>这里我们会疑惑，哪里修改的标记位？哪里接受处理的信号。全局搜索一下可以找到：设置接收信号的回调函数在<code>main</code>中的<code>ngx_init_signals</code>函数中完成，根据对应的信号量调用<code>ngx_signal_handler</code>函数来修改相应标记位。</li></ol></li></ol><h4 id="worker进程"><a class="header-anchor" href="#worker进程"></a>worker进程</h4><ol><li>设置环境变量，是nginx中的全局变量<code>environ</code></li><li>执行<code>ngx_modules</code>中的<code>init_process</code>函数，也就是利用nginx中模块注册机制。</li><li>主<code>for ( ;; )</code>循环。<ol><li><p><code>ngx_process_events_and_timers</code>非常核心的函数，包含了事件处理，和延时处理。<code>nginx</code>中所有事务都是围绕这个函数中事件处理来完成的。也就是利用了状态机的机制，每次事件的触发，执行触发的相应事件，就是在该函数中完成。</p><ol><li>timer初始化，如果ngx开了线程处理方式，则timer初始化和处理有所差异。</li><li><code>ngx_process_events</code>核心函数。define为<code>ngx_event_actions.process_events</code>, <code>ngx_event_actions</code>是一个全局变量，这个全局变量可以注册不同的事件触发器模块(只能注册一个事件触发器，注册方式和普通模块注册一致)，比如你使用<code>epoll</code>做事件触发器，那么就使用<code>ngx_epool_module</code>中的事件触发器的<code>process_events</code>函数。而所有的事件都在<code>ngx_event.h</code>中有定义：</li></ol>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*add)(<span class="keyword">ngx_event_t</span> *ev, <span class="keyword">ngx_int_t</span> event, <span class="keyword">ngx_uint_t</span> flags);</span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*del)(<span class="keyword">ngx_event_t</span> *ev, <span class="keyword">ngx_int_t</span> event, <span class="keyword">ngx_uint_t</span> flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*enable)(<span class="keyword">ngx_event_t</span> *ev, <span class="keyword">ngx_int_t</span> event, <span class="keyword">ngx_uint_t</span> flags);</span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*disable)(<span class="keyword">ngx_event_t</span> *ev, <span class="keyword">ngx_int_t</span> event, <span class="keyword">ngx_uint_t</span> flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*add_conn)(<span class="keyword">ngx_connection_t</span> *c);</span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*del_conn)(<span class="keyword">ngx_connection_t</span> *c, <span class="keyword">ngx_uint_t</span> flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*process_changes)(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">ngx_uint_t</span> nowait);</span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*process_events)(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">ngx_msec_t</span> timer,</span><br><span class="line">                <span class="keyword">ngx_uint_t</span> flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*init)(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">ngx_msec_t</span> timer);</span><br><span class="line">    <span class="keyword">void</span>       (*done)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line">&#125; <span class="keyword">ngx_event_actions_t</span>;</span><br></pre></td></tr></table></figure><p>这里肯定有一些列的事件轮转机制，需要绘图列出TODO<br>3. 执行相应延时。<br>4. <code>posted_events</code>相应的事件还不清楚干啥用的TODO</p></li><li><p>处理接收到的系统信号或者主进程信号：<code>ngx_terminate</code>,<code>ngx_quit</code>,<code>ngx_reconfigure</code>或<code>ngx_reopen</code>。这里面的所代表的功能都很好理解，细节需要的时候再看。</p></li></ol></li></ol><h4 id="nginx架构"><a class="header-anchor" href="#nginx架构"></a>nginx架构</h4><p>从上面的代码分析，我们基本上可以得到大致的结论：</p><ol><li>nginx有多个进程，分别为master进程和work进程(这个从nginx的实际运行情况也可以看到)。</li><li>nginx通过环境变量和配置文件来进行管理。</li><li>master的工作是对work进程进行管理和控制，work进程进行实际的工作。</li></ol><p>因此我们能得到以下的结构图（<a href="http://tengine.taobao.org/book/chapter_02.html" target="_blank" rel="noopener">图片来源</a>）：<br><img src="/2021/07/11/nginx源码阅读/nginx%E6%9E%B6%E6%9E%84.png" alt="架构图"></p><h3 id="场景1的执行流程"><a class="header-anchor" href="#场景1的执行流程"></a>场景1的执行流程</h3><p>当nginx启动后，master进程就一直在主for循环里等待接收信号量，来进行work和自身的控制。而work进程则在主for循环中由<code>ngx_process_events_and_timers</code>函数来处理事件，或处理接收到的信号量。<br>那么场景1的触发流程入口，肯定在<code>ngx_process_events_and_timers</code>函数中的<code>process_events</code>函数触发，而这个函数是个全局函数指针，通过注册生效。而注册的地方我们在编译完成后可以发现一个<code>obj/ngx_modules.c</code>的文件，改文件通过<code>configure</code>生成，通过你选择的编译选择项来生成模块注册文件。那么我们先研究一下nginx的模块注册是如何工作的。</p><h4 id="nginx模块注册机制"><a class="header-anchor" href="#nginx模块注册机制"></a>nginx模块注册机制</h4><h5 id="注册入口"><a class="header-anchor" href="#注册入口"></a>注册入口</h5><p><code>ngx_modules.c</code>用于控制nginx模块注册，模块注册的统一入口。根据编译时的<code>configure</code>参数生成。其文件结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span>  ngx_core_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span>  ngx_errlog_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span>  ngx_conf_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span>  ngx_events_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span>  ngx_event_core_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span>  ngx_epoll_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span>  ngx_http_module;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ngx_module_t</span> *ngx_modules[] = &#123;</span><br><span class="line">    &amp;ngx_core_module,</span><br><span class="line">    &amp;ngx_errlog_module,</span><br><span class="line">    &amp;ngx_conf_module,</span><br><span class="line">    &amp;ngx_events_module,</span><br><span class="line">    &amp;ngx_event_core_module,</span><br><span class="line">    &amp;ngx_epoll_module,</span><br><span class="line">    &amp;ngx_http_module,</span><br><span class="line">    ...</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其核心注册机制就是通过配置文件，选择生成全局变量<code>ngx_modules</code>, nginx主体程序读取该全局变量的值来执行相应模块。</p><h5 id="模块入口"><a class="header-anchor" href="#模块入口"></a>模块入口</h5><p>通过注册机制可知，主程序与模块直接的交互只能通过<code>ngx_module_t</code>这个结构，也就是说<code>ngx_module_t</code>是模块提供的接口。<code>ngx_module_t</code>结构如下(先撇一眼，在<a href="#ngx_module_t%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90">后续</a>分析)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_module_s</span>      <span class="title">ngx_module_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_module_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            ctx_index;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            spare0;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            spare1;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            spare2;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            spare3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                 *ctx;</span><br><span class="line">    <span class="keyword">ngx_command_t</span>        *commands;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_master)(<span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_module)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_process)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_thread)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line">    <span class="keyword">void</span>                (*exit_thread)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line">    <span class="keyword">void</span>                (*exit_process)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                (*exit_master)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook0;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook1;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook2;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook3;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook4;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook5;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook6;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook7;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们现在已经知道如何进行模块注册，主程序和模块之间的交互接口。对于主程序来说，它并不知道模块具体功能是什么，只知道<code>ngx_module_t</code>这个结构，和<code>ngx_modules</code>全局量。那么现在我们就需要分析，<code>ngx_modules</code>在什么时候使用(模块实际生效位置)以及<code>ngx_module_t</code>里每个变量功能(模块生效干了啥)。即模块生效位置和功能。</p><h5 id="模块生效位置"><a class="header-anchor" href="#模块生效位置"></a>模块生效位置</h5><p>我们跟着启动顺序进行梳理，寻找<code>ngx_modules</code>使用的位置。注册模块分为两类，一是核心模块(NGX_CORE_MODULE)，二是配置模块(NGX_CONF_MODULE)。</p><ol><li><p>main函数，进行<code>ngx_module_t.index</code>初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ngx_max_module = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">    ngx_modules[i]-&gt;index = ngx_max_module++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>ngx_init_cycle</code>中执行注册的核心模块配置初始化(<code>module-&gt;create_conf</code>)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ngx_modules[i]-&gt;type != NGX_CORE_MODULE) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`ngx_module_t.ctx`强转`ngx_core_module_t`</span></span><br><span class="line">    <span class="keyword">module</span> = ngx_modules[i]-&gt;ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;create_conf) &#123;</span><br><span class="line">        rv = <span class="keyword">module</span>-&gt;create_conf(cycle);</span><br><span class="line">        <span class="keyword">if</span> (rv == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ngx_destroy_pool(pool);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cycle-&gt;conf_ctx[ngx_modules[i]-&gt;index] = rv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件解析中，读取注册的配置模块，并用于处理配置文件参数(具体配置方法后面细化)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ngx_modules[i]-&gt;type != NGX_CONF_MODULE</span><br><span class="line">     &amp;&amp; ngx_modules[i]-&gt;type != cf-&gt;module_type)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>注册的核心模块初始化，类似上述第二点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ngx_modules[i]-&gt;type != NGX_CORE_MODULE) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">module</span> = ngx_modules[i]-&gt;ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;init_conf) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;init_conf(cycle, cycle-&gt;conf_ctx[ngx_modules[i]-&gt;index])</span><br><span class="line">            == NGX_CONF_ERROR)</span><br><span class="line">        &#123;</span><br><span class="line">            environ = senv;</span><br><span class="line">            ngx_destroy_cycle_pools(&amp;conf);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行注册模块各自的<code>init_module</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ngx_modules[i]-&gt;init_module) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ngx_modules[i]-&gt;init_module(cycle) != NGX_OK) &#123;</span><br><span class="line">            <span class="comment">/* fatal */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>work里<code>ngx_single_process_cycle</code>中会执行模块的<code>init_process</code>和<code>exit_process</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ngx_modules[i]-&gt;init_process) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ngx_modules[i]-&gt;init_process(cycle) == NGX_ERROR) &#123;</span><br><span class="line">            <span class="comment">/* fatal */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ngx_terminate || ngx_quit) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ngx_modules[i]-&gt;exit_process) &#123;</span><br><span class="line">            ngx_modules[i]-&gt;exit_process(cycle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>master的<code>ngx_master_process_cycle</code>函数的子函数，<code>ngx_master_process_exit</code>会调用到对应的函数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (ngx_modules[i]-&gt;exit_master) &#123;</span><br><span class="line">         ngx_modules[i]-&gt;exit_master(cycle);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><p>上面的1-5几乎全是模块配置初始化相关的内容，<code>init_process</code>和<code>exit_process</code>是work进程中调用的模块初始化和退出。而<code>init_master</code>和<code>exit_master</code>则是在master进程中进行初始化和退出的。但这里还是有一个问题，模块真正处理请求的函数时如何和work程序挂钩的？</p><h5 id="nginx事件处理流程"><a class="header-anchor" href="#nginx事件处理流程"></a>nginx事件处理流程</h5><p>这里要弄清楚事件处理流程，有两种方式：</p><ol><li><p><s>从必调的<code>init_process</code>入手，阅读一个注册模块的<code>init_process</code>函数，看实现了什么。</s></p><ol><li>首先从一个熟悉的<code>ngx_http_module</code>入手，看<code>init_process</code>做了什么。找到定义的<code>ngx_http_module</code>:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_core_module_t</span>  ngx_http_module_ctx = &#123;</span><br><span class="line">     ngx_string(<span class="string">"http"</span>),</span><br><span class="line">     <span class="literal">NULL</span>,</span><br><span class="line">     <span class="literal">NULL</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ngx_module_t</span>  ngx_http_module = &#123;</span><br><span class="line">     NGX_MODULE_V1,</span><br><span class="line">     &amp;ngx_http_module_ctx,                  <span class="comment">/* module context */</span></span><br><span class="line">     ngx_http_commands,                     <span class="comment">/* module directives */</span></span><br><span class="line">     NGX_CORE_MODULE,                       <span class="comment">/* module type */</span></span><br><span class="line">     <span class="literal">NULL</span>,                                  <span class="comment">/* init master */</span></span><br><span class="line">     <span class="literal">NULL</span>,                                  <span class="comment">/* init module */</span></span><br><span class="line">     <span class="literal">NULL</span>,                                  <span class="comment">/* init process */</span></span><br><span class="line">     <span class="literal">NULL</span>,                                  <span class="comment">/* init thread */</span></span><br><span class="line">     <span class="literal">NULL</span>,                                  <span class="comment">/* exit thread */</span></span><br><span class="line">     <span class="literal">NULL</span>,                                  <span class="comment">/* exit process */</span></span><br><span class="line">     <span class="literal">NULL</span>,                                  <span class="comment">/* exit master */</span></span><br><span class="line">     NGX_MODULE_V1_PADDING</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>一看，麻了麻了，这啥也没有啊。<code>init_process</code>函数为空，<code>ngx_http_module_ctx</code>中的<code>create_conf</code>和<code>init_conf</code>也为空。<br>然后一连看了多个http的模块，发现<code>init_process</code>都为空。看来这种方法不行了。</p></li><li><p>从<code>work</code>进程入手，看谁注册了<code>ngx_event_actions</code>时间处理函数，然后阅读该模块的实现机制。</p><ol><li>在linux下，默认使用的是<code>epoll</code>, 对应注册的<code>ngx_event_actions</code>如下：</li></ol> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ngx_event_module_t</span>  ngx_poll_module_ctx = &#123;</span><br><span class="line">    &amp;poll_name,</span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* create configuration */</span></span><br><span class="line">    ngx_poll_init_conf,                    <span class="comment">/* init configuration */</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ngx_poll_add_event,                <span class="comment">/* add an event */</span></span><br><span class="line">        ngx_poll_del_event,                <span class="comment">/* delete an event */</span></span><br><span class="line">        ngx_poll_add_event,                <span class="comment">/* enable an event */</span></span><br><span class="line">        ngx_poll_del_event,                <span class="comment">/* disable an event */</span></span><br><span class="line">        <span class="literal">NULL</span>,                              <span class="comment">/* add an connection */</span></span><br><span class="line">        <span class="literal">NULL</span>,                              <span class="comment">/* delete an connection */</span></span><br><span class="line">        <span class="literal">NULL</span>,                              <span class="comment">/* process the changes */</span></span><br><span class="line">        ngx_poll_process_events,           <span class="comment">/* process the events */</span></span><br><span class="line">        ngx_poll_init,                     <span class="comment">/* init the events */</span></span><br><span class="line">        ngx_poll_done                      <span class="comment">/* done the events */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>work进程中调用的事件函数<code>(void) ngx_process_events(cycle, timer, flags);</code>对应着<code>epoll</code>中的<code>ngx_poll_process_events</code>函数。<br>那么我们可以得到初步的结论：</p><ol><li>nginx的模块依赖是一层层递进的：<ol><li>核心模块</li><li>事件处理模块</li><li>业务处理模块</li></ol></li><li><code>ngx_module_t</code>负责模块注册时的初始化。比如各种配置相关处理，执行业务前的初始化等。</li><li><code>ngx_event_module_t</code>则是负责进行业务注册，也就是当事件触发后，我应当执行哪些业务。而业务注册则是通过<code>ngx_event_actions_t.add*</code>函数实现。</li></ol></li></ol><p>结合上述两点，可以初步得到模块注册和事件处理的流程：</p><ol><li><p>在<code>ngx_event_core_module</code>注册模块(编译时控制)，生成<code>ngx_modules.c</code>文件，包含全局变量<code>ngx_modules</code></p></li><li><p>nginx启动时执行相关初始化,执行<code>ngx_modules</code>中<code>init_conf</code>等。</p></li><li><p>启动nginx的work进程，执行<code>ngx_modules</code>中<code>init_process</code>。其中包含<code>ngx_event_core_module.ngx_event_process_init</code></p></li><li><p><code>ngx_event_process_init</code>又以同样的原理，进行<code>event事件的注册</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (m = <span class="number">0</span>; ngx_modules[m]; m++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ngx_modules[m]-&gt;type != NGX_EVENT_MODULE) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_modules[m]-&gt;ctx_index != ecf-&gt;use) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ngx_event_module_t  *module;</span></span><br><span class="line">    <span class="keyword">module</span> = ngx_modules[m]-&gt;ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;actions.init(cycle, ngx_timer_resolution) != NGX_OK) &#123;</span><br><span class="line">        <span class="comment">/* fatal */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ngx_event_process_init</code>注册的事件中就有<code>ngx_epoll_module</code>模块(ngx_modules.c),可以说<code>ngx_epoll_module</code>是真正处理事件的地方。<code>ngx_event_process_init</code>中调用的<code>module-&gt;actions.init</code>在这里本质就是<code>ngx_epoll_init</code></p></li><li><p><code>ngx_epoll_init</code>中进行了<code>ngx_event_actions</code>事件的注册：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_event_actions = ngx_epoll_module_ctx.actions;</span><br></pre></td></tr></table></figure></li><li><p>nginx的work进程处理事件实际调用的是<code>ngx_event_actions.process_events</code>,那么就等同于<code>ngx_epoll_module</code>中的<code>ngx_epoll_process_events</code>函数。</p></li><li><p><code>ngx_epoll_process_events</code>中调用<code>epoll_wait</code>来接收事件，接收到的事件通过<code>event_list[i].data.ptr</code>用户自定义指针来进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只列出核心步骤，省略其他代码</span></span><br><span class="line"><span class="comment">//使用epoll的异步io来获取事件</span></span><br><span class="line">events = epoll_wait(ep, event_list, (<span class="keyword">int</span>) nevents, timer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; events; i++) &#123;</span><br><span class="line">    <span class="comment">//读取触发的事件，触发的事件是之前通过epoll_ctl注册到ep中的。</span></span><br><span class="line">    revents = event_list[i].events;</span><br><span class="line">    <span class="comment">//用户自定义的结构体指针，这里是nginx中的ngx_connection_s结构</span></span><br><span class="line">    c = event_list[i].data.ptr;</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    rev = c-&gt;read;</span><br><span class="line">    <span class="keyword">if</span> ((revents &amp; EPOLLIN) &amp;&amp; rev-&gt;active) &#123;</span><br><span class="line">        rev-&gt;handler(rev);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//写入数据</span></span><br><span class="line">     wev = c-&gt;write;</span><br><span class="line">     <span class="keyword">if</span> ((revents &amp; EPOLLOUT) &amp;&amp; wev-&gt;active) &#123;</span><br><span class="line">             wev-&gt;handler(wev);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>epoll事件处理通过调用<code>event_list[i].data.ptr</code>指针来指向具体实现进行处理。而事件的注册，则由<code>ngx_event_actions.add/add_conn</code>来调用对应的注册事件<code>epoll_ctl</code>来实现。</p><ol><li><code>ngx_event_actions.add/add_conn</code>相当于一个抽象接口，实现注册的一方，只需要根据<code>add</code>接口的定义<code>ngx_int_t  (*add)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);</code>实现注册即可。而调用的函数也只需要调用对应的<code>ngx_event_actions.add</code>，传递对应的参数，不用关系内部实现。</li><li><code>#define ngx_add_event        ngx_event_actions.add</code>被进一步封装成<code>ngx_handle_read_event, ngx_handle_write_event</code>等，由业务模块来进行调用注册。</li><li>业务模块调用<code>ngx_handle_write_event</code>等事件注册时机通常在<code>ngx_module_s</code>结构下的<code>ngx_command_t</code>模块，比如<code>ngx_http_module</code>模块的定义如下：</li></ol> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_command_t</span>  ngx_http_commands[] = &#123;</span><br><span class="line"></span><br><span class="line">&#123; ngx_string(<span class="string">"http"</span>),</span><br><span class="line">  NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,</span><br><span class="line">  ngx_http_block, <span class="comment">//改函数中进行了事件注册的调用。</span></span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="literal">NULL</span> &#125;,</span><br><span class="line"></span><br><span class="line">  ngx_null_command</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ngx_module_t</span>  ngx_http_module = &#123;</span><br><span class="line">    NGX_MODULE_V1,</span><br><span class="line">    &amp;ngx_http_module_ctx,                  <span class="comment">/* module context */</span></span><br><span class="line">    ngx_http_commands,                     <span class="comment">/* module directives */</span></span><br><span class="line">    NGX_CORE_MODULE,                       <span class="comment">/* module type */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* init master */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* init module */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* init process */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* init thread */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* exit thread */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* exit process */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* exit master */</span></span><br><span class="line">    NGX_MODULE_V1_PADDING</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="4"><li>而每个模块的<code>ngx_command_t</code>结构，都会在<code>ngx_conf_handler</code>函数中进行处理：</li></ol> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmd = ngx_modules[i]-&gt;commands;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">rv = cmd-&gt;<span class="built_in">set</span>(cf, cmd, conf);</span><br></pre></td></tr></table></figure></li></ol><h4 id="nginx注册机制结构图"><a class="header-anchor" href="#nginx注册机制结构图"></a>nginx注册机制结构图</h4><p>根据Nginx的注册机制，我们把结构流程图分为了三个部分：</p><ol><li>编译时控制注册哪些模块</li><li>运行时模块注册执行</li><li>运行时事件处理函数注册执行</li></ol><p>前文已提过，nginx的模块注册控制是根据<code>configure</code>配置来控制是否编译某些文件，以及生成对应的<code>ngx_module.c</code>文件来控制注册列表。而执行的时候，则根据<code>ngx_module.c</code>文件中的模块列表的全局变量值<code>ngx_modules</code>来执行对应模块实现的接口。<br>TODO 对应的commands没有体现<br><img src="/2021/07/11/nginx源码阅读/%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8C%E6%9C%BA%E5%88%B6.drawio.png" alt="nginx模块注册机制"></p><p>nginx通过以上机制对事件处理模块进行注册，实例化事件处理接口<code>ngx_event_actions</code>（这个变量只有一个，也就是说nginx同时只能有一个事件处理模块）。<br>nginx通过事件处理统一接口<code>ngx_event_actions.add</code>，来进行事件处理函数的注册，同样删除事件也有相应的接口，而事件注册的具体方式，则通过上述注册的事件处理模块来实现(如<code>epoll</code>,<a href="https://blog.csdn.net/s2603898260/article/details/106821040" target="_blank" rel="noopener">一些epoll示例</a>)。<br>TODO 该图还需要修改和细化<br><img src="/2021/07/11/nginx源码阅读/%E4%BA%8B%E4%BB%B6%E6%B3%A8%E5%86%8C%E6%9C%BA%E5%88%B6.drawio.png" alt="nginx事件注册机制"></p><h4 id="一个事件触发流程"><a class="header-anchor" href="#一个事件触发流程"></a>一个事件触发流程</h4><ol><li><p>nginx启动后会监听配置的端口，监听端口后才会进行fork子进程，此时所有nginx都会监听对应的端口。使用算法让其中一个子进程获得fd</p><ol><li>为了方式<code>惊群</code>效应，通过获取互斥锁的方式保证只有一个子进程获取到fd。<a href="https://blog.csdn.net/u012062760/article/details/48732535" target="_blank" rel="noopener">参考</a></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngx_process_events_and_timers</span></span><br><span class="line"> <span class="keyword">if</span> (ngx_use_accept_mutex) &#123;</span><br><span class="line">     <span class="keyword">if</span> (ngx_accept_disabled &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         ngx_accept_disabled--;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//在此函数中尝试进行加锁，争抢锁。</span></span><br><span class="line">         <span class="keyword">if</span> (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//抢到锁，使用post机制进行通知</span></span><br><span class="line">         <span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">             flags |= NGX_POST_EVENTS;</span><br><span class="line"></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//没有抢到，推迟进行锁竞争</span></span><br><span class="line">             <span class="keyword">if</span> (timer == NGX_TIMER_INFINITE</span><br><span class="line">                 || timer &gt; ngx_accept_mutex_delay)</span><br><span class="line">             &#123;</span><br><span class="line">                 timer = ngx_accept_mutex_delay;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//尝试加锁，成功即可进行fd获取，失败则过一段时间再竞争。</span></span><br><span class="line"> ngx_trylock_accept_mutex(<span class="keyword">ngx_cycle_t</span> *cycle)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (ngx_shmtx_trylock(&amp;ngx_accept_mutex)) &#123;</span><br><span class="line"></span><br><span class="line">         ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                     <span class="string">"accept mutex locked"</span>);</span><br><span class="line">     ...</span><br><span class="line">     &#125;</span><br><span class="line">      ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="string">"accept mutex lock failed: %ui"</span>, ngx_accept_mutex_held);</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>加锁后，事件来临之前，获取锁work进程一直阻塞在<code>ngx_epoll_module.c:ngx_epoll_process_events-&gt;epoll_wait</code>，而没有获取锁的设置timer，进入下一轮循环。</p></li><li><p>触发<code>ngx_event_accept</code>函数，该函数在<code>ngx_event_process_init</code>时期被注册到了<code>epoll</code>中。</p><ol><li>获取链接相关信息, 使用<code>accept</code>获取返回新的<code>socket</code>。<br><img src="/2021/07/11/nginx源码阅读/accept%E8%AF%A6%E8%A7%A3.png" alt="accept原理"><a href="https://blog.csdn.net/Z_Stand/article/details/102535706" target="_blank" rel="noopener">图片来源</a></li><li>调用注册的<code>ls-&gt;handler</code>函数，这里对应的是<code>ngx_http_init_connection</code>，该函数是在<code>ngx_http_commands</code>里的<code>ngx_http_block</code>函数中被调用的。<ol><li><code>ngx_http_init_connection</code>初始化了一个timer(TODO干啥的？)，然后使用<code>ngx_handle_read_event</code>注册了一个读事件，事件<code>rev-&gt;handler = ngx_http_init_request</code></li></ol></li></ol></li><li><p>触发步骤2注册的<code>epoll</code>读事件，对应调用<code>rev-&gt;handler</code>函数，也就是<code>ngx_http_init_request</code>函数</p></li><li><p><code>ngx_http_init_request</code>函数处理完所有的http请求的数据处理。</p></li></ol><h4 id="事件轮转"><a class="header-anchor" href="#事件轮转"></a>事件轮转</h4><ol><li><code>nginx</code>的<code>master</code>进程在接收到请求后，将获取到的<code>fd</code>根据算法分配给某一个子进程，子进程触发<code>epoll</code>监听事件，获取执行<code>accept</code>，并根据类型增加<code>epoll</code>的读/写事件</li><li><code>epoll</code>触发读/写事件，进行读写操作。由于<code>nginx</code>的<code>epoll</code>是<code>ET</code>模式, 如果第一次读取数据没有读完，会继续增加对应的<code>epoll</code>读事件。(TODO)</li><li>继续触发后续事件。</li></ol><h4 id="timer机制"><a class="header-anchor" href="#timer机制"></a>timer机制</h4><p><a href="https://www.cnblogs.com/549294286/p/6058774.html" target="_blank" rel="noopener">Nginx的定时事件的实现</a><br>nginx的master进程使用的是系统信号来进行死循环的延时，关键函数<code>setitimer(ITIMER_REAL, &amp;itv, NULL)</code>.<br>在worker进程中，则是使用自定义的timer，来判断超时，以及调用超时函数。nginx中的timer是通过红黑树实现的。</p><ol><li><p>timer的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngx_event_process_init函数中调用</span></span><br><span class="line"><span class="keyword">ngx_int_t</span></span><br><span class="line"> ngx_event_timer_init(<span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     ngx_rbtree_init(&amp;ngx_event_timer_rbtree, &amp;ngx_event_timer_sentinel,</span><br><span class="line">                     ngx_rbtree_insert_timer_value);</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> NGX_OK;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>整体流程，和timer的读取处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主for循环</span></span><br><span class="line"><span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"worker cycle"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要处理事件和event</span></span><br><span class="line">    ngx_process_events_and_timers(cycle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收到退出信号，terminate或者quit</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_terminate || ngx_quit) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ngx_modules[i]-&gt;exit_process) &#123;</span><br><span class="line">                ngx_modules[i]-&gt;exit_process(cycle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//内部会调用exit</span></span><br><span class="line">        ngx_master_process_exit(cycle);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ngx_process_events_and_timers:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在红黑树中找到对应的最新超时。</span></span><br><span class="line"><span class="keyword">if</span> (ngx_timer_resolution) &#123;</span><br><span class="line">     timer = NGX_TIMER_INFINITE;</span><br><span class="line">     flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     timer = ngx_event_find_timer();</span><br><span class="line">     flags = NGX_UPDATE_TIME;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//在evnet的wait前更新ngx_current_msec</span></span><br><span class="line"> delta = ngx_current_msec;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*事件处理核心工作函数，将timer传递给epoll_wait中，作为超时时间。</span></span><br><span class="line"><span class="comment"> 如果该timer从epoll_wait中超时，那么证明这个timer到期了，</span></span><br><span class="line"><span class="comment"> 可以执行后面的ngx_event_expire_timers */</span></span><br><span class="line"> (<span class="keyword">void</span>) ngx_process_events(cycle, timer, flags);</span><br><span class="line"></span><br><span class="line"> delta = ngx_current_msec - delta;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//只有超过了1ms，才会执行timer中的超时。</span></span><br><span class="line"> <span class="keyword">if</span> (delta) &#123;</span><br><span class="line">     ngx_event_expire_timers();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>timer的添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本质上就是向红黑树中插入节点</span></span><br><span class="line"><span class="keyword">static</span> ngx_inline <span class="keyword">void</span></span><br><span class="line"> ngx_event_add_timer(<span class="keyword">ngx_event_t</span> *ev, <span class="keyword">ngx_msec_t</span> timer)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">ngx_msec_t</span>      key;</span><br><span class="line">     <span class="keyword">ngx_msec_int_t</span>  diff;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     ngx_mutex_lock(ngx_event_timer_mutex);</span><br><span class="line"></span><br><span class="line">     ngx_rbtree_insert(&amp;ngx_event_timer_rbtree, &amp;ev-&gt;timer);</span><br><span class="line"></span><br><span class="line">     ngx_mutex_unlock(ngx_event_timer_mutex);</span><br><span class="line"></span><br><span class="line">     ev-&gt;timer_set = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><p>红黑树：<br><a href="https://blog.csdn.net/jjc120074203/article/details/78780221" target="_blank" rel="noopener">快速理解红黑树原理</a><br><a href="https://www.jianshu.com/p/038585421b73" target="_blank" rel="noopener">红黑树之原理详解</a></p><h3 id="nginx中的事件机制"><a class="header-anchor" href="#nginx中的事件机制"></a>nginx中的事件机制</h3><p><a href="https://tangocc.github.io/2018/07/08/nginx-event-model/" target="_blank" rel="noopener">参考</a></p><ol><li><p>nginx通过<code>accept_mutex</code>锁来解决惊群问题，意味着同一时间一个请求只有一个进程接收到</p></li><li><p>当进程接收到数据后，事件模块产生事件，并添加到事件队列中。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//epoll触发事件</span></span><br><span class="line">events = epoll_wait(ep, event_list, (<span class="keyword">int</span>) nevents, timer);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//这里将读写事件放到ngx_posted_accept_events或者ngx_posted_events事件中</span></span><br><span class="line"><span class="comment">//在ngx_process_events_and_timers函数中的ngx_event_process_posted中进行处理</span></span><br><span class="line"><span class="comment">//猜测这个锁是在多线程的模式下才加上的</span></span><br><span class="line">ngx_mutex_lock(ngx_posted_events_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; events; i++) &#123;</span><br><span class="line">    c = event_list[i].data.ptr;</span><br><span class="line"></span><br><span class="line">    rev = c-&gt;read;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; NGX_POST_EVENTS) &#123;</span><br><span class="line">        <span class="built_in">queue</span> = (<span class="keyword">ngx_event_t</span> **) (rev-&gt;accept ?</span><br><span class="line">                        &amp;ngx_posted_accept_events : &amp;ngx_posted_events);</span><br><span class="line"></span><br><span class="line">        ngx_locked_post_event(rev, <span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事件放到<code>ngx_posted_accept_events</code>队列或<code>ngx_posted_events</code>队列后，由<code>ngx_process_events_and_timers</code>函数进行处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取防止惊群的锁</span></span><br><span class="line"><span class="keyword">if</span> (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理事件接收的事件</span></span><br><span class="line"><span class="keyword">if</span> (ngx_posted_accept_events) &#123;</span><br><span class="line">    ngx_event_process_posted(cycle, &amp;ngx_posted_accept_events);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放锁，防止阻塞其他进程</span></span><br><span class="line"><span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">    ngx_shmtx_unlock(&amp;ngx_accept_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理其他事件</span></span><br><span class="line">ngx_event_process_posted(cycle, &amp;ngx_posted_events);</span><br></pre></td></tr></table></figure></li></ol><p>防止惊群问题，nginx在后续采用了新的方式<code>Socket ReusePort</code>来处理。同时对应的就是linux系统中的<a href="https://lwn.net/Articles/542629/" target="_blank" rel="noopener">SO_REUSEPORT</a>参数。粗浅理解可<a href="http://xiaorui.cc/archives/2413" target="_blank" rel="noopener">参考</a>，<a href="https://zhuanlan.zhihu.com/p/351065391" target="_blank" rel="noopener">其他一些参考</a></p><h1>NEXT：</h1><p>使用gdb+debug日志更加快捷和方便。</p><ol><li>nginx的web缓存机制(相同请求缓存返回),NGINX为单进程模型，不存在互斥问题，直接到cache中找即可，只是数据写入如果要进行落盘的时候，是异步操作。</li><li>编写一个基于<code>epoll</code>的状态机。epoll状态机只能基于fd轮转，而触发只能通过内核软中断触发。epoll是用于io复用层面，意味着必须有io操作。业务层面的状态转换并没有io操作，并不适合这个。</li><li>更新一些图和说明</li></ol><h4 id="nginx中的命名习惯"><a class="header-anchor" href="#nginx中的命名习惯"></a>nginx中的命名习惯</h4><ol><li>几乎所有的通用变量都使用ngx_xxx进行了重定义，比如<code>intptr_t-&gt;ngx_int_t</code>。至于<code>intptr_t</code>数据结构的解析，<a href="https://www.cnblogs.com/yinbiao/p/12566738.html" target="_blank" rel="noopener">可参考</a></li><li>nginx中，_s结尾的都代表是定义的结构体，_t都代表在声明变量时需要使用的类型，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct ngx_log_s         ngx_log_t;</span><br><span class="line">struct ngx_log_s &#123; //_s用于定义结构</span><br><span class="line"> ngx_uint_t           log_level;</span><br><span class="line"> ngx_open_file_t     *file;</span><br><span class="line"> ...</span><br><span class="line"> &#125;;</span><br><span class="line"> ngx_log_t        *log;  //_t用于声明变量</span><br></pre></td></tr></table></figure></li></ol><h4 id="nginx中数据结构"><a class="header-anchor" href="#nginx中数据结构"></a>nginx中数据结构</h4><h4 id="nginx的数据共享"><a class="header-anchor" href="#nginx的数据共享"></a>nginx的数据共享</h4><h3 id="分析验证"><a class="header-anchor" href="#分析验证"></a>分析验证</h3><p>重新编译debug版本，来验证我们的猜想，或者使用gdb跟踪也是可以的。gdb跟踪更方便快捷，但是在多进程分析的时候，debug模式往往更方便。</p><h3 id="整体流程图"><a class="header-anchor" href="#整体流程图"></a>整体流程图</h3><h2 id="其他"><a class="header-anchor" href="#其他"></a>其他</h2><h3 id="nginx中的一些骚操作"><a class="header-anchor" href="#nginx中的一些骚操作"></a>nginx中的一些骚操作</h3><h4 id="内存节约"><a class="header-anchor" href="#内存节约"></a>内存节约</h4><ol><li><code>unsigned    recycled:1;</code><br>使用了<a href="https://www.runoob.com/cprogramming/c-bit-fields.html" target="_blank" rel="noopener">位域</a>的方法来减少内存的使用。<code>unsigned</code> == <code>unsigned int</code></li></ol><h3 id="参考"><a class="header-anchor" href="#参考"></a>参考</h3><p><a href="http://tengine.taobao.org/book/index.html" target="_blank" rel="noopener">Nginx开发从入门到精通</a><br><a href="https://cloud.tencent.com/developer/article/1447290" target="_blank" rel="noopener">通俗易懂的Nginx工作原理</a><br><a href="https://www.zhihu.com/question/486578358" target="_blank" rel="noopener">epoll 原理是如何实现的</a></p><h4 id="可以列出相关的看过的书籍，或者问题参考链接网页一类的。"><a class="header-anchor" href="#可以列出相关的看过的书籍，或者问题参考链接网页一类的。"></a>可以列出相关的看过的书籍，或者问题参考链接网页一类的。</h4><p>备注：<br>可以进行单独开帖：</p><ol><li>nginx中的一些骚操作</li><li>nginx中数据结构</li><li>nginx的数据共享</li><li>nginx的模块机制<ol><li>都可以在编译后的objs/ngx_modules.c查看哪些被注册。</li><li>模块分为几大类：<ol><li>事件模块，构建不同的事件触发框架，类似<code>epoll</code>, <code>poll</code>。这类模块不实现具体功能，只是配置不同的的事件触发器。</li><li>功能模块，如http模块…</li></ol></li><li>模块注册方式：<ol><li>有configure来控制文件拷贝，进而控制全局变量<code>ngx_modules</code>和<code>ngx_event_actions</code>，以此达到模块注册效果。</li><li>configure内容解析？？TODO</li></ol></li></ol></li><li>nginx中的events以及进程间通信</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《鲁迅全集》读书笔记</title>
      <link href="/2021/07/10/%E3%80%8A%E9%B2%81%E8%BF%85%E5%85%A8%E9%9B%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/10/%E3%80%8A%E9%B2%81%E8%BF%85%E5%85%A8%E9%9B%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>来膜拜迅哥儿的作品(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>主题：迅哥儿，不用说了吧<br>类别：文学作品-&gt;小说+散文-&gt;迅哥儿<br>概要：略</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>迅哥儿的大名，在学生时代早已如雷贯耳，我也没有想过在二十多了还来品读他的作品。也是因为B站上一个介绍鲁迅先生的视频，让我重新燃起了阅读他作品的兴趣。这次没有要是要求的阅读理解，没有摘抄背诵，就单单的当做一个小说看，轻松愉悦的体验作品本身带来的第一感觉。<br>目前只看了第一二卷，里面有很多熟悉的文章，想看看再次阅读的感觉，可惜了没有当时读完某篇文章，就做记录导致遗失了许多。我也没有什么文学素养，是个认字的文盲，也就记录一些我觉得有趣，还在记忆里有些印象，或者对我来说眼前一亮的文章(没有亮的文章估计我没看懂)</p><h2 id="随感"><a class="header-anchor" href="#随感"></a>随感</h2><p>下面的文章是我看完后有所映象的文章，写下我的印象，有兴趣的可以自读原文</p><h3 id="第一卷"><a class="header-anchor" href="#第一卷"></a>第一卷</h3><h4 id="坟"><a class="header-anchor" href="#坟"></a>坟</h4><h5 id="我们现在怎样做父亲"><a class="header-anchor" href="#我们现在怎样做父亲"></a>我们现在怎样做父亲</h5><p>不得不说，那个父为刚的时代拥有现在(2020)部分人才能拥有的思想，着实佩服。<br><strong>‘这样，便是父母对于子女，应该健全的产生，尽力的教育，完全的解放。’</strong></p><h5 id="未有天才之前"><a class="header-anchor" href="#未有天才之前"></a>未有天才之前</h5><p>天才需要土壤，鲜花需要绿叶，不是说一个人是土壤就该贬责他，而众多肥沃的土壤，总会有长出天才的一天。<br><strong>‘天才并不是自生自长在深林荒野里的怪物，是由可以使天才生长的民众产生，长育出来的，所以没有这种民众，就没有天才。’</strong></p><h5 id="说胡须"><a class="header-anchor" href="#说胡须"></a>说胡须</h5><p>一个胡子的形式别人就说东说西，上纲上线，按现在的话说，吃多了。</p><h5 id="论“他妈的！”"><a class="header-anchor" href="#论“他妈的！”"></a>论“他妈的！”</h5><p>题目眼前一亮，原来这是“国骂”，一直流传至今啊。</p><h4 id="呐喊"><a class="header-anchor" href="#呐喊"></a>呐喊</h4><h5 id="自序"><a class="header-anchor" href="#自序"></a>自序</h5><p><strong>‘“假如一间铁屋子，是绝无窗户而万难破毁的，里面有许多熟睡的人们，不久都要闷死了，然而是从昏睡入死灭，并不感到就死的悲哀。现在你大嚷起来，惊起了较为清醒的几个人，使这不幸的少数者来受无可挽救的临终的苦楚，你倒以为对得起他们么？”<br>“然而几个人既然起来，你不能说决没有毁坏这铁屋的希望。”’</strong></p><h5 id="狂人日记"><a class="header-anchor" href="#狂人日记"></a>狂人日记</h5><p><strong>‘今天晚上，很好的月光。<br>我不见他，已是三十多年；今天见了，精神分外爽快。才知道以前的三十多年，全是发昏；然而须十分小心。不然，那赵家的狗，何以看我两眼呢？<br>我怕得有理。’</strong><br><strong>‘凡事总须研究，才会明白，古来时常吃人，我也还记得，可是不甚清楚。我翻开历史一查，这历史没有年代，歪歪斜斜的每页上都写着“仁义道德”几个字。我横竖睡不着，仔细看了半夜，才从字缝里看出字来，满本都写着两个字是“吃人”！’</strong></p><h5 id="一件小事"><a class="header-anchor" href="#一件小事"></a>一件小事</h5><p>如果这件小事放到现在，估计又是另外一个故事了……</p><h5 id="故乡"><a class="header-anchor" href="#故乡"></a>故乡</h5><p><strong>‘“阿！闰土哥，——你来了？…”<br>我接着便有许多话，想要连珠一般涌出：角鸡、跳鱼儿、贝壳、猹，…但又总觉得被什么挡着似的。单在脑里面回旋，吐不出口外去。<br>他站住了，脸上现出欢喜和凄凉的神情；动着嘴唇，却没有作声。他的态度终于恭敬起来了，分明的叫道：<br>“老爷！…”’</strong></p><h5 id="阿Q正传"><a class="header-anchor" href="#阿Q正传"></a>阿Ｑ正传</h5><p><strong>‘闲人还不完，只撩他，于是终而至于打。阿Ｑ在形式上打败了，被人揪住黄辫子，在壁上碰了四五个响头，闲人这才心满意足的得胜的走了，阿Ｑ站了一刻，心里想，“我总算被儿子打了，现在的世界真不像样…”于是也心满意足的得胜的走了。’</strong></p><h4 id="野草"><a class="header-anchor" href="#野草"></a>野草</h4><p>这个合集的文章我觉得都非常精炼，耐读，值得都看看</p><h5 id="秋夜"><a class="header-anchor" href="#秋夜"></a>秋夜</h5><p><strong>‘在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。’</strong></p><h5 id="我的失恋"><a class="header-anchor" href="#我的失恋"></a>我的失恋</h5><p><strong>‘我的所爱在山腰；<br>想去寻她山太高，<br>低头无法泪沾袍。<br>爱人赠我百蝶巾；<br>回她什么：猫头鹰。<br>从此翻脸不理我，<br>不知何故兮使我心惊。<br>……’</strong></p><h5 id="希望"><a class="header-anchor" href="#希望"></a>希望</h5><p><strong>‘我只得由我来肉搏这空虚中的暗夜了，纵使寻不到身外的青春，也总得自己来一掷我身中的迟暮。但暗夜又在那里呢？现在没有星，没有月光以至笑的渺茫和爱的翔舞；青年们很平安，而我的面前又竟至于并且没有真的暗夜。<br>绝望之为虚妄，正与希望相同！’</strong></p><h5 id="过客"><a class="header-anchor" href="#过客"></a>过客</h5><p><strong>‘翁——前面？前面，是坟。<br>客——（诧异地，）坟？<br>孩——不，不，不的。那里有许多许多野百合、野蔷薇，我常常去玩，去看他们的。’</strong><br><strong>‘客——料不定可能走完？…（沉思，忽然惊起，）那不行！我只得走。回到那里去，就没一处没有名目，没一处没有地主，没一处没有驱逐和牢笼，没一处没有皮面的笑容，没一处没有眶外的眼泪。我憎恶他们，我不回转去！’</strong></p><h5 id="狗的驳诘"><a class="header-anchor" href="#狗的驳诘"></a>狗的驳诘</h5><p><strong>‘“呔！住口！你这势利的狗！”<br>“嘻嘻！”他笑了，还接着说，“不敢，愧不如人呢。”’</strong></p><h5 id="聪明人和傻子和奴才"><a class="header-anchor" href="#聪明人和傻子和奴才"></a>聪明人和傻子和奴才</h5><h3 id="第二卷"><a class="header-anchor" href="#第二卷"></a>第二卷</h3><h4 id="热风"><a class="header-anchor" href="#热风"></a>热风</h4><h5 id="随感录三十六"><a class="header-anchor" href="#随感录三十六"></a>随感录三十六</h5><p><strong>‘有人说：“我们要特别生长；不然，何以为中国人！”<br>于是乎要从“世界人”中挤出。<br>于是乎中国人失了世界，却暂时仍要在这世界上住！——这便是我的大恐惧。’</strong></p><h5 id="随感录四十一"><a class="header-anchor" href="#随感录四十一"></a>随感录四十一</h5><p><strong>‘纵令不过一洼浅水，也可以学学大海；横竖都是水，可以相通。几粒石子，任他们暗地里掷来；几滴秽水，任他们从背后泼来就是了。’</strong></p><h5 id="随感录四十七"><a class="header-anchor" href="#随感录四十七"></a>随感录四十七</h5><p><strong>‘张三、李四是同时人。张三记了古典来做古文；李四又记了古典，去读张三做的古文。我想：古典是古人的时事，要晓得那时的事，免不了翻着古典；现在两位既然同时，何妨老实说出，一目了然，省却你也记古典，我也记古典的工夫呢？’</strong><br>正如现在的什么yyds，awsl……</p><h5 id="随感录五十四"><a class="header-anchor" href="#随感录五十四"></a>随感录五十四</h5><p><strong>‘要想进步，要想太平，总得连根的拔去了“二重思想”。因为世界虽然不小，但彷徨的人种，是终竟寻不出位置的。’</strong></p><h5 id="六十六-生命的路"><a class="header-anchor" href="#六十六-生命的路"></a>六十六 生命的路</h5><p><strong>‘什么是路？就是从没路的地方践踏出来的，从只有荆棘的地方开辟出来的。’</strong></p><h4 id="彷徨"><a class="header-anchor" href="#彷徨"></a>彷徨</h4><h5 id="伤逝"><a class="header-anchor" href="#伤逝"></a>伤逝</h5><p><strong>‘但是，这却更虚空于新的生路；现在所有的只是初春的夜，竟还是那么长。我活着，我总得向着新的生路跨出去，那第一步，——却不过是写下我的悔恨和悲哀，为子君，为自己。’</strong></p><h5 id="弟兄"><a class="header-anchor" href="#弟兄"></a>弟兄</h5><p><strong>‘“不！”他不放手，“我来办。”<br>月生也就不再去抢着办了。沛君便十分安心似的沉静地走到自己的桌前，看着呈文，一面伸手去揭开了绿锈斑斓的墨盒盖。’</strong></p><h4 id="朝花夕拾"><a class="header-anchor" href="#朝花夕拾"></a>朝花夕拾</h4><p><strong>‘前天，已将《野草》编定了，这回便轮到陆续载在《莽原》上的《旧事重提》，我还替他改了一个名称：《朝花夕拾》。’</strong><br>很多我们熟知的文章，记录着迅哥儿的过去……</p><h4 id="故事新编"><a class="header-anchor" href="#故事新编"></a>故事新编</h4><p>非常有趣，建议去看看。<br>嫦娥为何奔月？是因为受不了后裔天天只能给他做乌鸦炸酱面…… 哈哈哈</p><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><p>不知道是不是受了读书时的影响，迅哥儿的文章，但凡一看，有些异样的语句，就觉得他在讽刺着什么。但有些他讽刺的文章，写的又深刻形象，比如《牺牲谟》。<br>总的来说，目前只看了前两卷，还是非常值得一读。个人感觉，迅哥儿对于人物形象塑造能力极其强，几句话，几个字，一个人就活了。而讽刺现象，一类人，你马上能够真真切切的在现实中看到，就是某个人的某个嘴脸。<br>很多文章，还是需要细细读细细品，多读几次。<br>后面空了继续看后面的……</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《财富自由之路》粗读</title>
      <link href="/2021/03/09/%E3%80%8A%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF%E3%80%8B%E7%B2%97%E8%AF%BB/"/>
      <url>/2021/03/09/%E3%80%8A%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF%E3%80%8B%E7%B2%97%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>钱钱钱(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>一共三册。<br>主题： 讲述怎样一步一步的实现财富自由<br>类别：经济学-&gt;实用性-&gt;投资理财+鸡汤<br>概要：从金钱管理，投资理财，自我成长，金钱价值观等方面给出建议，让你更快的实现财务自由。</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>作者核心思想：教会你如何规划自己的财产，制定计划，以实现财务自由。</p><p>而我的想法非常明确，赚钱。</p><h2 id="主要观点"><a class="header-anchor" href="#主要观点"></a>主要观点</h2><h3 id="7年内赚到你第一个1000万"><a class="header-anchor" href="#7年内赚到你第一个1000万"></a>7年内赚到你第一个1000万</h3><p>讲述一条从0开始到财富自由的路，给出大概的轮廓和基础理念。</p><ol><li>财富不会从天而降——除非你指望着中彩票头奖。但每个人可以做到的是：做出正确的决定，制订一个长期计划，使自己获得财务保障，甚至创造出一份财富，以此来改善自己的生活质量。</li><li>变富的途径很多，本书中为您详述其中一种，它由以下4种策略组成：<ol><li>储蓄一定比例的金钱。</li><li>使用储蓄资金进行投资。</li><li>提高自己的收入。</li><li>从每次加薪中提取一定比例进行储蓄。</li></ol></li><li>仅仅闭门读书不会让你变得富有。更多地运用这本书，使这本书的知识成为你知识体系的一部分，你才能变得富有。</li><li>首先进行自我分析，分析完成后，在进行计划制定。</li><li>我们在等谁？在等什么？是上帝还是命运？“所有的傻瓜都生活在希望和等待之中。”</li><li>将困难当作成长的机会</li><li>扩大你的个人范畴</li><li>变化的5个层次：<ol><li>你意识到自己对现状感到不满意</li><li>期待的结果没有出现，你意识到，仅仅只是采取行动还远远不够。</li><li>学到的技巧对你起到了一定的帮助</li><li>用不同的方向看待问题和世界</li><li>通过改变对自身的认知，我们可以带来巨大的变化。</li></ol></li><li>成功日记和自信</li><li>没有哪个奇迹的发生不需要冒险</li><li>好运不是一种不通过努力，光靠期待就可以获得的东西。</li><li>储存资本+识别机会+果断地做出决定并采取行动 -&gt; 好运</li><li>大多数人都高估了自己1年内能做到的事情，也低估了自己10年内能做到的事情。</li><li>清晰明确的目标，可量化的目标，并且随时回顾目标，让其能够不断在你脑海里生根。</li><li>穷和富裕在于每次细小的选择。或者说，富人思想，要么暴富，要么难受死。</li><li>教练法则。让一个教练来督促你成长，少走弯路。</li><li>定下一个大目标，即使他看起来不可能完成。</li><li>大力发展自己的优势，而不是着重弥补自己的劣势。</li><li>当你为自己设立了极限，你就会设法达到你的极限。你不仅仅要对自己的失败承担责任，也要对你的成功承担责任。</li><li>你如果认为成功是不可重复的，就失去了提升自我价值的机会。</li><li>一个付出110％努力，主动摒弃所有借口的人，势必取得成功。</li><li>明确你的信念，并让它变得更加深刻。比如我必须要改变。</li><li>你需要建立一个能让自己变得富有的信念，并且加固它。</li><li>不要陷入债务危机。</li><li>增加收入方式：<ol><li>展示和提升你的强项，和价值。</li><li>安排的事情立马去做，不要有拖延症。</li><li>让自己称为专家。</li></ol></li><li>储蓄是必要的。</li><li>影响收入的版块：<ol><li>能力</li><li>精力</li><li>知名度/影响力</li><li>自我评价</li><li>创意</li></ol></li><li>收入来源：<ol><li>产品价值</li><li>知识价值</li><li>服务价值</li><li>创意价值</li></ol></li><li>当你可以靠自己的资产生活，而不是工作，才能称为富有。</li><li>学会寻找新的收入。</li><li>市场波动一直存在，要考虑到大危机的可能性。</li><li>股民需要遵循的原则:<ol><li>区分投资和投机，投资是可以在固定的一段时间获得收益，投机是卖出时获得收益。</li><li>区分债务和投资，债务是花钱，投资是赚钱。</li><li>确定你的资产类型：<ol><li>货币资产</li><li>有型资产</li><li>赌博</li></ol></li><li>有型资产完胜货币资产。</li><li>必须承担风险</li><li>分散投资</li></ol></li><li>投资三部曲：<ol><li>财务保障，是指发生意外情况(生病，失业)能帮助你的财产。这部分钱用于定期，或者现金存放。</li><li>财务安全，是指产生的利息能够够你的日常开支。这部分钱按照4:4:2(低:适中:中风险)的比例用于投资。</li><li>财务自由，除了上述两笔钱，剩下的钱，用于较高风险投资，一般比例5:5(中:高风险)</li></ol></li><li>近朱者赤</li><li>想尽办法获得一个优秀的导师。记住如何使他人收益。</li><li>要拥有感激之心，付出一定的金钱。</li><li>知识只有运用起来才是力量。</li><li>建立一个团队，让你的富足持续下去。</li></ol><h3 id="3年内让你的个人资产翻一翻"><a class="header-anchor" href="#3年内让你的个人资产翻一翻"></a>3年内让你的个人资产翻一翻</h3><p>学习如何显著提高自己的收入——在并不需要延长工作时间或者增加工作强度。</p><ol><li>仓鼠之轮：做为一个赚钱工具，不停的赚的更多，而又花的更多，却不思考自身的意义和价值，并且无法停歇。</li><li>尝试开启自己的第二职业，第二职业就是能够带来很多收益(至少能够做好了带来很多收益)</li><li>思想决定一切，穷人常常不知道自己想要什么，中产阶级常常是负担不起，富裕阶级常常想怎么能负担起。</li><li>沉静在做自己喜爱事务之中，某个瞬间感觉到了永恒，这就会“心流”。</li><li>要知道自己真正想要什么。</li><li>列出自己的爱好，列出自己的能力，找到这些交集，交集越多的地方，越是适合你的工作。</li><li>找工作的方法：<ol><li>熟人内推</li><li>找到感兴趣的公司，针对性的制作简历。</li></ol></li><li>专家途径：<ol><li>追求卓越</li><li>与众不同</li><li>成为第一人</li><li>如果不能成为第一人，就创造新的定位。</li><li>宁可精致，不要宽泛。</li><li>选择基本需求，不要搞套路。顺应时代</li><li>选择一个目标群体。</li><li>为他人解决一个问题。</li><li>宣传自己和自己的产品。</li><li>给自己的产品或服务定价。</li></ol></li><li>idea的产生：<ol><li>你想解决一个问题，并为之思考。</li><li>调研别人的处理方式，考虑其优点和不足</li><li>结合自己的想法慢慢勾勒出一个方案</li><li>灵光乍现</li></ol></li><li>明白自己的定位和自己擅长的东西，如何变成与众不同的产品以及能解决实际问题。</li><li>企业家的特质：<ol><li>企业家都敢于冒险</li><li>能经受住失望</li><li>渴望权利</li><li>更多的自信心</li><li>善于控制资金</li><li>榜样作用</li><li>好胜心</li><li>求知欲</li><li>经营直觉</li></ol></li><li>销售行业可以锻炼一些企业家的特性</li><li>企业家的6项基本任务概要：<ol><li>寻找优秀的同事与合伙人。</li><li>监督盈利以及创建机制。</li><li>对您的公司进行创新。</li><li>从一切多余的事务中解脱出来。</li><li>保持您的宏伟蓝图及其意义永远充满活力。</li><li>想出一条退出的策略。</li></ol></li><li>好的机制就是领导的依赖性越小。</li></ol><h3 id="为你量身定制的投资组合"><a class="header-anchor" href="#为你量身定制的投资组合"></a>为你量身定制的投资组合</h3><p>更加安全的高效的提升自己的资产，前提得是你有资金来投资。<br>1.</p><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><p>财富自由之路有三本，我也是粗读了前两本，也是分为三个阶段，财务保障-&gt;财务安全-&gt;财务自由。从最开始的如何赚钱到后面的如何理财，到如何定位，工作，当投资人等等……<br>总的来说，它大概的给你指出了一条通往财富自由的路子，而其中80%的内容或许你都知道，更加类似于鸡汤一样的东西。对于我而言，最大的鸡汤收获莫过于一句“你在等什么？上帝还是命运？”，同样其中也不乏一些理财观念，而我最赞同的就是对金钱的划分：保障资金，安全资金和自由资金。<br>总的来说，粗读还是有一定收获的，至于第三本，我暂时没有看了，因为没到哪个地步，也没了兴趣，毕竟现在还在实现财务保障阶段。至于进行分析阅读和精读，感觉没啥必要，没有那么多高深的知识，一看你我都明白，重点在行动。</p><h3 id="相关"><a class="header-anchor" href="#相关"></a>相关</h3><p>这本书和小狗钱钱的理念相似，但是我更喜欢那本书，更有趣，更生动，而又较为透彻的传输了理财理念。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《nginx入门到精通》读书笔记</title>
      <link href="/2021/03/09/%E3%80%8Anginx%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/03/09/%E3%80%8Anginx%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>从实践入门介绍nginx(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><a href="http://tengine.taobao.org/book/index.html" target="_blank" rel="noopener">在线阅读</a><br>主题： nginx模块开发和原理解析<br>类别：计算机-&gt;实用性+理论性论述书-&gt;nginx<br>概要：从模块开发了解nginx的使用以及nginx整体结构。从源码原理解析了解nginx底层设计和各种优化操作。<br>这个玩意儿太监了，没有写完，很多东西都只有大纲。</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>作者想通过文章帮助人们了解nginx的模块开发，和其内部实现原理。<br>而我也想进行nginx源码学习，了解其中的实现原理和架构，以及一些实现亮点。<br>为了更深入学习，需要将nginx源码和书结合起来看，虽然书中选择了1.2的版本，为了降低难度，我选择了<a href="http://nginx.org/download/nginx-1.0.15.tar.gz" target="_blank" rel="noopener">nginx-1.0.15</a>版本。</p><h2 id="主旨"><a class="header-anchor" href="#主旨"></a>主旨</h2><h3 id="文章的核心内容"><a class="header-anchor" href="#文章的核心内容"></a>文章的核心内容</h3><h4 id="核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。"><a class="header-anchor" href="#核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。"></a>核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。</h4><h3 id="整本书的架构"><a class="header-anchor" href="#整本书的架构"></a>整本书的架构</h3><h4 id="作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。"><a class="header-anchor" href="#作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。"></a>作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。</h4><h3 id="问题处理"><a class="header-anchor" href="#问题处理"></a>问题处理</h3><h4 id="作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。"><a class="header-anchor" href="#作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。"></a>作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。</h4><h2 id="章节"><a class="header-anchor" href="#章节"></a>章节</h2><h3 id="nginx模块开发"><a class="header-anchor" href="#nginx模块开发"></a>nginx模块开发</h3><p>该模块主要进行nginx整体架构的初步介绍，并指导进行相关的实践操作，进行相关模块开发。</p><h4 id="nginx架构"><a class="header-anchor" href="#nginx架构"></a>nginx架构</h4><p>先上一幅nginx架构图：<br><img src="/2021/03/09/《nginx入门到精通》读书笔记/nginx%E6%9E%B6%E6%9E%84.png" alt><br>这幅图很明显的说明了nginx的大架构，其中：<br>master：负责接收外部控制信号，管理work进程<br>worker：负责处理请求连接，每个worker之间平等竞争连接。<br>优势：</p><ol><li>work使用进程，而不是线程(虽然也支持线程模式)，是为了最大限度避免线程切换开销，并且work数量一般和cpu数量相同，减少cpu上下文切换。</li><li>事件处理采用了异步非阻塞形式，使进程处理请求时不会阻塞。<br>而通常web服务器事件分为三类：网络事件，信号(信号事件如何处理???)和定时器。而nginx的这三个事件处理方式可以用一段伪代码表示：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//执行事件</span></span><br><span class="line">    <span class="keyword">for</span> t in run_tasks:</span><br><span class="line">        t.handler();</span><br><span class="line">    update_time(&amp;now);</span><br><span class="line">    timeout = ETERNITY;</span><br><span class="line">    <span class="comment">//处理定时器</span></span><br><span class="line">    <span class="keyword">for</span> t in wait_tasks: <span class="comment">/* 已经排序，依次取出超时最小定时器 */</span></span><br><span class="line">        <span class="keyword">if</span> (t.time &lt;= now) &#123;</span><br><span class="line">            t.timeout_handler();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = t.time - now;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//网络事件触发，或者定时器到期</span></span><br><span class="line">    nevents = poll_function(events, timeout);</span><br><span class="line">    <span class="keyword">for</span> i in nevents:</span><br><span class="line">        task t;</span><br><span class="line">        <span class="keyword">if</span> (events[i].type == READ) &#123;</span><br><span class="line">            t.handler = read_handler;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* events[i].type == WRITE */</span></span><br><span class="line">            t.handler = write_handler;</span><br><span class="line">        &#125;</span><br><span class="line">        run_tasks_add(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nginx基础概念"><a class="header-anchor" href="#nginx基础概念"></a>nginx基础概念</h4><p><strong>connection</strong>：对tcp链接的封装，其中包括socket，读写事件。<br>connection生命周期：master读取配置文件，建立监听并获得fd-&gt;fork子进程，获得该fd-&gt;竞争获取链接，并建立链接-&gt;客户端或者服务端完成时间后断开。<br>链接竞争机制伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处的设计是为了避免某些进程已经没有剩余链接却还能竞争到锁，</span></span><br><span class="line"><span class="comment">//而有剩余链接的进程却竞争不到。</span></span><br><span class="line"><span class="comment">//当前进程总连接数/8 - 当前剩余连接数</span></span><br><span class="line">ngx_accept_disabled = ngx_cycle-&gt;connection_n / <span class="number">8</span></span><br><span class="line">    - ngx_cycle-&gt;free_connection_n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ngx_accept_disabled &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    ngx_accept_disabled--; <span class="comment">//(有必要???每次该值都会被上面覆盖)</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//尝试竞争锁</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">        flags |= NGX_POST_EVENTS;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer == NGX_TIMER_INFINITE</span><br><span class="line">                || timer &gt; ngx_accept_mutex_delay)</span><br><span class="line">        &#123;</span><br><span class="line">            timer = ngx_accept_mutex_delay;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>request</strong>：<br>很明显，这就是表示一个http的请求，其生命周期如下图(细节code???)：<br><img src="/2021/03/09/《nginx入门到精通》读书笔记/request%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt></p><p><strong>keepalive</strong>：<br>链接跟踪，在接收到第一个http请求后，不断开连接，如果一定时间内没有接到该客户端的后续请求再断开连接。对于大多数网页访问来说，keepalive是很有必要的。</p><p><strong>pipeline</strong>：<br>同时可以接收两个请求，即当客户端不用等到第一个请求完再发第二个请求。有点类似http2的处理方式。</p><p><strong>lingering_close</strong>：<br>在出现服务端错误的情况下，服务端返回错误信息，write到tcp的write buffer里，然后直接close。如果这个时候该链接的read buffer里还有数据，则会直接返回reset，丢弃write buffer里的内容。如果没有，则等write buffer里数据发送了再close。而lingering_close的作用，就是在出错write数据后，等一段时间再close，这段时间内仍然读取read buffer里的数据扔掉即可。</p><h4 id="基础数据结构"><a class="header-anchor" href="#基础数据结构"></a>基础数据结构</h4><p><strong>ngx_str_t</strong>：具体参考源码，并且自己进行相关调用。<br><strong>ngx_pool_t</strong>:</p><h3 id="nginx原理"><a class="header-anchor" href="#nginx原理"></a>nginx原理</h3><p>从架构深入到内部实现，讲解nginx源码的各个模块的关键设计。需要配合源码来进行阅读。</p><h4 id><a class="header-anchor" href="#"></a></h4><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><h3 id="所得"><a class="header-anchor" href="#所得"></a>所得</h3><h4 id="作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？"><a class="header-anchor" href="#作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？"></a>作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？</h4><h3 id="所想"><a class="header-anchor" href="#所想"></a>所想</h3><h4 id="看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。"><a class="header-anchor" href="#看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。"></a>看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。</h4><h3 id="相关"><a class="header-anchor" href="#相关"></a>相关</h3><h4 id="可以列出相关的看过的书籍，或者问题参考链接网页一类的。"><a class="header-anchor" href="#可以列出相关的看过的书籍，或者问题参考链接网页一类的。"></a>可以列出相关的看过的书籍，或者问题参考链接网页一类的。</h4>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读笔记框架</title>
      <link href="/2021/03/08/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%A1%86%E6%9E%B6/"/>
      <url>/2021/03/08/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>好的笔记能体现出一本书的核心思想，能表达自己的心得体会，能帮助你快速回忆巩固。(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em>不同的书有不同的笔记方法，特定框架能更快速的明确笔记目的——读《如何阅读一本书》后所得</em></p><a id="more"></a><h2 id="检视阅读"><a class="header-anchor" href="#检视阅读"></a>检视阅读</h2><p>检视阅读的主旨在了解书的架构，核心内容。所以，大多数时候，你都只会得到一个概念性的东西，自己了解即可。至于笔记，更适合于名言名句那种记录方式，记录下表达核心思想的语句。<br><strong>如果要有笔记，也需要那么几个部分</strong>：</p><ol><li><p>书的概要</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 书名</span><br><span class="line">## 前言</span><br><span class="line">### 书的主题和分类</span><br><span class="line">### 整本书的核心内容，一到两句话</span><br><span class="line">### 作者写这本书的目的，或者他想解决什么问题？</span><br><span class="line">### 你期望能从书中获得什么</span><br></pre></td></tr></table></figure></li><li><p>列出文章中一些核心的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 主旨</span><br><span class="line">### 观点1</span><br><span class="line">### 观点2</span><br><span class="line">### 观点3</span><br><span class="line">....(不一定要全，看到了就记下)</span><br></pre></td></tr></table></figure></li><li><p>总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 结语</span><br><span class="line">###  延展</span><br><span class="line">#### 作者所提出的问题，是否就是你真正想问的问题？是否有必要进行分析阅读？理由？</span><br><span class="line">###  相关</span><br><span class="line">#### 可以列出相关的看过的书籍，或者问题参考链接网页一类的。</span><br></pre></td></tr></table></figure></li></ol><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 《nginx入门到精通》读书笔记</span><br><span class="line">date: 2021-03-09 10:29:26</span><br><span class="line">categories: 笔记</span><br><span class="line">tags: [nginx]</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">从实践入门介绍nginx(•̀⌄•́)</span><br><span class="line">　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</span><br><span class="line">* * *</span><br><span class="line">主题： nginx模块开发和原理解析</span><br><span class="line">类别：计算机-&gt;实用性+理论性论述书-&gt;nginx</span><br><span class="line">概要：从模块开发了解nginx的使用以及nginx整体结构。从源码原理解析了解nginx底层设计和各种优化操作。</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line">## 前言</span><br><span class="line">作者想通过文章帮助人们了解nginx的模块开发，和其内部实现原理。</span><br><span class="line">而我也想进行nginx源码学习，了解其中的实现原理和架构，以及一些实现亮点。</span><br><span class="line"></span><br><span class="line">## 主要观点</span><br><span class="line">### 观点1</span><br><span class="line">### 观点2</span><br><span class="line">### 观点3</span><br><span class="line"></span><br><span class="line">## 结语</span><br><span class="line">###  延展</span><br><span class="line">#### 作者所提出的问题，是否就是你真正想问的问题？是否有必要进行分析阅读？理由？</span><br><span class="line">###  相关</span><br><span class="line">#### 可以列出相关的看过的书籍，或者问题参考链接网页一类的。</span><br></pre></td></tr></table></figure><h2 id="分析阅读"><a class="header-anchor" href="#分析阅读"></a>分析阅读</h2><p>分析阅读的笔记结构，主要以结构笔记为主(记录全书的整体架构)，概念笔记(记录一个概念或观点)为辅。<br><strong>分析阅读的通用方法</strong>：</p><ol><li><p>进行一遍检视阅读，并获得以下信息：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 书名</span><br><span class="line">## 前言</span><br><span class="line">### 书的主题和分类</span><br><span class="line">### 整本书的核心内容，一到两句话</span><br><span class="line">### 作者写这本书的目的，或者他想解决什么问题？</span><br><span class="line">### 你期望能从书中获得什么</span><br></pre></td></tr></table></figure></li><li><p>开始进行分析阅读，并在阅读过程中完成以下笔记：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 章节</span><br><span class="line">### 第一章(章节内容名称，可以和书中相同，也可以自己拟定)</span><br><span class="line">#### 核心内容，主要观点</span><br><span class="line">### 第二章</span><br><span class="line">#### 核心内容，主要观点</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>分析阅读过程中完成以下笔记：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## 主旨</span><br><span class="line">###  文章的核心内容</span><br><span class="line">#### 核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。</span><br><span class="line">###  整本书的架构</span><br><span class="line">#### 作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。</span><br><span class="line">###  问题处理</span><br><span class="line">#### 作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。</span><br></pre></td></tr></table></figure></li><li><p>认真完成上述过程后：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## 结语</span><br><span class="line">###  所得</span><br><span class="line">#### 作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？</span><br><span class="line">###  所想</span><br><span class="line">#### 看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。</span><br><span class="line">###  相关</span><br><span class="line">#### 可以列出相关的看过的书籍，或者问题参考链接网页一类的。</span><br></pre></td></tr></table></figure></li></ol><p><strong>整体结构</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 书名</span><br><span class="line">## 前言</span><br><span class="line">### 书的主题和分类</span><br><span class="line">### 整本书的核心内容，一到两句话</span><br><span class="line">### 作者写这本书的目的，或者他想解决什么问题？</span><br><span class="line">### 你期望能从书中获得什么</span><br><span class="line"></span><br><span class="line">## 主旨</span><br><span class="line">###  文章的核心内容</span><br><span class="line">#### 核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。</span><br><span class="line">###  整本书的架构</span><br><span class="line">#### 作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。</span><br><span class="line">###  问题处理</span><br><span class="line">#### 作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。</span><br><span class="line"></span><br><span class="line">## 章节</span><br><span class="line">### 第一章(章节内容名称，可以和书中相同，也可以自己拟定)</span><br><span class="line">#### 核心内容，主要观点</span><br><span class="line">### 第二章</span><br><span class="line">#### 核心内容，主要观点</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">## 结语</span><br><span class="line">###  所得</span><br><span class="line">#### 作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？</span><br><span class="line">###  所想</span><br><span class="line">#### 看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。</span><br><span class="line">###  相关</span><br><span class="line">#### 可以列出相关的看过的书籍，或者问题参考链接网页一类的。</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 《nginx入门到精通》读书笔记</span><br><span class="line">date: 2021-03-09 10:29:26</span><br><span class="line">categories: 笔记</span><br><span class="line">tags: [nginx]</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">从实践入门介绍nginx(•̀⌄•́)</span><br><span class="line">　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</span><br><span class="line">* * *</span><br><span class="line">主题： nginx模块开发和原理解析</span><br><span class="line">类别：计算机-&gt;实用性+理论性论述书-&gt;nginx</span><br><span class="line">概要：从模块开发了解nginx的使用以及nginx整体结构。从源码原理解析了解nginx底层设计和各种优化操作。</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line">## 前言</span><br><span class="line">作者想通过文章帮助人们了解nginx的模块开发，和其内部实现原理。</span><br><span class="line">而我也想进行nginx源码学习，了解其中的实现原理和架构，以及一些实现亮点。</span><br><span class="line"></span><br><span class="line">## 主旨</span><br><span class="line">###  文章的核心内容</span><br><span class="line">#### 核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。</span><br><span class="line">###  整本书的架构</span><br><span class="line">#### 作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。</span><br><span class="line">###  问题处理</span><br><span class="line">#### 作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。</span><br><span class="line"></span><br><span class="line">## 章节</span><br><span class="line">### nginx模块开发</span><br><span class="line">该模块主要进行nginx整体架构的初步介绍，并指导进行相关的实践操作，进行相关模块开发。</span><br><span class="line">#### </span><br><span class="line">### nginx原理</span><br><span class="line">从架构深入到内部实现，讲解nginx源码的各个模块的关键设计。需要配合源码来进行阅读。</span><br><span class="line">#### </span><br><span class="line"></span><br><span class="line">## 结语</span><br><span class="line">###  所得</span><br><span class="line">#### 作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？</span><br><span class="line">###  所想</span><br><span class="line">#### 看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。</span><br><span class="line">###  相关</span><br><span class="line">#### 可以列出相关的看过的书籍，或者问题参考链接网页一类的。</span><br></pre></td></tr></table></figure><h2 id="主题阅读"><a class="header-anchor" href="#主题阅读"></a>主题阅读</h2><p>主题阅读笔记以辩证笔记为主，结构笔记为辅。通常是围绕一个主题，引出不同作者的观点，整理各个作者之间的观点联系和区别。加上结构上整理，列出主题架构。可以说，主题笔记写好了相当于一本新的论述性书籍。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《如何读一本书》读书笔记</title>
      <link href="/2021/02/16/%E3%80%8A%E5%A6%82%E4%BD%95%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/02/16/%E3%80%8A%E5%A6%82%E4%BD%95%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>或许看了这本书后才能懂得什么叫做真正的阅读(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em>一些阅读技巧和方法，能够帮助你更快的通过阅读达到你想要的目的</em></p><a id="more"></a><p>PS：或许本书看完，应该总结一下如何写读书笔记。初步理解，读书笔记应该类似想一个纲要一般的东西，能够概况书中罗列的重点，表明整个书写的逻辑，看完后的心得体会，扩展和延伸。满足这几点，或许才是一个合格的读书笔记。<br>本笔记尝试写出一个读书笔记的模板，用于以后指导记录读书笔记。同样要理解到读书笔记真正存在的含义：<strong>帮助你快速理解(没看过的人)或回忆(看过的人)一本书的核心内容</strong></p><h1>序</h1><p>阅读的核心在于<strong>主动</strong>，意味着你越主动，收获越多。<br><em>写书的介绍和纲要</em></p><h1>笔记</h1><h2 id="阅读目的"><a class="header-anchor" href="#阅读目的"></a>阅读目的</h2><ul><li>消遣阅读。开心就好。小说</li><li>获得咨询。从文章或书中获得新消息，不用提升自己的思维理解能力。字典或报纸</li><li><strong>学习研究</strong>。从书中获得新的知识和锻炼思维。分为自我型学习(自学)和指导型学习(有老师教)。各种教科书。 <em>这也是本书介绍的重点</em></li></ul><h2 id="主动阅读"><a class="header-anchor" href="#主动阅读"></a>主动阅读</h2><p>任何阅读都需要主动，昏昏沉沉的阅读无异于浪费时间。<br>任何一种超越基础阅读的阅读层次，都需要提出问题并且找到答案。尝试在阅读的过程中养成提出问题的习惯，并且尝试在书中寻找。只有真正熟读一本书，并且能够与书作者“相互交流”，这本书才是真正属于你。<br>一个阅读者需要提出的四个基本问题：</p><ol><li>整体来说，这本书到底在谈些什么？ 文章主题。</li><li>作者细部说了什么，怎么说的？ 文章观点。</li><li>这本书说得有道理吗？</li><li>这本书和你有什么关系？你为何要读它？读它有没有意义？</li></ol><p>阅读完一本书以后，尝试编写书此书的大纲。<br>记录笔记有助于你理解作者的思维以及引发自己的思考。<br>养成一个良好的阅读习惯，不止是知道何为良好阅读，而是要实际实践，并慢慢的把良好阅读形成习惯。</p><h3 id="三种做笔记的方法"><a class="header-anchor" href="#三种做笔记的方法"></a>三种做笔记的方法</h3><p>在检视阅读中所要记录的是：</p><ol><li>这是怎样的一本书？</li><li>整本书在谈论什么？</li><li>作者是在借用怎样的框架，来发展他对这个主体的理解？<br>这种笔记重在记录全书的整体架构，而不是细节，我们称它为<strong>结构笔记</strong></li></ol><p>还有一种笔记，在分析阅读时常常使用，它用于记录一个概念，也可以说是作者的一个观点，当然这个观点可能不止这个作者阐述过。因此笔记中也可以包含其他书的相关联的观点。我们称这种笔记叫<strong>概念笔记</strong><br>还有一种更高级的笔记——<strong>辩证笔记</strong>。 通常这种笔记是围绕一个场景进行讨论，而这场讨论是由多个作者参与。往往辩证笔记最好进行单独记录，将辩证笔记加上概念的结构就可以形成一个主题。</p><h2 id="阅读层次"><a class="header-anchor" href="#阅读层次"></a>阅读层次</h2><p>阅读一共分为四个层次：</p><ol><li>基础阅读。意味着你能够认识书中的文字。</li><li>检视阅读。短时间内掌握一本书或者一段文字的核心内容。短时间意味着你不能完全阅读这本书或者这段文字。</li><li>分析阅读。意味着你完全阅读一本书，并且能够完全理解作者想要表达的所有观点，并且能够提出系统性的问题。当然这种阅读方式很消耗时间和精力，并且只有少数书适合这么阅读。</li><li>主题阅读。这种阅读方式往往不只阅读一本书，而是同一主题的许多书，把这些书进行内容观点的比较、和总结，得到自己的理解和观点。当你研究一个主题时就需要使用主题阅读。</li></ol><h2 id="基础阅读"><a class="header-anchor" href="#基础阅读"></a>基础阅读</h2><p>基础阅读的阶段：</p><ol><li>准备阶段：身体准备，能够有几本听说读写的能力。智力准备，能够有良好的认知和记忆力。</li><li>识字阶段：能够认识字符代表的含义包括字和词，并且能掌握基本发音。</li><li>字词学习：能够通过已知含义的上下文来理解新的未知词汇。</li><li>精炼阶段：熟练使用和精炼上述三种阶段</li></ol><h2 id="检视阅读"><a class="header-anchor" href="#检视阅读"></a>检视阅读</h2><p>检视阅读的方法：</p><ol><li><strong>有系统的略读或者粗读</strong>：<ol><li>先看书名页，然后如果有序就先看序。</li><li>研究目录页，对这本书的基本架构做概括性的理解。</li><li>如果书中附有索引，也要检阅一下——大多数论说类的书籍都会有索引。</li><li>如果那是本包着书衣的新书，不妨读一下出版者的介绍。大多数都不是只会瞎吹，如果只是瞎吹，估计你也能很快发现，也能间接证明这本书的价值。</li><li>从你对一本书的目录很概略，甚至有点模糊的印象当中，开始挑几个看来跟主题息息相关的篇章来看。如果这些篇章在开头或结尾有摘要说明（很多会有），就要仔细地阅读这些说明。</li><li>最后一步，把书打开来，东翻翻西翻翻，念个一两段．有时候连续读几页，但不要太多。就用这样的方法把全书翻过一遍，随时寻找主要论点的讯号，留意主题的基本脉动。书的最后几页很重要，大多包含了书的总结，记得要看。</li></ol></li><li><strong>粗浅的阅读</strong>：<ol><li>注意你能理解的部分，不要为一些没法立即了解的东西而停顿。继续读下去，直到全书读完。</li><li>阅读的速度根据书的内容而定，有些时候需要快速略读，有些时候，需要稍微慢点，以便能够初步理解文章真实含义。</li><li>阅读的时候不要习惯性的逗留和倒退阅读，除非它比较重要。</li><li>阅读一本书的时候，阅读速度应当根据内容而定，当你不知道哪些该快，哪些该慢时，先进行一遍略读是非常有必要的。</li></ol></li></ol><h2 id="分析阅读"><a class="header-anchor" href="#分析阅读"></a>分析阅读</h2><p>分析阅读是耗时消耗精力的，往往只有知识型的书才适合或者值得我们这样去阅读。因此在使用分析阅读的时候，你一定知道了这本书的价值，它里面一定有知识是你所求的。如果不知道，可以先进行检视阅读。</p><h3 id="书籍的分类"><a class="header-anchor" href="#书籍的分类"></a>书籍的分类</h3><p>首先，你先明确这本书是消遣类型还是咨询类型还是知识类型。如果是知识类型，我们可能还需要进行以下划分：<br><strong>实用性和理论性作品</strong><br>实用性作品往往是告诉你如何去做某一件事，理论性作品则是说明某一件事是为何。当然有些时候并不能做明确的划分，但是我们在检视阅读的时候要尝试着分析，这会让我们更加明白这本书对我们的作用，以及我们需要花费多少精力去阅读它。<br><strong>理论性作品分类</strong><br>理论性作品也分为很多类别：科学、哲学、医学、文学等，首先你能区分这些类别，然后再进行细节划分，比如自然科学包括数学，物理，化学等，由此一层层的细分。（了解书的分类定位很重要，这能更加明确你想学知识的范围以及定位对你有帮助的书。如果你无法进行细分，则需要先学习这些分类的差别）</p><h3 id="透视一本书"><a class="header-anchor" href="#透视一本书"></a>透视一本书</h3><p>为一个分析阅读的读者，你的责任就是要找出一本书的骨架。而找出骨架的方法：</p><ol><li>使用一个单一的句子，或最多几句话（一小段文字）来叙述整本书的内容。(往往书名，前言，目录都会包含很多信息)</li><li>将书中重要篇章列举出来，说明它们如何按照顺序组成一个整体的架构。(比如你可以将书分为几个章节，每个章节又分为几个小节，每个小节又包含几个重点。列出一个架构的树状图)</li></ol><h3 id="分析阅读的阶段"><a class="header-anchor" href="#分析阅读的阶段"></a>分析阅读的阶段</h3><p><strong>第一阶段：认识书的架构</strong><br>其中包含的四个规则（你可以先进行一次检视阅读，并完成）：</p><ol><li>依照书本的种类与主题作分类。</li><li>用最简短的句子说出整本书在谈些什么。</li><li>按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也一一列出。</li><li>找出作者在问的问题，或作者想要解决的问题。</li></ol><p><strong>第二阶段：诠释内容与讯息</strong></p><ol><li>找出重要单字，透过它们与作者达成共识。(其一要找出关键字&lt;一些着重强调的或者专业的词汇&gt;，其二要理解关键字&lt;要利用上下文自己已经了解的所有字句，来推敲出你所不了解的那个字的意义&gt;，与作者达成共识)</li><li>找出作者的主旨，即作者支持什么反对什么。(当你能使用不同的文字来形容同一个主旨，证明你理解了这个主旨。或者举例说明主旨的现象也能达到同样的效果。)</li><li>从相关文句的关联中，设法架构出一本书的基本论述(用于支持主旨的依据，分为归纳和演绎)。论述的开端往往来源于公理或者假设。</li><li>找出作者解决了哪些问题，哪些又未解决。未解决的问题中，哪些作者认为自己无法解决。</li></ol><p><strong>第三阶段：公正的评断一本书</strong></p><ol><li>在进行评断之前，你一定很好的完成了一二阶段，并做了深入的思考。</li><li>你可以对一本书的观点表示赞同，不赞同，或者暂缓评论(有种例外就是你没有读懂，并且不是由于你知识局限，而是书本身的问题难以理解)。但一定要理性并且列出相应的理由。避免进入不理性争端。</li><li>重知识与个人观点的不同，在作任何评断之前，都要找出理论基础。<ol><li>读者提出“我了解，但是我不同意”可以从以下四个方面来说明：<ol><li>你的知识不足。</li><li>你的知识有错误。</li><li>你不合逻辑—你的推论无法令人信服。</li><li>你的分析不够完整。</li></ol></li></ol></li></ol><p>辅助阅读<br>当你阅读一本书时，可以借助外在力量来帮助自己理解这本书。辅助来源可以有四个方面：</p><ol><li>相关经验</li><li>其他的书，读同一作者的书，按照时间顺序来读或许更加容易理解。</li><li>导论与摘要，阅读导读的时候，最好在读完一本书过后，因为导读是别人的理解，或多或少的会影响你对书的理解。而摘要在你进行主题阅读的时候则非常有帮助。</li><li>工具书。使用工具书的前提：必须知道你想要找的是什么，在哪一种工具书中能找到这样的东西。</li></ol><h3 id="阅读不同类型的书"><a class="header-anchor" href="#阅读不同类型的书"></a>阅读不同类型的书</h3><h4 id="论说性作品"><a class="header-anchor" href="#论说性作品"></a>论说性作品</h4><h5 id="实用性-都是在帮助你解决问题-："><a class="header-anchor" href="#实用性-都是在帮助你解决问题-："></a>实用性(都是在帮助你解决问题)：</h5><p><strong>实用性书籍分类：</strong></p><ol><li>说明规则。如这本书，以及一些烹饪书，维修书</li><li>阐述形成规则的原理。比如经济学，政治学</li></ol><p><strong>如何阅读实用性书籍：</strong><br>提出两个主要问题：</p><ol><li>作者的目的是什么？</li><li>他建议用什么方法达到这个目的？<br>阅读实用性书籍：</li><li>这本书是在谈些什么？</li><li>这本书的主旨与论述</li><li>书中的内容真实吗？</li><li>和你有多少关系？</li></ol><h5 id="理论性-都是在解决自己提出的问题-："><a class="header-anchor" href="#理论性-都是在解决自己提出的问题-："></a>理论性(都是在解决自己提出的问题)：</h5><h4 id="如何阅读想象文学："><a class="header-anchor" href="#如何阅读想象文学："></a>如何阅读想象文学：</h4><p>即小说，戏剧一类。阅读想象文学的目的是娱乐，或者感受文学的美。因此我们要避免一下几点：</p><ol><li>不要抗拒想象文学给你带来的影响，要跟随文学作品，去感受。</li><li>不要在想象文学中去找主旨、论述。</li><li>要用适用于传递知识的，与真理一致的标准来批评小说。<br>阅读想象文学的一些规则：</li><li>将一本想象文学书进行分类</li><li>了解一本书的整体大意，或者说主干。</li><li>要知道书中的整体是怎样由部分架构起来的。</li></ol><p>如何评论一个想象文学作品：</p><ol><li>首先你能体会并且在自己脑海中创造一个作者所构建的世界。</li><li>对作者的前提和假设你可以不接受，但不能说这是错的。</li><li>想象文学只有喜欢不喜欢，没有对与错。</li></ol><p>掌握和运用好想象文学的阅读方法，能帮助你了解到一本书给你带来喜悦的原因，以及这本书的有点和缺点，而且你能很好的评价一本想象文学作品。</p><h4 id="阅读一本小说书"><a class="header-anchor" href="#阅读一本小说书"></a>阅读一本小说书:</h4><ol><li>快，并且全神贯注，最好能一口气读完。</li></ol><h4 id="阅读一首诗："><a class="header-anchor" href="#阅读一首诗："></a>阅读一首诗：</h4><ol><li>同样，不论你读没读懂，都要先一口气读完。</li><li>重读一遍，并大声朗诵。</li><li>可以适当了解作者的背景(更有帮助)。</li></ol><h4 id="阅读历史："><a class="header-anchor" href="#阅读历史："></a>阅读历史：</h4><ol><li>历史书上所记载的不一定就是真实的历史。</li><li>写历史书的人不能保证完全客观，了解一个时期的历史，需要多方考察。</li><li>由史鉴今<br><strong>阅读历史：</strong></li><li>明白历史书的事件和时间限定范围</li><li>评论历史书籍，从作者知识的完备性或真实性方面</li><li>了解某本历史书给你带来的价值。</li></ol><h4 id="阅读报道："><a class="header-anchor" href="#阅读报道："></a>阅读报道：</h4><ol><li>作者想要证明什么</li><li>他想说服谁</li><li>他具有的特殊知识是什么</li><li>他使用了什么特殊语言(和当前时代相关)</li><li>他真的知道自己在说什么么？(报道是否属实)</li></ol><h4 id="阅读科学和数学："><a class="header-anchor" href="#阅读科学和数学："></a>阅读科学和数学：</h4><p>数学也是一种语言，用于描述规则或规律的语言。<br>从简单开始，由易到难。<br>开始时不必深究每个细节，先看自己感兴趣的。<br>如果是科普类型的读物，则更需要掌握书的主旨和整体结构。</p><h4 id="阅读哲学："><a class="header-anchor" href="#阅读哲学："></a>阅读哲学：</h4><p>提问题的时候就一定要有孩子气的单纯，而回答问题的时候却成熟而睿智。<br>要回答哲学的问题，除了思考，别无它法。<br>哲学的风格：</p><ol><li>哲学对话，论说形式风格。</li><li>哲学论文或散文。</li><li>面对异议。提出问题，提出对立面，支持对立面的证据，支持问题的证据。</li><li>哲学系统化。用描述科学的方法来描述哲学。</li><li>格言形式。<br>每本哲学书里都有中心思想或者原则。</li></ol><h4 id="阅读“经书”："><a class="header-anchor" href="#阅读“经书”："></a>阅读“经书”：</h4><p>“经书”这里定义为你奉为真理的书。即虔诚的不怀疑的阅读的一本书。</p><h4 id="阅读社会科学："><a class="header-anchor" href="#阅读社会科学："></a>阅读社会科学：</h4><p>阅读社会科学的简单之处在于其表达形式大多是论述形式，并且和我们息息相关。<br>而不易之处在于熟悉的术语和观念容易造成理解的偏差，并且本身这个领域的一些定义就是混杂的。</p><h2 id="主题阅读"><a class="header-anchor" href="#主题阅读"></a>主题阅读</h2><p>两个要求 (主题阅读的准备阶段)：</p><ol><li>一个特定的问题，不会仅牵涉到一本书(针对你要研究的主题，设计一份试验性的书目。你可以参考图书馆目录、专家的建议与书中的书目索引。)。</li><li>要知道总的来说应该读哪些书。(浏览这份书目上所有的书，确定哪些与你的主题相关，并就你的主题建立起清楚的概念。这个时候检视阅读就派上用场了)</li></ol><h3 id="主题阅读的五个步骤"><a class="header-anchor" href="#主题阅读的五个步骤"></a>主题阅读的五个步骤</h3><p>当你使用检视阅读找到相关主题的书以后，就可以开始进行主题阅读了。</p><ol><li>找到相关章节。(注意你关注的重点是主题，而不是某一本书)</li><li>以自己为主导，带引作者与你达成共识。</li><li>详细列出自己的问题，从作者的书中去寻找答案。</li><li>整合不同作者对问题的回答，理清争议和观点。</li><li>分析讨论。<br>主题阅读需要的是“辩证的客观”，意味着主题阅读需要面面俱到，而不需要加入自己预设的立场。<br>主题工具书能从三方面帮助刚开始做研究的人：启动阅读，建议阅读．指导阅读。</li></ol><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><p>主动是阅读过程中最重要的部分。<br>阅读好的书能帮助你心智成长，保持活力。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《小狗钱钱》的忠告</title>
      <link href="/2021/02/08/%E3%80%8A%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1%E3%80%8B%E7%9A%84%E8%AF%AD%E5%BD%95/"/>
      <url>/2021/02/08/%E3%80%8A%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1%E3%80%8B%E7%9A%84%E8%AF%AD%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>投资入门的一本书(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em>小狗钱钱的忠告，不仅适合小孩子，也适合我</em><br><em>当然还有一本同一作者写的书《财务自由之路》</em></p><a id="more"></a><h3 id="金钱有一些秘密和规律，想要了解这些秘密和规律，前提条件是你真的有这个愿望。"><a class="header-anchor" href="#金钱有一些秘密和规律，想要了解这些秘密和规律，前提条件是你真的有这个愿望。"></a>金钱有一些秘密和规律，想要了解这些秘密和规律，前提条件是你真的有这个愿望。</h3><p>只有你真切的愿望，而这个愿望又需要金钱，你才能够足够用心的来了解这些金钱的秘密。<br>如果你暂时无法找到真切的愿望，那么可以写下10个你有钱过后想干的事情，从中选取3个，暂时作为你真切的愿望。而后你为它付出的越多，愿望则变得越强烈。</p><h3 id="从来不要抱着试一试的心态，要不就不做，要做就要做好。"><a class="header-anchor" href="#从来不要抱着试一试的心态，要不就不做，要做就要做好。"></a>从来不要抱着试一试的心态，要不就不做，要做就要做好。</h3><p>决定一件事情，就要在72小时内开始实行，否则你以后可能永远都不会做它了。</p><h3 id="你能否挣到钱，关键因素不在于你有一个特别好的点子或者多聪明，而是在于你有多自信。"><a class="header-anchor" href="#你能否挣到钱，关键因素不在于你有一个特别好的点子或者多聪明，而是在于你有多自信。"></a>你能否挣到钱，关键因素不在于你有一个特别好的点子或者多聪明，而是在于你有多自信。</h3><p>每日坚持写成功日记(记录当日成功的5件事)，会让你变得更加自信。在写成功日记时的反思也会使得你不会过度自负。</p><h3 id="你最好想清楚，你喜欢什么，然后再想着怎么用它来赚钱。"><a class="header-anchor" href="#你最好想清楚，你喜欢什么，然后再想着怎么用它来赚钱。"></a>你最好想清楚，你喜欢什么，然后再想着怎么用它来赚钱。</h3><p>爱好和投入往往能使得你比别人更擅长做这件事。</p><h3 id="你要每天做对未来意义重大的事情，即使每天花费10分钟，也会有重大不同。"><a class="header-anchor" href="#你要每天做对未来意义重大的事情，即使每天花费10分钟，也会有重大不同。"></a>你要每天做对未来意义重大的事情，即使每天花费10分钟，也会有重大不同。</h3><p>万事万物都需要坚持，亘古不变的道理</p><h3 id="欠钱的人应当毁掉信用卡。"><a class="header-anchor" href="#欠钱的人应当毁掉信用卡。"></a>欠钱的人应当毁掉信用卡。</h3><p>很神奇，负债过后，应该每月竟可能少的还钱，而是把多余的钱存起来，用于生活意外支出(以免债上加债),或者用于投资。</p><h3 id="当你定下大目标后，就意味着你要比别人付出多的多的努力。"><a class="header-anchor" href="#当你定下大目标后，就意味着你要比别人付出多的多的努力。"></a>当你定下大目标后，就意味着你要比别人付出多的多的努力。</h3><p>废话</p><h3 id="假如我们没有自己的“鹅”，我们就需要自己工作赚钱，有了“鹅”，就可以通过“鹅”赚钱。"><a class="header-anchor" href="#假如我们没有自己的“鹅”，我们就需要自己工作赚钱，有了“鹅”，就可以通过“鹅”赚钱。"></a>假如我们没有自己的“鹅”，我们就需要自己工作赚钱，有了“鹅”，就可以通过“鹅”赚钱。</h3><p>意味着需要先积累资本，用资本来产生利益。</p><h3 id="幸运是充分准备和努力工作的结果。"><a class="header-anchor" href="#幸运是充分准备和努力工作的结果。"></a>幸运是充分准备和努力工作的结果。</h3><p>努力的人大多数时候都幸运，不努力的人偶尔幸运。</p><h3 id="钱只令留在那些为之付出努力的人身边，用非法手段取得不义之财的人，反而会比没钱的时候感觉更糟糕。"><a class="header-anchor" href="#钱只令留在那些为之付出努力的人身边，用非法手段取得不义之财的人，反而会比没钱的时候感觉更糟糕。"></a>钱只令留在那些为之付出努力的人身边，用非法手段取得不义之财的人，反而会比没钱的时候感觉更糟糕。</h3><p>最赚钱的东西都写在刑法里</p><h3 id="恐惧总是在我们设想事情会如何不顺的时候出现。我们对失败的可能性想得越多，就越害怕。而当你朝看积极的目标去思考的时候，就不会心生畏惧。"><a class="header-anchor" href="#恐惧总是在我们设想事情会如何不顺的时候出现。我们对失败的可能性想得越多，就越害怕。而当你朝看积极的目标去思考的时候，就不会心生畏惧。"></a>恐惧总是在我们设想事情会如何不顺的时候出现。我们对失败的可能性想得越多，就越害怕。而当你朝看积极的目标去思考的时候，就不会心生畏惧。</h3><h3 id="投资前需要确定几点："><a class="header-anchor" href="#投资前需要确定几点："></a>投资前需要确定几点：</h3><ol><li>确定自己希望财务上获得成功</li><li>自信、有想法，做自己喜欢做的事情。</li><li>把钱分为日常开销、梦想目标和“金鹅”(其实还有一部分是意外保险)</li><li>进行明智的投资</li><li>享受生活</li></ol><h3 id="一个人引以为傲的事情，往往是那些做起来比较难的事情。"><a class="header-anchor" href="#一个人引以为傲的事情，往往是那些做起来比较难的事情。"></a>一个人引以为傲的事情，往往是那些做起来比较难的事情。</h3><p>如果你没有做今天这件事情，你就永远不会知道，给自己一些压力之后，你能够做到些什么。</p><h3 id="购买基金建议："><a class="header-anchor" href="#购买基金建议："></a>购买基金建议：</h3><ol><li>基金应该至少有十年历史。假如它在这么长时间内一直有丰厚的盈利，那我们可以认为，它在未来也会运作良好。</li><li>对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终获利最好。</li><li>选择大型基金，能够很好的分散风险</li><li>用72法则得到这笔钱需要翻一倍的年数。(72/年收益百分比=年数)</li><li>选择相应有发展潜力的行业基金(看眼光了)</li><li>选择长线，别做短线</li></ol><h3 id="金融市场和一年四季一样，经历春夏秋冬的轮转。"><a class="header-anchor" href="#金融市场和一年四季一样，经历春夏秋冬的轮转。"></a>金融市场和一年四季一样，经历春夏秋冬的轮转。</h3><p>别想着跌了就卖，你不卖就不会亏。</p><h3 id="最重要的是，钱在人们眼中是一种再过于自然、普通的东西了。"><a class="header-anchor" href="#最重要的是，钱在人们眼中是一种再过于自然、普通的东西了。"></a>最重要的是，钱在人们眼中是一种再过于自然、普通的东西了。</h3>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《拯救吃货六六》小程序开发一</title>
      <link href="/2021/01/27/%E3%80%8A%E6%8B%AF%E6%95%91%E5%90%83%E8%B4%A7%E5%85%AD%E5%85%AD%E3%80%8B%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B8%80/"/>
      <url>/2021/01/27/%E3%80%8A%E6%8B%AF%E6%95%91%E5%90%83%E8%B4%A7%E5%85%AD%E5%85%AD%E3%80%8B%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B8%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang技术札记</title>
      <link href="/2021/01/25/Golang%E6%8A%80%E6%9C%AF%E6%9C%AD%E8%AE%B0/"/>
      <url>/2021/01/25/Golang%E6%8A%80%E6%9C%AF%E6%9C%AD%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>全当一个适合自己的golang快捷手册(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　by JiHan</p><hr><a id="more"></a><h3 id="Golang条件编译"><a class="header-anchor" href="#Golang条件编译"></a>Golang条件编译</h3><p>可参考：<a href="https://zhuanlan.zhihu.com/p/92235251" target="_blank" rel="noopener">golang交叉编译和条件编译的实际应用</a></p><h3 id="编译test程序"><a class="header-anchor" href="#编译test程序"></a>编译test程序</h3><p><code>-c</code> 参数就能满足：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -mod vendor -c &lt;your_test.go&gt;</span><br></pre></td></tr></table></figure><p>编译完成后，可以像<code>go test</code>的方式一样使用该可执行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -mod vendor ipset_test.go -test.run TestDoor</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ipset.test -test.run TestDoor</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/sunsky303/p/11818480.html" target="_blank" rel="noopener">参考</a></p><h3 id="开源学习"><a class="header-anchor" href="#开源学习"></a>开源学习</h3><p>微服务框架：<br>完善的微服务框架：<a href="https://github.com/asim/go-micro" target="_blank" rel="noopener">go-micro</a>  <a href="http://m2.topgoer.com/" target="_blank" rel="noopener">文档</a> <a href="https://laravelacademy.org/post/21015" target="_blank" rel="noopener">手把手教学文档</a><br>提供微服务所需工具集：<a href="https://github.com/go-kit/kit" target="_blank" rel="noopener">go-kit</a>  <a href="https://learnku.com/go/t/38417" target="_blank" rel="noopener">文档</a><br>服务框架：<a href="https://github.com/tal-tech/go-zero" target="_blank" rel="noopener">go-zero</a></p><h3 id="go-mod及依赖包升级"><a class="header-anchor" href="#go-mod及依赖包升级"></a>go mod及依赖包升级</h3><p>首先我们要清楚，golang对于如何寻找第三方包：</p><ol><li>直接使用go环境变量中的<code>GOPATH</code>变量来作为第三方包存储根目录，第三方包也只能同时存在一个版本。</li><li>使用<code>go mod</code>后，根据<code>go.sum</code>中的依赖在<code>GOMODCACHE</code>或<code>vender</code>(如果编译指定vendor依赖)中寻找相应版本的包。</li></ol><p>go mod的基本命令：<br><a href="http://c.biancheng.net/view/5712.html" target="_blank" rel="noopener">参考(更多详情)</a><br>标准看<code>go help mod</code></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>go mod download</td><td>下载依赖包到本地（默认为 GOPATH/pkg/mod 目录）</td></tr><tr><td>go mod edit</td><td>编辑 go.mod 文件</td></tr><tr><td>go mod graph</td><td>打印模块依赖图</td></tr><tr><td>go mod init</td><td>初始化当前文件夹，创建 go.mod 文件</td></tr><tr><td>go mod tidy</td><td>增加缺少的包，删除无用的包</td></tr><tr><td>go mod vendor</td><td>将依赖复制到 vendor 目录下</td></tr><tr><td>go mod verify</td><td>校验依赖</td></tr><tr><td>go mod why</td><td>解释为什么需要依赖</td></tr></tbody></table><p>第三方包升级：</p><ol><li>首先获取升级包（默认情况下都是下载到<code>GOMODCACHE</code>路径下）<ol><li>可以使用<code>go get</code> 命令进行升级<br><code>go get -u all</code>  将项目中的包升级到最新的次要版本或者修订版本；<br><code>go get -u [包名]</code>  将项目中的包升级到最新的修订版本；<br><code>go get [包名]@[版本号]</code>  下载对应包的指定版本或者将对应包升级到指定的版本。<br><code>go list -m  -mod=mod -versions [包名]</code>可以查看该包支持版本</li><li>也可以使用<code>go-mod-upgrade</code>第三方可视化组件升级，<a href="https://learnku.com/go/t/40982" target="_blank" rel="noopener">参考</a><ol><li><code>go get -u github.com/oligot/go-mod-upgrade</code> 下载该组件</li><li>在需要的项目下执行<code>go-mod-upgrade</code></li><li>按照提示选择升级</li></ol></li></ol></li><li>如果有第三方依赖，需要修改依赖项，可以使用<code>replace</code>进行相应版本包的替换，比如：<code>replace github.com/ozgio/strutil v0.3.0 =&gt; github.com/shiweifu/strutil v0.3.0</code></li><li>执行<code>go mod tidy</code>和<code>go mod vendor</code>(如果有必要)</li></ol><h3 id="golang性能分析"><a class="header-anchor" href="#golang性能分析"></a>golang性能分析</h3><p><a href="http://liumurong.org/2019/12/gin_pprof/" target="_blank" rel="noopener">gin中使用pprof</a><br><a href="https://zhuanlan.zhihu.com/p/345413502" target="_blank" rel="noopener">go性能诊断</a><br>不同的路径参数，可以获取不同的性能结果：</p><ul><li>allocs: A sampling of all past memory allocations</li><li>block: Stack traces that led to blocking on synchronization primitives</li><li>cmdline: The command line invocation of the current program</li><li>goroutine: Stack traces of all current goroutines</li><li>heap: A sampling of memory allocations of live objects. You can specify the gc GET parameter to run GC before taking the heap sample.</li><li>mutex: Stack traces of holders of contended mutexes</li><li>profile: CPU profile. You can specify the duration in the seconds GET parameter. After you get the profile file, use the go tool pprof command to investigate the profile.</li><li>threadcreate: Stack traces that led to the creation of new OS threads</li><li>trace: A trace of execution of the current program. You can specify the duration in the seconds GET parameter. After you get the trace file, use the go tool trace command to investigate the trace.</li></ul><p>看性能：<code>go tool pprof --seconds 60 http://127.0.0.1:45/debug/pprof/profile</code><br>查阅结果：</p><ol><li>安装graphviz<code>yum install graphviz</code></li><li>执行：<code>go tool pprof -http 0.0.0.0:3001 file</code></li><li>在Chrome浏览器访问：<code>http://host:port</code></li><li>生成火焰图：<ol><li>下载工具：<code>go install github.com/uber/go-torch@latest</code></li><li>输出火焰图（默认生成torch.svg）：<code>go-torch &lt;file&gt;</code></li></ol></li></ol><p>业务跟踪：<code>curl http://127.0.0.1:45/debug/pprof/trace?seconds=30 &gt; /data/trace.out</code><br>查阅结果：</p><ol><li><code>go tool trace -http 0.0.0.0:3001 trace.out</code></li></ol><h3 id="go-micro学习"><a class="header-anchor" href="#go-micro学习"></a>go-micro学习</h3><p><a href="https://laravelacademy.org/post/21015" target="_blank" rel="noopener">手把手教学文档</a></p><h4 id="生成proto相关代码"><a class="header-anchor" href="#生成proto相关代码"></a>生成proto相关代码</h4><p>这里有一个路径问题，那么执行的命令要做适当修改：<br><code>protoc --proto_path=. --go_opt=Mproto/greeter.proto=./proto --micro_out=. --go_out=.  proto/greeter.proto</code><br>有关<code> --go_opt</code>参数以及<code>protoc-gen-go: unable to determine Go import path for &quot;proto/greeter.proto&quot;</code>问题<a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated#package" target="_blank" rel="noopener">处理方法</a></p><h3 id="字符串拼接"><a class="header-anchor" href="#字符串拼接"></a>字符串拼接</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">isFirst := <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> b strings.Builder</span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> oneMap &#123;</span><br><span class="line"><span class="keyword">if</span> !isFirst &#123;</span><br><span class="line">b.WriteString(<span class="string">","</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">isFirst = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">b.WriteString(k.String())</span><br><span class="line">&#125;</span><br><span class="line">idsStr := b.String()</span><br></pre></td></tr></table></figure><h3 id="有关panic"><a class="header-anchor" href="#有关panic"></a>有关panic</h3><p>go在触发<code>panic</code>的时候，程序退出码和C程序退出码不一致。golang遇到panic是自己内部触发的，并非接收到内核信号，退出码是<code>2</code>。而c语言触发段错误，内核会发送一个信号给该进程<code>SIGSEGV</code>，然后程序退出，退出码是<code>139</code></p><h3 id="有关golang内存泄漏"><a class="header-anchor" href="#有关golang内存泄漏"></a>有关golang内存泄漏</h3><h4 id="go内存泄漏分类："><a class="header-anchor" href="#go内存泄漏分类："></a>go内存泄漏分类：</h4><p>golang内存也存在泄漏，也就是没有按照想要的方式释放。一般分为以下几个方面：</p><ol><li>goroutine泄漏，即有些协程一直阻塞，无法得到释放，导致里面的变量无法释放，从而引起内存泄漏。比如：<ol><li>goroutine过多</li><li>goroutine阻塞<ol><li>IO阻塞</li><li>channel阻塞</li><li>select阻塞</li><li>互斥锁，或信号量阻塞</li></ol></li></ol></li><li>代码内存泄漏，代码中申请了一些内存，没有及时释放，或者被其他引用导致内存不断增加而泄漏。比如：<ol><li>time.After中函数延迟过大，这个After等到结束后才会释放</li><li>time.ticker 未stop</li><li>slice被全局变量引用导致不能释放。</li></ol></li><li>GC释放问题，在一些低版本中如1.12-1.15版本，gc采用了一些惰性回收机制，要等到内核压力大时才进行回收和释放。不过在1.16后的版本，gc基本比较稳定了。</li></ol><h4 id="排查工具和方法："><a class="header-anchor" href="#排查工具和方法："></a>排查工具和方法：</h4><ol><li>使用<code>pprof</code>工具，一个很强的工具，能排查各种阻塞，协程异常，内存异常等问题。通常使用这一个工具就足够了。<a href="https://zhuanlan.zhihu.com/p/396363069" target="_blank" rel="noopener">使用指南</a></li><li><code>valgrind</code>进一步分析内存溢出问题，(这个工具对c和c++好使，在go上没有试过)。<a href="https://valgrind.org/docs/manual/quick-start.html#quick-start.mcrun" target="_blank" rel="noopener">官方文档</a></li></ol><h4 id="pprof对性能影响："><a class="header-anchor" href="#pprof对性能影响："></a>pprof对性能影响：</h4><p>通过<a href="https://stackoverflow.com/questions/26545159/how-big-is-pprof-import-overhead-in-go" target="_blank" rel="noopener">stackoverflow的文章</a>以及<a href="https://medium.com/google-cloud/continuous-profiling-of-go-programs-96d4416af77b" target="_blank" rel="noopener">引用的文章</a>，可以得到一个待验证的观点：<strong>每分钟开启10s的pprof的性能分析，也会导致5%的额外开销。</strong><br>另外一个<a href="https://groups.google.com/g/golang-nuts/c/e6lB8ENbIw8" target="_blank" rel="noopener">讨论组</a>的观点是：<strong>脱离具体程序谈性能影响是不切实际的。使用性能分析工具进行问题排查是可靠安全的，如果担心性能影响，可只针对部分业务进行分析(类似集群，只分析一台)。</strong></p><h4 id="关于golang的版本特性："><a class="header-anchor" href="#关于golang的版本特性："></a>关于golang的版本特性：</h4><table><thead><tr><th>版本</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>Go 1.5</td><td>垃圾收集器优化</td><td>并发收集</td></tr><tr><td></td><td>内部包支持</td><td>内部引用的库放在<code>internal</code>文件夹下，外部无法引用</td></tr><tr><td></td><td><code>GOMAXPROCS=</code>可用核心数</td><td>意味着大部分情况下无需手动设置<code>GOMAXPROCS</code>，旧版本<code>GOMAXPROCS=1</code></td></tr><tr><td></td><td><code>go tool trace</code>命令</td><td>支持细粒度的程序执行跟踪</td></tr><tr><td></td><td><code>go doc</code>命令</td><td><code>1.13</code>被移除，需要单独下载安装</td></tr><tr><td>Go 1.6</td><td>支持<code>HTTP/2</code>协议</td><td>只要我们使用<code>TLS</code>则会默认启动<code>HTTP/2</code>特性</td></tr><tr><td>Go 1.7</td><td><code>Context</code>库和<code>vendor</code>支持优化</td><td><code>context</code>成为重要的控制流、上下文传递工具</td></tr><tr><td>Go 1.8</td><td>垃圾回收器进一步优化</td><td>延迟时间全面降到毫秒级别以下</td></tr><tr><td>Go 1.9</td><td><code>type alias</code>支持</td><td>当你使用<code>type T2 T1</code>的时候需要考虑是不是使用 <code>type T2 = T1</code>更好</td></tr><tr><td></td><td><code>Test Helper</code>函数</td><td>新加<code>(T).Helper</code>和<code>(B).Helper m</code>， 用来标记调用的函数是一个测试辅助函数</td></tr><tr><td>Go 1.10</td><td><code>go build/test</code>增加缓存优化</td><td>加速构建/测试性能，当你使用 容器进行构建/测试时，如果效率较低，考虑复用缓存</td></tr><tr><td>Go 1.11</td><td>引入<code>Go modules</code></td><td>从此<code>go mod</code>逐渐成为主流包管理方式</td></tr><tr><td>Go 1.12</td><td><code>go vet</code>工具</td><td><code>go tool vet</code>不再支持</td></tr><tr><td>Go 1.13</td><td><code>sync.Pool</code>优化</td><td>垃圾回收时，<code>pool</code>中对象不会被完全清理掉。它引入了一个<code>cache</code>，用于在两次GC之前清理pool中未使用的对象实例</td></tr><tr><td></td><td><code>defer</code>性能优化</td><td>性能提高 30%</td></tr><tr><td></td><td>新的逃逸分析(<code>escape analysis</code>)器</td><td>分析代码，何时分配到<code>stack</code>而不是<code>heap</code></td></tr><tr><td></td><td><code>errors</code>包优化</td><td>支持<code>wrapping</code>，<code>fmt.Errorf</code>增加<code>%w</code>格式符，<code>errors</code>包增加三个函数（<code>Unwrap、Is、As</code>），很实用</td></tr><tr><td></td><td><code>Go modules</code>成为默认值</td><td><code>Go 1.13</code>后<code>GOPROXY</code>和<code>GOSUMDB</code>都会有默认值</td></tr><tr><td>Go 1.14</td><td><code>defer</code>性能再次优化</td><td><code>Go1.14</code>提高了<code>defer</code>的大多数用法的性能，几乎0开销。defer已经可以用于对性能要求很高的场景了</td></tr><tr><td></td><td><code>time.Timer</code>性能提升</td><td>针对<code>timer</code>性能问题的很多优化不再有必要了</td></tr><tr><td></td><td>允许嵌入具有重叠方法集的接口</td><td><code>type ReadWriteCloser interface { io.ReadCloser;io.WriteCloser}</code>不会报错</td></tr><tr><td></td><td><code>testing</code>包的<code>T、B和TB</code>都加上了<code>CleanUp</code>方法</td><td>类似<code>defer</code>，清理测试申请资源</td></tr><tr><td></td><td>引入基于信号的的异步抢占机制</td><td>死循环的goroutine能够被抢占了，不过代价是出现死循环导致的性能下降问题更难排查了</td></tr><tr><td></td><td>更高效的页分配器</td><td>页分配器效率变高，并且在<code>GOMAXPROCS</code>值较高时，导致的锁争用显着减少</td></tr><tr><td>Go 1.15</td><td>链接器的重大改进，可减少链接器资源的使用</td><td>全新链接器，代码健壮性可维护性，开销都有改进</td></tr><tr><td></td><td>tzdata包</td><td>该程序包允许将时区数据库嵌入程序中</td></tr><tr><td>Go 1.16</td><td>添加了对<code>macOS ARM64</code>的支持</td><td>也称为<code>Apple</code>芯片</td></tr><tr><td></td><td>开始禁止<code>import</code>导入的模块以<code>.</code>开头</td><td><code>import &quot;./tools/image&quot;</code>将不合法</td></tr><tr><td></td><td>默认使用<code>go mod</code>进行管理</td><td><code>GO111MODULE</code>环境变量现在默认为<code>on</code></td></tr><tr><td></td><td>新增<code>embed</code>包</td><td><code>embed</code>包 提供了对使用<code>new//go:embed</code>指令在编译时访问嵌入在程序中的文件的功能</td></tr><tr><td></td><td><code>go install</code>和<code>go get</code>的功能分离</td><td><code>go get</code>不再支持安装，默认就使用<code>-d</code>参数</td></tr><tr><td>Go 1.17</td><td>简化<code>go mod</code>的依赖图</td><td><code>完整module依赖图</code>-&gt;<code>修剪的module依赖图</code></td></tr><tr><td></td><td>从基于堆栈的调用惯例到基于寄存器的调用惯例的切换</td><td>主要基于arm64架构下，性能得到较大提升</td></tr><tr><td></td><td>支持切片指针到数组指针的强制转换</td><td>减少内存拷贝，以及对切片的断言</td></tr><tr><td></td><td>更易读的构建约束</td><td><code>//go:build</code>-&gt;<code>// +build</code></td></tr><tr><td>Go 1.18</td><td>泛型<code>Generics</code>支持</td><td>引入了对使用参数化类型的泛型代码的新支持, 达到了算法可复用的目的</td></tr><tr><td></td><td>模糊测试<code>Fuzzing</code></td><td>提供了一种自动化测试的选择, Go 是第一个将模糊测试完全集成到其标准工具链中的主要语言</td></tr><tr><td></td><td><code>Workspaces</code></td><td>解决<code>go mod</code>遗留下来的本地多模块开发依赖问题</td></tr><tr><td>Go 1.19</td><td>泛型问题fix</td><td>更稳定的泛型支持，个人建议正式环境还是观望一波</td></tr><tr><td></td><td>文档优化</td><td><code>doc comment</code>文档优化</td></tr><tr><td></td><td><code>runtime.SetMemoryLimit</code></td><td>一个新的<code>runtime.SetMemoryLimit</code>函数以及一个<code>GOMEMLIMIT</code>环境变量被引入。有了这个memory软限制，Go运行时将通过限制堆的大小，以及更积极地将内存返回给底层os，来试图维持这个内存限制，以尽量避免Go程序因分配heap过多，超出系统内存资源限制而被kill</td></tr><tr><td></td><td>启动时将默认提高打开文件的限值</td><td>就是linux常见的<code>open files</code></td></tr><tr><td></td><td><code>race detector</code>性能提升</td><td><code>race</code>检测性能相对于上一版将提升1.5倍-2倍，内存开销减半，并且没有对goroutine的数量的上限限制</td></tr><tr><td></td><td>编译约束增加<code>unix</code>标签</td><td></td></tr><tr><td></td><td>其他标准库变化</td><td>如：<code>net</code>软件包将使用<code>EDNS</code>，<code>flag</code>包增加<code>TextVar</code>函数等</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《怪诞行为学：可预测的非理性》读书笔记</title>
      <link href="/2021/01/13/%E3%80%8A%E6%80%AA%E8%AF%9E%E8%A1%8C%E4%B8%BA%E5%AD%A6%EF%BC%9A%E5%8F%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E9%9D%9E%E7%90%86%E6%80%A7%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/01/13/%E3%80%8A%E6%80%AA%E8%AF%9E%E8%A1%8C%E4%B8%BA%E5%AD%A6%EF%BC%9A%E5%8F%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E9%9D%9E%E7%90%86%E6%80%A7%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>人性的弱点在经济学中的体现(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em>只是简单的记录书中的发现，或者有趣的事</em></p><a id="more"></a><ul><li>多数人只有到了具体情境才知道自己真正想要的是什么。</li><li>我们对事物的印象都是通过比较而得到的。<br>直观的表现如下：<br><img src="/2021/01/13/《怪诞行为学：可预测的非理性》读书笔记/page28.jpg" alt></li><li>我们不但喜欢将事物与事物进行比较，而且喜欢比较容易比较的——避免比较不容易比较的事物。</li><li>富有的人嫉妒比他更富有的人</li><li>要让人渴望做一件事，只需要让做这件事的机会难得即可</li><li>“幼鹅效应”与“锚定”</li><li>任意锚的初次形成之后仍会长久存在，伴随我们左右。</li><li>羊群效应：基于其他人推断的好坏来决定自己是否效仿。自己也可能成为自己的羊群。是基于前面的推断。</li><li>“任意一致性”很大程度上决定了我们的消费习惯</li><li>我们对价格的敏感度很大程度上取决于我们过去对价格的记忆，以及我们想与过去保持一致的欲望。</li><li>人类本能的惧怕损失，这使得免费变得非常诱人。</li><li>社会规范和市场规范。市场规范会挤走社会规范，市场规范和社会规范的界限之一就是有明确的价格。</li><li>只要提到“金钱”，我们的行为就越接近市场规范。</li><li>一旦社会规范与市场规范发生碰撞，社会规范就会退出。换言之，社会规范很难重建。</li><li>理性状态下无法预测非理性状态下的行为。</li><li>拖沓的本质还是理性和非理性下的决定不同。关键在于设立底线，那种形式的底线对你有帮助，就使用哪种。</li><li>简化的方式，自我强制性罚款手段和“家长式”提醒亦或者设定冷静期间都有助于防止拖沓。</li><li>我们会依恋我们所拥有的一切。</li><li>我们总是把注意力集中到自己会失去什么，而不是会得到什么。</li><li>我们经常假定别人看待交易的角度和我们一样。</li><li>宜家效应和虚拟所有权。(当你尝试使用一个东西过后，就会拥有虚拟所有权而加强购买欲望)</li><li>尝试用“非拥有心态”来看待一桩交易，把自己和感兴趣的物品适当拉开距离。</li><li>人们都幻想保留所有的“门”，把所有能尝试的都尝试一遍，但往往得不偿失。就算是两种方案之间的过多考虑，也会得不偿失。</li><li>人们美好的预期往往会提升实际体验的评价，反之亦然。偏见也是此原因。</li><li>价格的魔力和安慰剂原理是一样的。</li><li>不诚实是人们中的普遍现象。防止不诚实的方案：道德约束，法律法规。</li><li>离金钱越远的作弊现象越普遍。</li><li>人们并非理性的，所看到的事物都是不完全真实的。而正式因为非理性，才能有机会找到对你我都互利互惠的方式，我们称为“免费午餐”。</li><li>把我们喜欢和不喜欢的，但对我们有好处的事物关联到一起，从而解决日常生活中的自控问题。</li><li>我们会高估自己所拥有的的一切。同我们会依恋我们所拥有的一切。</li><li>预期能增强我们的体验，也可能会让我们失望。</li><li>人们有时候并不能良好的判断自己行为的边界，因此需要需要法规来给出底线。</li><li>我们很擅长说服自己看到自己想看的东西。</li><li>“计划谬误”是一种普遍现象，人们都过于乐观的指定计划。</li><li>主动地、有意识地对难解、困惑以至受伤的事件进行正确解读，能帮助人们走出“习得性无助状态”。</li><li>高薪资和奖金往往是激励和压力并存。</li><li>人们通常能够坦率的承认自己身体的局限，但是不愿意考虑自己认知上的不足。</li><li>我们应该坦率的承认自己身上的缺点，甚至无能，不断的去探索新的方法，努力创造更好的世界。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何进行http压测</title>
      <link href="/2020/12/25/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8Chttp%E5%8E%8B%E6%B5%8B/"/>
      <url>/2020/12/25/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8Chttp%E5%8E%8B%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>测试新手上线 (•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><a id="more"></a><h2 id="如何进行http压测"><a class="header-anchor" href="#如何进行http压测"></a>如何进行http压测</h2><h3 id="准备"><a class="header-anchor" href="#准备"></a>准备</h3><p>首先要准备2台设备，客户端，压测设备。如果是网关类型，需要增加后面的测试桩。<br>其次，我们需要选择压测工具，这里我使用的是<code>wrk</code>，由于io复用能在单机上产生很高的并发量。</p><h3 id="目的"><a class="header-anchor" href="#目的"></a>目的</h3><p>压测目的：</p><ol><li>了解自身项目在某种环境下的最大承受业务。</li><li>进行性能问题排查和优化。</li></ol><p><strong>TODO：</strong></p><ol><li>选定固定的运行环境(网络，运行系统，平台，压测工具，客户端)</li><li>准备基准测试项目和待测试项目</li><li>进行基准测试，并确定环境配置正常</li><li>进行待测试项目测试</li><li>分析总结</li></ol><h3 id="基准"><a class="header-anchor" href="#基准"></a>基准</h3><p>开始测试之前，我们需要测试对标的基准。通常可以在相应服务器上搭建一个nginx简单服务，进行压测得到基准参考数据。当然也可以找官方压测数据。<br>示例：<br><code>wrk -t 16 -c 1000 -d 60s --script=proxy_http.lua --latency http://192.168.1.11:5556/test10k.html</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Running 1m test @ http://192.168.1.11:5556/test0k.html</span><br><span class="line">  16 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     6.69ms    6.67ms 430.69ms   99.61%</span><br><span class="line">    Req/Sec     9.52k   825.25    25.95k    91.53%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    6.39ms</span><br><span class="line">     75%    6.88ms</span><br><span class="line">     90%    7.45ms</span><br><span class="line">     99%   10.20ms</span><br><span class="line">  9100687 requests in 1.00m, 2.13GB read</span><br><span class="line">Requests/sec: 151455.19</span><br><span class="line">Transfer/sec:     36.25MB</span><br></pre></td></tr></table></figure><p>基准测试一般都需要考虑到平台环境和网络环境，测试出的结果是否是正常值。如果有较大偏差，则需要考虑是否有其他因素影响测试结果。<br><strong>影响测试结果的一些情况：</strong></p><ol><li><p>linux文件/socket数目限制<br>可以通过以下配置查看</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ubuntu:~$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 20</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 16382</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024  #打开文件数目限制</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) unlimited</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><p>修改打开文件数目限制(临时)：<code>ulimit -n 2048</code><br>永久设置方法(<a href="https://blog.csdn.net/fdipzone/article/details/34588803" target="_blank" rel="noopener">参考</a>)：</p><blockquote><p><code>vim /etc/security/limits.conf</code>在最后加入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;* soft nofile 4096</span><br><span class="line">&gt;* hard nofile 4096</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>最前的 * 表示所有用户，可根据需要设置某一用户，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;fdipzone soft nofile 8192</span><br><span class="line">&gt;fdipzone hard nofile 8192</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>改完后注销一下就能生效。</p></blockquote><p>查看某一进程打开进程数：<code>lsof -p pid | wc -l</code><br>查看系统打开进程数：<code>lsof | wc -l</code></p></li><li><p>网络因素<br>如果网络有其他人一起在用，可能出现网络波动，导致测试结果波动，或者<code>wrk</code>出现timeout。实际测试时，可以考虑单独直连网线。</p></li><li><p>大量timeout占用socket<br>可以通过<code>ss -tan | grep TIME-WAIT</code>或<code>ss -s</code>命令查看是否有大量的time_wait(<code>ss -tan | awk  '{++S[$1]} END {for(a in S) print a, S[a]}'</code>可进行统计)。如果存在大量time_wait可通过配置<code> /etc/sysctl.conf</code>文件修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Controls the use of TCP syncookies</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"></span><br><span class="line"># The TIME-WAIT sockets for new connections can be reused</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"></span><br><span class="line"># Enable fast recycling of TIME-WAIT sockets status</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line"></span><br><span class="line"># Decrease the time default value for tcp_fin_timeout connection</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br></pre></td></tr></table></figure><p>然后执行 <code>/sbin/sysctl -p</code> 让参数生效</p></li><li><p>系统IO<br>大量的系统IO会使程序性能降低很多，当然类似的mysql频繁读写也会(这里不谈)。<br><code>iotop</code>查看系统IO情况。（<code>pidstat -d 1</code>和<code>iotop</code>类似，但是<code>pidstat</code>工具依赖更少）<a href="https://blog.csdn.net/yangguosb/article/details/89853045" target="_blank" rel="noopener">更多参考</a><br>如果存在一些大量占用IO的情况，可通过<code>lsof -p &lt;pid&gt;</code>(或者<code>iostat </code>、<code>pidstat</code>都能达到相同效果)来确定进程关联的文件，是否有文件在进行大量读写操作。<br>如果上述没有找到可以文件，也可以通过<code>strace -p &lt;pid&gt;</code>来观察进程和系统的交互，来确定程序在哪里进行了大量IO操作。<a href="https://www.linuxidc.com/Linux/2018-01/150654.htm" target="_blank" rel="noopener">strace使用参考</a></p></li><li><p>其他</p></li></ol><p>可根据项目重视的点来测试基准数据，并统计整理。<br>测试基准数据记录，除了基准的QPS，还要包括内存利用率，CPU利用率，网络带宽利用率，IO利用率这些基本情况。<a href="https://tlanyan.me/linux-traffic-commands/" target="_blank" rel="noopener">Linux查看网络流量</a></p><h3 id="压测"><a class="header-anchor" href="#压测"></a>压测</h3><p>首先要<strong>确保环境的一致性</strong>，保证变量的单一性，不论环境，网络，系统配置都需要保持 一致。<br>简单示例结果：</p><table><thead><tr><th></th><th>http+0k</th><th>http+nk</th><th>https+0k</th><th>https+nk</th></tr></thead><tbody><tr><td>基准</td><td>QPS:151455.19<br>CPU:93.6%<br>NET:125MB/s<br>IO:100KB/s<br>MEM:20%</td><td>…</td><td>…</td><td>…</td></tr><tr><td>project</td><td>QPS:142234.19<br>CPU:97.8%<br>NET:122MB/s<br>IO:128KB/s<br>MEM:40%</td><td>…</td><td>…</td><td>…</td></tr><tr><td>结论</td><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><h3 id="其他"><a class="header-anchor" href="#其他"></a>其他</h3><p><a href="https://learnku.com/articles/42203" target="_blank" rel="noopener">Nginx 高级篇（九）单机并发 1 万 10 万次请求解决和优化方案<br></a></p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《mysql必知必会》读书笔记</title>
      <link href="/2020/11/05/%E3%80%8Amysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/11/05/%E3%80%8Amysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>mysql初学者报道(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em>以下内容都是根据书中的内容，以及自己觉得有价值的部分进行记录。可供mysql的信息快捷检索。</em><br><em>本书是比较老的书了，基于的是MySQL5上进行编写的，与目前很多流行版本可能有所不符。但对于初学小白来说还是很有用的。</em></p><a id="more"></a><h2 id="了解mysql"><a class="header-anchor" href="#了解mysql"></a>了解mysql</h2><p>首先mysql是一个关系型数据库，设计的基本原则就是将现实种的一类事物对应一个表，事物之间的关系反应到表之间的关系。<br><strong>SQL</strong>是一种专门用来与数据库通信的语言<br><strong>表（table）</strong> 某种<code>特定类型数据</code>的结构化清单。比如顾客的清单和订单就应当放在两个表中。<br><strong>模式（schema）</strong> 关于数据库和表的布局及特性的信息。（理解不了，就不管）<br><strong>列（column）</strong> 表中的一个字段。所有表都是由一个或多个列组<br>成的。<br><strong>数据类型（datatype）</strong> 所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。<br><strong>行（row）</strong> 表中的一个记录。<br><strong>主键（primary key）</strong> 一列（或一组列），其值能够唯一区分表中每个行。<br>主键需要满足的条件：</p><ul><li>任意两行都不具有相同的主键值；</li><li>每个行都必须具有一个主键值（主键列不允许NULL值）。</li></ul><p>主键的最好习惯：</p><ul><li>不更新主键列中的值；</li><li>不重用主键列的值；</li><li>不在主键列中使用可能会更改的值。</li></ul><p>**外键（foreign key）**外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。<br><strong>关系表</strong>的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系（relational））互相关联。<br><strong>可伸缩性（scale</strong>）能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好（scale well）。</p><h2 id="MySQL简介"><a class="header-anchor" href="#MySQL简介"></a>MySQL简介</h2><p>分为客户端(mysql)，和服务端(mysqld)。</p><h2 id="使用MySQL"><a class="header-anchor" href="#使用MySQL"></a>使用MySQL</h2><p><strong>先看本书的目录，进行环境安装和基础表的导入</strong> <a href="./%E3%80%8Amysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/mysql_scripts.zip">下载</a><br>linux，只用命令行。我的环境：CLOUD<br><strong>使用前准备</strong><br>服务端安装：<br>mysql版本5.7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yum install mysql？？？？感觉还缺点啥</span><br><span class="line">$ systemctl start mysqld</span><br></pre></td></tr></table></figure><p>安装完成后，会在日志里产生一个随机密码，通过这个随机密码，进入数据库。<br>下面的命令可以修改密码：<br><code>mysql -u$db_user -p&quot;$tmpPass&quot; --connect-expired-password -e &quot;ALTER USER '$db_user'@'localhost' IDENTIFIED BY '$new_pass';flush privileges;&quot;</code><br>mysql默认配置文件<code>/etc/my.cnf</code><br>mysql默认日志输出<code>/var/log/mysqld.log</code></p><p>当我们需要用客户端连接到服务端时，需要：</p><ul><li>主机名（计算机名）——如果连接到本地MySQL服务器，为localhost；</li><li>端口（如果使用默认端口3306之外的端口）；</li><li>一个合法的用户名；</li><li>用户口令（如果需要）。</li></ul><p>链接mysql：<code>mysql -uroot -pxxx -P 3306 -h localhost</code>（具体看<code>mysql --help</code>）<br>使用命令行非交互模式操作数据库：<code>mysql -uroot -pxxx -P 3306 -h localhost -e &quot;sql command&quot;</code></p><p>导入示例数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ unzip mysql_scripts.zip</span><br><span class="line">mysql&gt; CREATE DATABASE test;</span><br><span class="line">mysql&gt; USE test;</span><br><span class="line">mysql&gt; source /path/create.sql</span><br><span class="line">mysql&gt; source ~/populate.sql</span><br></pre></td></tr></table></figure><h3 id="mysql的sql命令"><a class="header-anchor" href="#mysql的sql命令"></a>mysql的sql命令</h3><p>sql命令不区分大小写，但是表、数据库等名称是区分大小写的。<br>过个空格或者分行，等同于一个空格。<br>单个命令，我们称为一个子句，例如SELECT和FROM</p><h4 id="帮助"><a class="header-anchor" href="#帮助"></a>帮助:</h4><p><code>HELP cmd;</code><br><code>HELP SHOW;</code></p><h4 id="数据库相关："><a class="header-anchor" href="#数据库相关："></a>数据库相关：</h4><p>数据库创建：<code>CREATE DATABASE name;</code><br>数据库选择：<code>USE name;</code><br>数据库信息查看：<code>SHOW DATABASES;</code><br>数据库删除：<code>DROP DATABASE dbname;</code></p><h4 id="表相关："><a class="header-anchor" href="#表相关："></a>表相关：</h4><h5 id="信息显示："><a class="header-anchor" href="#信息显示："></a>信息显示：</h5><p>表列表：<code>SHOW tables;</code><br>列显示：<code>SHOW columns FROM table_name;</code></p><h5 id="普通检索："><a class="header-anchor" href="#普通检索："></a>普通检索：</h5><p>检索单个列：<code>SELECT prod_name FROM table_name;</code>（没有明确排序的情况，顺序不能保证一致性。）<br>检索多个列：<code>SELECT prod_name1,  prod_name2 FROM table_name;</code><br>检索所有列：<code>SELECT * FROM table_name \G;</code> (\G是更加友好是输出方式)<br>检索列值不同的行：<code>SELECT DISTINCT prod_name1 FROM table_name;</code> (不会显示prod_name1值相同的行)<br>检索行限制：<code>SELECT prod_name1 FROM table_name LIMIT 5;</code> (LIMIT 3,4 表示从3行开始的4行)<br>检索列和表限制：<code>SELECT products.prod_name FROM test.products;</code> (假设test数据库存在)</p><h5 id="数据排序："><a class="header-anchor" href="#数据排序："></a>数据排序：</h5><p>mysql在排序时认为A和a是一样的。<br>根据某列排序：<code>SELECT prod_name FROM products ORDER BY prod_id;</code><br>根据多行排序：<code>SELECT prod_id, prod_price, prod_name FROM products ORDER BY prod_price, prod_name;</code> （先按照价格排序，再按照名称排序）<br>排序方向：<code>SELECT prod_name FROM products ORDER BY prod_id DESC;</code>(默认情况下是升序，降序需要指定关键字<code>DESC</code>)<br>先降后升：<code>SELECT prod_id, prod_price, prod_name FROM products ORDER BY prod_price DESC, prod_name;</code> (升序关键字<code>ASC</code>,一般默认升序，所以没啥用)</p><h5 id="数据过滤："><a class="header-anchor" href="#数据过滤："></a>数据过滤：</h5><p><strong>常用过滤</strong>：<br><code>SELECT prod_price, prod_name FROM products WHERE prod_price = 2.50;</code>(字符比较时，默认不区分大小写)<br>范围检查：<code>SELECT prod_price, prod_name FROM products WHERE prod_price BETWEEN 5 AND 10;</code><br>空值检查：<code>SELECT cust_id FROM customers WHERE cust_email IS NULL;</code><br>WHERE操作符：</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>在指定的两个值之间</td></tr><tr><td>IS NULL</td><td>检查空值</td></tr></tbody></table><p>多个逻辑过滤组合，AND优先。最好是加上<code>()</code>确保逻辑正确。<br>逻辑过滤：<code>SELECT prod_price, prod_name FROM products WHERE vend_id = 1002 OR vend_id=1003;</code><br>逻辑过滤：<code>SELECT prod_price, prod_name FROM products WHERE vend_id IN (1002,1003);</code>（效果同上的OR操作）<br>WHERE逻辑操作符：</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>AND</td><td>同时满足</td></tr><tr><td>OR</td><td>满足其一</td></tr><tr><td>IN</td><td>满足其一</td></tr><tr><td>NOT</td><td>取反</td></tr></tbody></table><p><strong>通配符过滤</strong>：<br><code>SELECT prod_id, prod_name FROM products WHERE prod_name LIKE 'jet%'</code>（<code>%</code>类似正则里的<code>*</code>）</p><table><thead><tr><th>通配符</th><th>说明</th></tr></thead><tbody><tr><td>%</td><td>0~n个任意字符</td></tr><tr><td>_</td><td>1个任意字符</td></tr></tbody></table><p><strong>正则匹配</strong>：<br><code>SELECT prod_id, prod_name FROM products WHERE prod_name REGEXP '1000';</code></p><p><strong>字符类</strong></p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>任意字母和数字（同[a-zA-Z0-9]）</td></tr><tr><td>[:alpha:]</td><td>任意字符（同[a-zA-Z]）</td></tr><tr><td>[:blank:]</td><td>空格和制表（同[\t]）</td></tr><tr><td>[:cntrl:]</td><td>ASCII控制字符（ASCII 0到31和127）[:digit:] 任意数字（同[0-9]）</td></tr><tr><td>[:graph:]</td><td>与[:print:]相同，但不包括空格</td></tr><tr><td>[:lower:]</td><td>任意小写字母（同[a-z]）</td></tr><tr><td>[:print:]</td><td>任意可打印字符</td></tr><tr><td>[:punct:]</td><td>既不在[:alnum:]又不在[:cntrl:]中的任意字符</td></tr><tr><td>[:space:]</td><td>包括空格在内的任意空白字符（同[\f\n\r\t\v]）</td></tr><tr><td>[:upper:]</td><td>任意大写字母（同[A-Z]）</td></tr><tr><td>[:xdigit:]</td><td>任意十六进制数字（同[a-fA-F0-9]）</td></tr></tbody></table><p><strong>重复元字符元</strong></p><table><thead><tr><th>字</th><th>符说  明</th></tr></thead><tbody><tr><td>*</td><td>0个或多个匹配</td></tr><tr><td>+</td><td>1个或多个匹配（等于{1,}）</td></tr><tr><td>?</td><td>0个或1个匹配（等于{0,1}）</td></tr><tr><td>{n}</td><td>指定数目的匹配</td></tr><tr><td>{n,}</td><td>不少于指定数目的匹配</td></tr><tr><td>{n,m}</td><td>匹配数目的范围（m不超过255）</td></tr></tbody></table><p><strong>定位元字符元</strong></p><table><thead><tr><th>字</th><th>符说  明</th></tr></thead><tbody><tr><td>^</td><td>文本的开始</td></tr><tr><td>$</td><td>文本的结尾</td></tr><tr><td>[[:&lt;:]]</td><td>词的开始</td></tr><tr><td>[[:&gt;:]]</td><td>词的结尾</td></tr></tbody></table><h5 id="计算字段："><a class="header-anchor" href="#计算字段："></a>计算字段：</h5><p>拼接字段：<code>SELECT concat(vend_name ,'(', vend_country,')') FROM vendors;</code>（concat关键字做拼接）<br><code>RTrim()</code>去除右侧多余空格<br><code>LTrim()</code>去除左侧多余空格<br>使用别名：<code>SELECT concat(vend_name ,'(', vend_country,')') AS new_name FROM vendors;</code>（AS字段赋予新的列名）<br>算术计算：<code>SELECT prod_id, quantity * item_price AS expanded_price FROM orderitems;</code> 算术操作符(+、-、*、/)</p><h5 id="函数："><a class="header-anchor" href="#函数："></a>函数：</h5><p>函数可移植性不如SQL语句。<br>SQL支持的一些函数：</p><ol><li>文本处理函数</li><li>数值数据运算</li><li>日期处理</li><li>返回DBMS正使用的特殊信息</li></ol><p><strong>常用的文本处理函数</strong></p><table><thead><tr><th>函  数</th><th>符说  明</th></tr></thead><tbody><tr><td>Left()</td><td>返回串左边的字符</td></tr><tr><td>Length()</td><td>返回串的长度</td></tr><tr><td>Locate()</td><td>找出串的一个子串</td></tr><tr><td>Lower()</td><td>将串转换为小写</td></tr><tr><td>LTrim()</td><td>去掉串左边的空格</td></tr><tr><td>Right()</td><td>返回串右边的字符</td></tr><tr><td>RTrim()</td><td>去掉串右边的空格</td></tr><tr><td>Soundex()</td><td>返回串的SOUNDEX值，读音相近值</td></tr><tr><td>SubString()</td><td>返回子串的字符</td></tr><tr><td>Upper()</td><td>将串转换为大写</td></tr></tbody></table><p>示例：<code>SELECT cust_name, cust_contact FROM customers WHERE Soundex(cust_contact) = Soundex('Y Lie');</code></p><p><strong>常用日期和时间处理函数</strong></p><table><thead><tr><th>函  数</th><th>符说  明</th></tr></thead><tbody><tr><td>AddDate()</td><td>增加一个日期（天、周等）</td></tr><tr><td>AddTime()</td><td>增加一个时间（时、分等）</td></tr><tr><td>CurDate()</td><td>返回当前日期</td></tr><tr><td>CurTime()</td><td>返回当前时间</td></tr><tr><td>Date()</td><td>返回日期时间的日期部分</td></tr><tr><td>DateDiff()</td><td>计算两个日期之差</td></tr><tr><td>Date_Add()</td><td>高度灵活的日期运算函数</td></tr><tr><td>Date_Format()</td><td>返回一个格式化的日期或时间串</td></tr><tr><td>Day()</td><td>返回一个日期的天数部分</td></tr><tr><td>DayOfWeek()</td><td>对于一个日期，返回对应的星期几</td></tr><tr><td>Hour()</td><td>返回一个时间的小时部分</td></tr><tr><td>Minute()</td><td>返回一个时间的分钟部分</td></tr><tr><td>Month()</td><td>返回一个日期的月份部分</td></tr><tr><td>Now()</td><td>返回当前日期和时间</td></tr><tr><td>Second()</td><td>返回一个时间的秒部分</td></tr><tr><td>Time()</td><td>返回一个日期时间的时间部分</td></tr><tr><td>Year()</td><td>返回一个日期的年份部分</td></tr></tbody></table><p>示例：<code>SELECT * FROM orders WHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30';</code></p><p><strong>常用数值处理函数</strong></p><table><thead><tr><th>函  数</th><th>符说  明</th></tr></thead><tbody><tr><td>Abs()</td><td>返回一个数的绝对值</td></tr><tr><td>Cos()</td><td>返回一个角度的余弦</td></tr><tr><td>Exp()</td><td>返回一个数的指数值</td></tr><tr><td>Mod()</td><td>返回除操作的余数</td></tr><tr><td>Pi()</td><td>返回圆周率</td></tr><tr><td>Rand()</td><td>返回一个随机数</td></tr><tr><td>Sin()</td><td>返回一个角度的正弦</td></tr><tr><td>Sqrt()</td><td>返回一个数的平方根</td></tr><tr><td>Tan()</td><td>返回一个角度的正切</td></tr></tbody></table><p><strong>SQL聚集函数</strong>针对行组的操作函数</p><table><thead><tr><th>函  数</th><th>符说  明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的平均值</td></tr><tr><td>COUNT()</td><td>返回某列的行数</td></tr><tr><td>MAX()</td><td>返回某列的最大值</td></tr><tr><td>MIN()</td><td>返回某列的最小值</td></tr><tr><td>SUM()</td><td>返回某列值之和</td></tr></tbody></table><p>示例：<code>SELECT AVG(prod_price) AS avg_price FROM products;</code>，计算改列平均值。<br>COUNT(*)返回满足条件的数据行数，包括NULL，COUNT(column)不包含NULL</p><h5 id="分组数据"><a class="header-anchor" href="#分组数据"></a>分组数据</h5><p>创建分组：<code>SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id;</code> 其中<code>GROUP BY</code>按照<code>vend_id</code>排序进行分组。<br>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。<br>过滤分组：<code>SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id HAVING COUNT(*) &gt;= 3;</code><br><code>HAVING</code>和<code>WHERE</code>的差别: WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤.</p><h5 id="SELECT子句顺序"><a class="header-anchor" href="#SELECT子句顺序"></a>SELECT子句顺序</h5><table><thead><tr><th>子  句</th><th>说  明</th><th>是否必须使用</th></tr></thead><tbody><tr><td>SELECT</td><td>要返回的列或表达式</td><td>是</td></tr><tr><td>FROM</td><td>从中检索数据的表</td><td>仅在从表选择数据时使用</td></tr><tr><td>WHERE</td><td>行级过滤</td><td>否</td></tr></tbody></table><h5 id="子查询"><a class="header-anchor" href="#子查询"></a>子查询</h5><p>意味着把子查询语句查询的结果作为查询语句<code>where</code>的条件<br>示例：<code>SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'TNT2');</code><br>应当保证<code>where</code>子句中的列和子查询中<code>select</code>的列相同<br>也可以在计算字段使用子查询：<code>SELECT cust_name, cust_state, (SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id ) AS orders FROM customers;</code><br>在进行子查询使用时，注意限制歧义性列名，比如这里用的<code>orders.cust_id = customers.cust_id </code><br><em>编写子查询的时候最好逐步进行，一层层嵌套验证</em></p><h5 id="联结查询"><a class="header-anchor" href="#联结查询"></a>联结查询</h5><p>其实就是多条件查询，不过把主键和外键相互关联而已。链接的表越多，性能下降越厉害，毕竟需要提前列出行乘积的量。<br>等值联结示例：<code>SELECT vend_name, prod_name, prod_price FROM vendors, products WHERE vendors.vend_id = products.vend_id ORDER BY vend_name , prod_name ;</code>（注意避免出现列名的二义性），如果没有where语句，那么列出的数据将是对应数据在所在表的行乘积(不懂就自己试试)。<br>内部联结示例(能达到上例一样的结果)：<code>SELECT vend_name, prod_name, prod_price FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id  ORDER BY vend_name , prod_name ;</code><br>还有自连接、自然链接和外部链接。但是我感觉用where都能实现，就不搞这些了。</p><h5 id="组合查询"><a class="header-anchor" href="#组合查询"></a>组合查询</h5><p>将多个select查询语句，组合成单个查询语句返回。(多个查询语句的返回结果相似)<br>示例：<br><code>SELECT vend_id ,prod_id,prod_price FROM products WHERE prod_price &lt;= 5;</code> + <code>SELECT vend_id ,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002);</code><br>=<br><code>SELECT vend_id ,prod_id,prod_price FROM products WHERE prod_price &lt;= 5 UNION SELECT vend_id ,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002);</code><br>=<br><code>SELECT vend_id ,prod_id,prod_price FROM products WHERE prod_price &lt;= 5 OR vend_id IN (101001,1002);</code><br><code>UNION</code>和<code>WHERE OR</code>都能去除重复行，但如果要包含重复行，只有<code>UNION ALL</code>可以。<code>UNION </code>只能在最后一个<code>SELECT</code>子句中包含<code>ORDER BY</code>子句</p><h5 id="全文本搜索"><a class="header-anchor" href="#全文本搜索"></a>全文本搜索</h5><p>需要引擎支持一般MyISAM支持，InnoDB不支持<br>需要启动全文本搜索支持(FULLTEXT)，mysql会建立相关索引<br>建立全文搜索：<code>CREATE TABLE productfulltext ( note_id int NOT NULL AUTO_INCREMENT, prod_id char(10) NOT NULL, note_text text  NULL, PRIMARY KEY(note_id), FULLTEXT(note_text)) ENGINE=MyISAM;</code><br>建议不要在导入数据时使用FULLTEXT，导入后修改表定义FULLTEXT会快点。<br>执行全文搜索：<code>SELECT note_text FROM productnotes WHERE Match(note_text) Against('rabbit');</code> Match()指定被搜索的列，Against()指定要使用的搜索表达式。<br>Match()参数必须和FULLTEXT中定义的相同，如果是多列，必须一致。<br>同样效果：<code>SELECT note_text FROM productnotes WHERE note_text LIKE '%rabbit%';</code>. 区别在于<code>LIKE</code>返回的数据顺序不确定，<code>Match</code>有良好的排序。<br>使用扩展查询：<code>SELECT note_text FROM productnotes WHERE Match(note_text) Against('rabbit' WITH QUERY EXPANSION);</code><br>使用布尔文本搜索(在没有<code>FULLTEXT</code>下也能使用，但很缓慢)：``SELECT note_text FROM productnotes WHERE Match(note_text) Against(‘rabbit’ IN BOOLEAN MODE);`<br>布尔搜索支持通配：</p><table><thead><tr><th>布尔操作符</th><th>说  明</th></tr></thead><tbody><tr><td>+</td><td>包含，词必须存在</td></tr><tr><td>-</td><td>排除，词必须不出现</td></tr><tr><td>&gt;</td><td>包含，而且增加等级值</td></tr><tr><td>&lt;</td><td>包含，且减少等级值</td></tr><tr><td>()</td><td>把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）</td></tr><tr><td>~</td><td>取消一个词的排序值</td></tr><tr><td>*</td><td>词尾的通配符</td></tr><tr><td>“”</td><td>定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语）</td></tr></tbody></table><p>一些特殊说明：</p><ul><li>在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。</li><li>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参阅MySQL文档以了解如何完成此工作）。</li><li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN MODE。</li><li>如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中） 。</li><li>忽略词中的单引号。例如，don’t索引为dont。</li><li>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。如前所述，仅在MyISAM数据库引擎中支持全文本搜索。</li></ul><h5 id="插入数据"><a class="header-anchor" href="#插入数据"></a>插入数据</h5><p>示例：<code>INSERT INTO customers VALUES(NULL, 'pep', '100 main', 'Los', 'CA', '90046', 'USA', NULL, NULL);</code><br>插入数据必须对应着每一个列。<br>更安全的示例：<code>INSERT INTO customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email) VALUES(NULL, 'pep', '100 main', 'Los', 'CA', '90046', 'USA', NULL, NULL);</code> 这种方式，后面的数据只需要和前面列名相对于就行(但是省略掉的列必须可为空或者有默认值)。<br><code>INSERT LOW_PRIORITY INTO</code>方式插入可以降低插入的优先级，保证查询的效率。<br>插入多个列示例：<code>INSERT INTO customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email) VALUES(NULL, 'pep', '100 main', 'Los', 'CA', '90046', 'USA', NULL, NULL), (NULL, 'pep', '100 main', 'Los', 'CA', '90046', 'USA', NULL, NULL)</code><br>将数据从一张表导入到另外一张表：<code>INSERT INTO customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email) SELECT cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email FROM custnew;</code></p><h5 id="更新数据"><a class="header-anchor" href="#更新数据"></a>更新数据</h5><p>示例：<code>UPDATE customers SET cust_email = 'elmer@fudd.com' WHERE cust_id = 10005;</code><br>更新多列：<code>UPDATE customers SET cust_name = 'foo', cust_email = 'elmer@fudd.com' WHERE cust_id = 10005;</code> 更新多行默认情况下其中一个更新出错，所有更新数据都会恢复。如果需要发生错误也要继续更新，可使用关键字<code>IGNORE</code><br>删除相应值，可以将其<code>UPDATE</code>为<code>NULL</code>（前提允许为<code>NULL</code>）<br><strong>如果忽略<code>WHERE</code>就会更新所有行</strong></p><h5 id="删除数据"><a class="header-anchor" href="#删除数据"></a>删除数据</h5><p>删除行：<code>DELETE FROM customers WHERE cust_id = 10006;</code><br><strong>同样，如果忽略<code>WHERE</code>就会删除所有行</strong><br>如果需要删除表中所有行，使用<code>TRUNCATE TABLE</code>更佳<br>最好使用强制实施引用完整性的数据库，这样MySQL将不允许删除具有与其他表相关联的数据的行。</p><h5 id="创建表"><a class="header-anchor" href="#创建表"></a>创建表</h5><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers</span><br><span class="line">(</span><br><span class="line">  cust_id      <span class="built_in">int</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  cust_name    <span class="built_in">char</span>(<span class="number">50</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  cust_address <span class="built_in">char</span>(<span class="number">50</span>)  <span class="literal">NULL</span> ,</span><br><span class="line">  cust_city    <span class="built_in">char</span>(<span class="number">50</span>)  <span class="literal">NULL</span> ,</span><br><span class="line">  cust_state   <span class="built_in">char</span>(<span class="number">5</span>)   <span class="literal">NULL</span> ,</span><br><span class="line">  cust_zip     <span class="built_in">char</span>(<span class="number">10</span>)  <span class="literal">NULL</span> ,</span><br><span class="line">  cust_country <span class="built_in">char</span>(<span class="number">50</span>)  <span class="literal">NULL</span> ,</span><br><span class="line">  cust_contact <span class="built_in">char</span>(<span class="number">50</span>)  <span class="literal">NULL</span> ,</span><br><span class="line">  cust_email   <span class="built_in">char</span>(<span class="number">255</span>) <span class="literal">NULL</span> ,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (cust_id)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>创建表时需要改表名不存在，不然会报错。<br>创建表的时候，<code>NULL</code>和空串不是一回事。<code>NULL</code>代表没有值，空串代表有值且值为<code>''</code><br>创建主键：<code>PRIMARY KEY (vend_id, ...)</code>主键支持一个或多个，但行值必须唯一。主键不能配置为<code>NULL</code>值</p><p><strong>建表引擎</strong></p><ul><li>InnoDB是一个可靠的事务处理引擎，它不支持全文本搜索；</li><li>MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）</li><li>MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理。</li></ul><h5 id="更新表"><a class="header-anchor" href="#更新表"></a>更新表</h5><p>增加列：<code>ALTER TABLE vendors ADD vend_phone CHAR(20);</code><br>删除列：<code>ALTER TABLE vendors DROP COLUMN vend_phone;</code><br>定义外键：<code>ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id);</code><br>使用<code>ALTER</code>命令一定要小心谨慎，提前做数据备份，因为数据库表更改是不能撤销的。</p><h5 id="删除表"><a class="header-anchor" href="#删除表"></a>删除表</h5><p>示例：<code>DROP TABLE customers;</code> 不能撤销，没有确认，一次性永久删除。</p><h5 id="重命名表"><a class="header-anchor" href="#重命名表"></a>重命名表</h5><p>示例：<code>RENAME TABLE customers2 TO customers;</code><br>重命名多个：<code>RENAME TABLE customers2 TO customers, A TO A2;</code></p><h4 id="视图"><a class="header-anchor" href="#视图"></a>视图</h4><p>视图不包含任何数据，仅仅是一张虚拟表。<br>如：<br>我们需要查询一组数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name , cust_contact </span><br><span class="line">  <span class="keyword">FROM</span> customers, orders, orderitems </span><br><span class="line">  <span class="keyword">WHERE</span> customers.cust_id = orders.cust_id </span><br><span class="line">    <span class="keyword">AND</span> orderitems.order_num = orders.order_num </span><br><span class="line">    <span class="keyword">AND</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure><p>而我们需要根据不同的<code>prod_id</code>得到不同的结果。为了简便，我们将前面相同的查询包装成一个表<code>productcustomers</code>虚拟表。得到以下查询：<br><code>SELECT cust_name, cust_contact FROM productcustomers  WHERE prod_id = 'TNT2';</code><br>而这里的<code>productcustomers</code>就是视图。<br>视图好处：</p><ul><li>重用SQL语句。</li><li>简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</li><li>使用表的组成部分而不是整个表。</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul><p>视图常见的规则和限制：</p><ul><li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</li><li>对于可以创建的视图数目没有限制。</li><li>为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</li><li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</li><li>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。</li><li>视图不能索引，也不能有关联的触发器或默认值。</li><li>视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。</li></ul><p>使用视图并不能提升性能，只是做了一次包装，实际查询还是一样的过程。</p><h5 id="视图使用"><a class="header-anchor" href="#视图使用"></a>视图使用</h5><ul><li><p>视图用<code>CREATE VIEW</code>语句来创建。示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> productcustomers <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name , cust_contact </span><br><span class="line">  <span class="keyword">FROM</span> customers, orders, orderitems </span><br><span class="line">  <span class="keyword">WHERE</span> customers.cust_id = orders.cust_id </span><br><span class="line">    <span class="keyword">AND</span> orderitems.order_num = orders.order_num</span><br></pre></td></tr></table></figure></li><li><p>使用<code>SHOW CREATE VIEW viewname;</code>来查看创建视图的语句。</p></li><li><p>用DROP删除视图，其语法为<code>DROP VIEW viewname;</code>。</p></li><li><p>更新视图时，可以先用DROP再用CREATE，也可以直接用<code>CREATE OR REPLACE VIEW</code>。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</p></li></ul><p>视图中还可以进行数据格式化、过滤和计算等。其使用方式和<code>SELECT</code>本质上一样</p><h4 id="存储过程"><a class="header-anchor" href="#存储过程"></a>存储过程</h4><p>一个业务稍微复杂的业务，通常都需要很多个SQL语句配合才能完成。而这个时候，使用存储过程就可以将这些SQL语句整合到一起。可将其视为批处理，虽然不仅限于批处理。<br>使用存储过程好处(简单、安全、高性能)：</p><ul><li>通过把处理封装在容易使用的单元中，简化复杂的操作（正如前面例子所述）。</li><li>由于不要求反复建立一系列处理步骤，这保证了数据的完整性和统一性</li><li>简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。</li><li>提高性能。因为使用存储过程比使用单独的SQL语句要快。</li><li>存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码。</li></ul><h5 id="创建存储过程"><a class="header-anchor" href="#创建存储过程"></a>创建存储过程</h5><p>创建存储过程（命令行下 有语法错误）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing() </span><br><span class="line">  <span class="keyword">BEGIN</span>  </span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">Avg</span>(prod_price) <span class="keyword">AS</span> priceaverage </span><br><span class="line">      <span class="keyword">FROM</span> products; </span><br><span class="line">  <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>如果在命令行下执行，需要使用<code>DELIMITER</code>修改分隔符：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing() </span><br><span class="line">  <span class="keyword">BEGIN</span>  </span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">Avg</span>(prod_price) <span class="keyword">AS</span> priceaverage </span><br><span class="line">      <span class="keyword">FROM</span> products; </span><br><span class="line">  <span class="keyword">END</span>$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h5 id="调用存储过程"><a class="header-anchor" href="#调用存储过程"></a>调用存储过程</h5><p>存储过程的执行为调用，调用方式和函数调用类似。<br><code>CALL productprice(@pricelow, @pricehigh);</code><br>存储过程定义的时候，参数可定义类型为<code>IN</code>、<code>OUT</code>和<code>INOUT</code>。用于表示参数是传入、传出还是即传入又传出。参数传递和定义类型一致。<br>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> productpricing(</span><br><span class="line">  <span class="keyword">OUT</span> o <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">  <span class="keyword">IN</span> i <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">  INOUT io <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">) </span><br><span class="line">  <span class="keyword">BEGIN</span>  </span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">Avg</span>(prod_price) <span class="keyword">INTO</span> o </span><br><span class="line">      <span class="keyword">FROM</span> products; </span><br><span class="line">    <span class="comment">-- Do some other things</span></span><br><span class="line">  <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>如果我们想显示变量返回的值：<code>SELECT @pricelow， @pricehigh</code>方式。</p><h5 id="删除存储过程："><a class="header-anchor" href="#删除存储过程："></a>删除存储过程：</h5><p><code>DROP PROCEDURE productpricing;</code><br><code>DROP PROCEDURE IF EXISTS productpricing;</code></p><h5 id="检查存储过程："><a class="header-anchor" href="#检查存储过程："></a>检查存储过程：</h5><p>可以看到创建时间、创建者等一些详细信息。<br><code>SHOW CREATE PROCEDURE productpricing</code></p><h5 id="稍微复杂的存储过程代码"><a class="header-anchor" href="#稍微复杂的存储过程代码"></a>稍微复杂的存储过程代码</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Name: ordertotar</span></span><br><span class="line"><span class="comment">-- Parameters: onumber = order number</span></span><br><span class="line"><span class="comment">--                     taxable = 0 if not taxable, 1 if taxable </span></span><br><span class="line"><span class="comment">--                     ototal = order total variable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal (</span><br><span class="line">  <span class="keyword">IN</span> onumber <span class="built_in">INT</span>,</span><br><span class="line">  <span class="keyword">IN</span> taxable <span class="built_in">BOOLEAN</span>, </span><br><span class="line">  <span class="keyword">OUT</span> ototal <span class="built_in">DECIMAL</span> (<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">) <span class="keyword">COMMENT</span> <span class="string">'Obtain order total, optionally adding tax'</span></span><br><span class="line">BECIN</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Declare variable for total </span></span><br><span class="line">  <span class="keyword">DECLARE</span> total <span class="built_in">DECIMAL</span> (<span class="number">8</span>,<span class="number">2</span>); </span><br><span class="line">  <span class="comment">-- Declare tax percentage </span></span><br><span class="line">  <span class="keyword">DECLARE</span> taxrate <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Get the order total.</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">Sum</span>(item_price*quantity) </span><br><span class="line">  <span class="keyword">FROM</span> orderitems</span><br><span class="line">  <span class="keyword">WHERE</span> order_num = onumber </span><br><span class="line">  <span class="keyword">INTO</span> total;</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- Is this taxable? </span></span><br><span class="line">  IF taxable THEN</span><br><span class="line">    <span class="comment">-- Yes. so add taxrate to the total.</span></span><br><span class="line">    <span class="keyword">SELECT</span> total+(total/<span class="number">100</span>*taxrate) <span class="keyword">INTO</span> total; </span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">---And finally, save to out variable </span></span><br><span class="line">  <span class="keyword">SELECT</span> total <span class="keyword">INTO</span> ototal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h5 id="游标："><a class="header-anchor" href="#游标："></a>游标：</h5><p>只能用于存储过程中。<br>用于检索存储过程中读取到的多行数据。可进行前进或者退后一行等操作。详细使用等用到再说。</p><h4 id="触发器："><a class="header-anchor" href="#触发器："></a>触发器：</h4><p>在某些语句或事件之后后自动执行某些语句。<br>触发器支持的事件：</p><ol><li>DELETE</li><li>INSERT</li><li>UPDATE</li></ol><h5 id="创建触发器"><a class="header-anchor" href="#创建触发器"></a>创建触发器</h5><p>需要4个信息：</p><ul><li>唯一的触发器名(每个表中唯一)；</li><li>触发器关联的表；</li><li>触发器应该响应的活动（DELETE、INSERT或UPDATE）；</li><li>触发器何时执行（处理之前或之后）</li></ul><p>示例：<code>CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT 'Product added' INTO @v;</code> （Mysql 5后触发器不允许直接返回值，因此需要把值存放到一个变量中）<br>上面示例的含义：<code>CREATE TRIGGER</code>用来创建名为<code>newproduct</code>的新触发器。触发器可在一个操作发生之前或之后执行，这里给出了<code>AFTER INSERT</code>，所以此触发器将在<code>INSERT</code>语句成功执行后执行。这个触发器还指定<code>FOR EACH ROW</code>，因此代码对每个插入行执行。在这个例子中，文本’Product added’将在每次插入行后存放到v变量中。</p><h5 id="删除触发器"><a class="header-anchor" href="#删除触发器"></a>删除触发器</h5><p>示例：<code>DROP TRIGGER newproduct;</code></p><h5 id="使用触发器"><a class="header-anchor" href="#使用触发器"></a>使用触发器</h5><p><strong>INSERT触发器</strong></p><ul><li>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；</li><li>在BEFOREINSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）；</li><li>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值<br>示例：<code>CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT NEW.prod_id INTO @v;</code>  在新插入一行后，自动将改行的<code>prod_id</code>赋值到<code>v</code>变量中。</li></ul><p><strong>DELETE触发器</strong></p><ul><li>在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行</li><li>OLD中的值全都是只读的，不能更新<br>将删除的行保存到另外一张表：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> deleteorder <span class="keyword">BEFORE</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> orders </span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line">DEGIN</span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> archive_orders(order_num, order_date, cust_id)</span><br><span class="line">  <span class="keyword">VALUES</span>(OLD.order_num, OLD.order_date, OLD.cust_id)</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><strong>UPDATE触发器</strong></p><ul><li>在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值；</li><li>在BEFOREUPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）</li><li>OLD中的值全都是只读的，不能更新</li></ul><h4 id="管理事物处理："><a class="header-anchor" href="#管理事物处理："></a>管理事物处理：</h4><p>事物处理可以用来维护数据库完整性，它保证成批的MySQL语句，要么完全执行，要么完全不执行。</p><ul><li><strong>事务</strong>（transaction）指一组SQL语句；</li><li><strong>回退</strong>（rollback）指撤销指定SQL语句的过程；</li><li><strong>提交</strong>（commit）指将未存储的SQL语句结果写入数据库表；</li><li><strong>保留点</strong>（savepoint）指事务处理中设置的临时占位符（place- holder），你可以对它发布回退（与回退整个事务处理不同）</li></ul><h5 id="控制事务处理："><a class="header-anchor" href="#控制事务处理："></a>控制事务处理：</h5><p>开始事务标识：<code>START TRANSACTION;</code><br>回退：<code>ROLLBACK;</code> 只能在执行<code>START TRANSACTION;</code>后有效<br>提交：<code>COMMIT;</code>将事务内执行的操作写入到表。<br>在<code>COMMIT</code>或<code>ROLLBACK</code>后，事务自动关闭。<br>设置保留点：<code>SAVEPOINT delete1;</code>在事务中增加保留点，就能回退到你想回退的保留点位置。</p><p>MySQL默认是自动提交的，即执行完一个SQL语句，自动commit。可以通过<code>SET autocommit=0</code>来取消自动提交。(<code>autocommit</code>针对的是每个连接而不是服务器)</p><h4 id="全球化和本地化："><a class="header-anchor" href="#全球化和本地化："></a>全球化和本地化：</h4><ul><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对为规定字符如何比较的指令</li></ul><p>查询系统支持字符集合默认校对：<code>SHOW CHARACTER SET;</code><br>查看所有校对：<code>SHOW COLLATION;</code><br>查看数据库所使用的字符集和校对：<br><code>SHOW VARIABLES LIKE 'character%';</code><br><code>SHOW VARIABLES LIKE 'collation%';</code><br>给表或单列指定相关字符集合校对顺序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers(</span><br><span class="line">  cust_id      <span class="built_in">int</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  cust_name    <span class="built_in">char</span>(<span class="number">50</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATION</span> utf8_general_ci,</span><br><span class="line">) <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> hebrew <span class="keyword">COLLATION</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure><ul><li>如果指定<code>CHARACTER SET</code>和<code>COLLATE</code>两者，则使用这些值。</li><li>如果只指定<code>CHARACTER SET</code>，则使用此字符集及其默认的校对（如<code>SHOW CHARACTER SET</code>的结果中所示）。</li><li>如果既不指定<code>CHARACTER SET</code>，也不指定<code>COLLATE</code>，则使用数据库默认</li></ul><p>对<code>SELECT</code>使用<code>COLLATE</code>指定一个备用的校对顺序。</p><h4 id="安全管理"><a class="header-anchor" href="#安全管理"></a>安全管理</h4><p>应该给不同的用户不同的访问权限，有些有完全控制权(管理员)，有些则有只读权限。<br>MySQL的用户账号信息都在<code>mysql</code>表中(用户的增删通常都不建议直接操作该表，而是使用相应命令)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><h5 id="创建用户账号"><a class="header-anchor" href="#创建用户账号"></a>创建用户账号</h5><p><code>CREATE USER ben IDENTIFIED BY 'p@$$wOrd';</code><br>也可以不增加<code>IDENTIFIED</code>，不设密码</p><h5 id="重命名用户"><a class="header-anchor" href="#重命名用户"></a>重命名用户</h5><p><code>RENAME USER ben TO bforta;</code></p><h5 id="删除用户"><a class="header-anchor" href="#删除用户"></a>删除用户</h5><p><code>DROP USER bforta;</code></p><h5 id="设置访问权限"><a class="header-anchor" href="#设置访问权限"></a>设置访问权限</h5><p>查看用户权限:<code>SHOW GRANTS FOR bforta;</code><br>不指定主机名的情况下，MySQL里<code>%</code>代表主机名，<code>USAGE</code>表示没有任何权限。<br>授予权限：<code>GRANT SELECT, INSERT ON crashcourse.* TO bforta;</code> 授予<code>bforta</code>用户<code>crashcourse</code>表的<code>SELECT</code> 和<code>INSERT</code>权限</p><h5 id="取消访问权限"><a class="header-anchor" href="#取消访问权限"></a>取消访问权限</h5><p><code>REVOKE SELECT ON crashcourse.* FROM bforta;</code> 被撤销的权限必须存在，否则出错。</p><h5 id="修改密码"><a class="header-anchor" href="#修改密码"></a>修改密码</h5><p><code>SET PASSWORD = Password('passssssword');</code></p><h5 id="权限列表"><a class="header-anchor" href="#权限列表"></a>权限列表</h5><table><thead><tr><th>权限</th><th>说  明</th></tr></thead><tbody><tr><td>ALL</td><td>除GRANTOPTION外的所有权限</td></tr><tr><td>ALTER</td><td>使用ALTER TABLE</td></tr><tr><td>ALTER ROUTINE</td><td>使用ALTER PROCEDURE和DROP PROCEDURE</td></tr><tr><td>CREATE</td><td>使用CREATE TABLE</td></tr><tr><td>CREATE ROUTINE</td><td>使用CREATE PROCEDURE</td></tr><tr><td>CREATE TEMPORARY TABLES</td><td>使用CREATE TEMPORARY TABLE</td></tr><tr><td>CREATE USER</td><td>使用CREATE USER、DROPUSER、RENAMEUSER和REVOKE ALLPRIVILEGES</td></tr><tr><td>CREATE VIEW</td><td>使用CREATE VIEW</td></tr><tr><td>DELETE</td><td>使用DELETE</td></tr><tr><td>DROP</td><td>使用DROP TABLE</td></tr><tr><td>EXECUTE</td><td>使用CALL和存储过程</td></tr><tr><td>FILE</td><td>使用SELECT INTO OUTFILE和LOAD DATA INFILE</td></tr><tr><td>GRANT OPTION</td><td>使用GRANT和REVOKE</td></tr><tr><td>INDEX</td><td>使用CREATE INDEX和DROP INDEX</td></tr><tr><td>INSERT</td><td>使用INSERT</td></tr><tr><td>LOCK TABLES</td><td>使用LOCK TABLES</td></tr><tr><td>PROCESS</td><td>使用SHOW FULL PROCESSLIST</td></tr><tr><td>RELOAD</td><td>使用FLUSH</td></tr><tr><td>REPLICATION CLIENT</td><td>服务器位置的访问</td></tr><tr><td>REPLICATION SLAVE</td><td>由复制从属使用</td></tr><tr><td>SELECT</td><td>使用SELECT</td></tr><tr><td>SHOW DATABASES</td><td>使用SHOW DATABASES</td></tr><tr><td>SHOW VIEW</td><td>使用SHOW CREATE VIEW</td></tr><tr><td>SHUTDOWN</td><td>使用mysqladminshutdown（用来关闭MySQL）</td></tr><tr><td>SUPER</td><td>使用CHANGEMASTER、KILL、LOGS、PURGE、MASTER和SETGLOBAL。还允许mysqladmin调试登录</td></tr><tr><td>UPDATE</td><td>使用UPDATE</td></tr><tr><td>USAGE</td><td>无访问权限</td></tr></tbody></table><h4 id="数据库维护："><a class="header-anchor" href="#数据库维护："></a>数据库维护：</h4><h5 id="数据备份"><a class="header-anchor" href="#数据备份"></a>数据备份</h5><ul><li>使用命令行实用程序<code>mysqldump</code>转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。</li><li>可用命令行实用程序<code>mysqlhotcopy</code>从一个数据库复制所有数据（并非所有数据库引擎都支持这个实用程序）。</li><li>可以使用MySQL的<code>BACKUP TABLE</code>或<code>SELECT INTO OUTFILE</code>转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据可以用<code>RESTORE TABLE</code>来复原。<br><strong>首先刷新未写数据</strong> 为了保证所有数据被写到磁盘（包括索引数据） ，可能需要在进行备份前使用<code>FLUSH TABLES</code>语句。</li></ul><h5 id="进行数据库维护"><a class="header-anchor" href="#进行数据库维护"></a>进行数据库维护</h5><ul><li><code>ANALYZE TABLE</code>，用来检查表键是否正确。</li><li><code>CHECK TABLE</code>用来针对许多问题对表进行检查。在MyISAM表上还对索引进行检查。<code>CHECK TABLE</code>支持一系列的用于MyISAM表的方式。<code>CHANGED</code>检查自最后一次检查以来改动过的表。<code>EXTENDED</code>执行最彻底的检查，<code>FAST</code>只检查未正常关闭的表，<code>MEDIUM</code>检查所有被删除的链接并进行键检验，<code>QUICK</code>只进行快速扫描。</li><li><code>REPAIR TABLE</code>用来修复偶尔产生的MyISAM表访问产生不正确和不一致的结果。</li><li><code>OPTIMIZE TABLE</code>用来回收一个表删除大量数据后的空间，从而优化表性能。</li></ul><h5 id="启动问题诊断"><a class="header-anchor" href="#启动问题诊断"></a>启动问题诊断</h5><ul><li>–help显示帮助——一个选项列表；</li><li>–safe-mode装载减去某些最佳配置的服务器；</li><li>–verbose显示全文本消息（为获得更详细的帮助消息与–help联合使用）；</li><li>–version显示版本信息然后退出。<br>更多的，可以进行网上搜索，和对应不同mysql版本进行查看。</li></ul><h5 id="日志文件"><a class="header-anchor" href="#日志文件"></a>日志文件</h5><ul><li><strong>错误日志</strong>。它包含启动和关闭问题以及任意关键错误的细节。此日志通常名为hostname.err，位于data目录中。此日志名可用–log-error命令行选项更改。</li><li><strong>查询日志</strong>。它记录所有MySQL活动，在诊断问题时非常有用。此日志文件可能会很快地变得非常大，因此不应该长期使用它。此日志通常名为hostname.log，位于data目录中。此名字可以用–log命令行选项更改。</li><li><strong>二进制日志</strong>。它记录更新过数据（或者可能更新过数据）的所有语句。此日志通常名为hostname-bin，位于data目录内。此名字可以用–log-bin命令行选项更改。注意，这个日志文件是MySQL5中添加的，以前的MySQL版本中使用的是更新日志。</li><li><strong>缓慢查询日志</strong>。顾名思义，此日志记录执行缓慢的任何查询。这个日志在确定数据库何处需要优化很有用。此日志通常名为hostname-slow.log，位于data目录中。此名字可以用–log-slow-queries命令行选项更改。</li></ul><h4 id="改善性能："><a class="header-anchor" href="#改善性能："></a>改善性能：</h4><ol><li>首先，MySQL（与所有DBMS一样）具有特定的硬件建议。在学习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但对用于生产的服务器来说，应该坚持遵循这些硬件建议。</li><li>一般来说，关键的生产DBMS应该运行在自己的专用服务器上。</li><li>MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大小等。（为查看当前设置，可使用SHOW VARIABLES;和SHOWSTATUS;。）</li><li>MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多个任务。如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢。如果你遇到显著的性能不良，可使用SHOWPROCESSLIST显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录）</li><li>尽量在数据库中进行过滤，而不是到客户端进行过滤。可有效减少带宽，并且数据库对过滤做了优化。</li><li>总是有不止一种方法编写同一条SELECT语句。应该试验联结、并、子查询等，找出最佳的方法。</li><li>使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。</li><li>一般来说，存储过程执行得比一条一条地执行其中的各条MySQL语句快。</li><li>应该总是使用正确的数据类型。</li><li>决不要检索比需求还要多的数据。换言之，不要用SELECT *（除非你真正需要每个列）。</li><li>有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li><li>在导入数据时，应该关闭自动提交。你可能还想删除索引（包括FULLTEXT索引） ，然后在导入完成后再重建它们。</li><li>必须索引数据库表以改善数据检索的性能。确定索引什么不是一件微不足道的任务，需要分析使用的SELECT语句以找出重复的WHERE和ORDERBY子句。如果一个简单的WHERE子句返回结果所花的时间太长，则可以断定其中使用的列（或几个列）就是需要索引的对象。</li><li>你的SELECT语句中有一系列复杂的OR条件吗？通过使用多条SELECT语句和连接它们的UNION语句，你能看到极大的性能改进。</li><li>索引改善数据检索的性能，但损害数据插入、删除和更新的性能。如果你有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们。（索引可根据需要添加和删除。）</li><li>LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE。</li><li>数据库是不断变化的实体。一组优化良好的表一会儿后可能就面目全非了。由于表的使用和内容的更改，理想的优化和配置也会改变。</li><li>最重要的规则就是，每条规则在某些条件下都会被打破。</li></ol><h4 id="其他："><a class="header-anchor" href="#其他："></a>其他：</h4><p>服务器状态信息：<code>SHOW status;</code><br>显示用户安全权限：<code>SHOW grants;</code><br>显示日志信息：<code>SHOW errors/warnings;</code></p><p>至此，本书笔记完结🎉</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《高性能mysql第三版》读书笔记</title>
      <link href="/2020/10/27/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/10/27/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>学习一下mysql还是很有必要的(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em>以下内容都是根据书中的章节目录，并且根据自己的缺陷进行记录的。</em></p><a id="more"></a><h3 id="第一章-mysql架构和历史"><a class="header-anchor" href="#第一章-mysql架构和历史"></a>第一章  mysql架构和历史</h3><p><strong>架构逻辑</strong>：<br>mysql将查询处理及其他系统任务和数据存储/提取进行分离<br><img src="/2020/10/27/《高性能mysql第三版》读书笔记/mysql%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt><br><em><a href="https://www.yinxiang.com/everhub/note/39051186-8641-4d49-852b-256cf80d3a22" target="_blank" rel="noopener">图片来源</a></em><br>存储引擎部分，仅仅是响应上层服务器请求，相互之间不会进行通信。<br>服务器会验证客户端密码或者证书，并且在认证通过后查询该客户端的权限。<br><strong>并发控制</strong>：<br>读写锁作为实现原理，锁的粒度作为性能的考量(锁的开销和安全性的平衡)，mysql提供了表锁和行级锁<br><strong>事务</strong>：<br>mysql中的一个原子性sql查询，或者独立工作单元<br>原子性，一致性，隔离性，持久性。<br>隔离级别：未提交读，提交读，可重复读，可串行读。<br>死锁：检测，死锁的循环依赖。解决，最少行级排他锁回滚。<br>事务日志：先将数据进行内存拷贝，再将需要进行的I/O读写操作写入到日志，由后台根据日志进行数据写入。如果数据本身还未写入磁盘，系统崩溃，相应的存储引擎也有相应的数据恢复策略。(怎么搞的？？)<br>mysql中默认自动提交，将每一次查询都当做一个事务提交。<br>事务是由存储引擎实现，如果使用多种存储引擎(事务型和非事务型)，会变得不可靠。</p><p><strong>多版本并发控制(mvcc)</strong>：</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APISIX调研和使用</title>
      <link href="/2020/09/22/APISIX%E8%B0%83%E7%A0%94%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/09/22/APISIX%E8%B0%83%E7%A0%94%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>针对性的了解apisix插件化api网关，期望能给项目提供一些参考和优化(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em><a href="https://github.com/apache/apisix" target="_blank" rel="noopener">官方Git</a></em><br><em><a href="https://github.com/apache/apisix-dashboard" target="_blank" rel="noopener">管理端页面</a></em><br><em><a href="https://github.com/apache/apisix/blob/master/doc/router-radixtree.md" target="_blank" rel="noopener">router-radixtree</a></em><br><em><a href="https://github.com/apache/apisix/blob/master/doc/zh-cn/architecture-design.md" target="_blank" rel="noopener">结构设计</a></em><br><em><a href="http://www.itheima.com/news/20200404/193127.html" target="_blank" rel="noopener">安装参考</a></em><br><em><a href="https://segmentfault.com/a/1190000020128654" target="_blank" rel="noopener">APISIX高性能实践</a></em><br><em><a href="https://zhuanlan.zhihu.com/p/89610466" target="_blank" rel="noopener">APISIX高性能实践续</a></em><br><em><a href="https://cloud.tencent.com/developer/article/1528618" target="_blank" rel="noopener">APISIX上手</a></em><br><em><a href="https://apisix.iresty.com/apisix/dashboard/#/schema/routes/list" target="_blank" rel="noopener">官方参考dashboard</a></em><br><em>目前只在Coentos 7上安装测试，Centos 6上需要升级gcc，要支持<code>GLIBC_2.14</code></em></p><a id="more"></a><h2 id="简介和安装"><a class="header-anchor" href="#简介和安装"></a>简介和安装</h2><h3 id="apisix安装"><a class="header-anchor" href="#apisix安装"></a>apisix安装</h3><p>直接看这个就可以了<a href="https://github.com/apache/apisix/blob/master/README_CN.md" target="_blank" rel="noopener"><strong>官方中文</strong></a><br>可能遇到问题：</p><ol><li>openresty libssl.so.1.1 not found<br><a href="https://www.cnblogs.com/emanlee/p/6100019.html" target="_blank" rel="noopener">升级openssl</a></li><li>需要注意的是，etcd的协议版本问题，需要支持2版本? <code>export ETCDCTL_API=2</code></li></ol><h3 id="APISIX-Dashboard安装"><a class="header-anchor" href="#APISIX-Dashboard安装"></a>APISIX Dashboard安装</h3><ol><li><p>安装前置环境：mysql，golang，nodejs(version &gt;=10.xx)</p></li><li><p>安装启用apisix</p></li><li><p>配置mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">输入你的密码和用户名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysql –uroot –p123456</span></span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> <span class="built_in">source</span> ./api/script/db/schema.sql</span></span><br></pre></td></tr></table></figure></li><li><p>编译运行后端程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd api &amp;&amp; go build -o ../manager-api . &amp;&amp; cd ..</span><br><span class="line">sh ./api/run/run.sh &amp;</span><br></pre></td></tr></table></figure></li><li><p>编译前端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm insert -g yarn</span><br><span class="line">yarn install</span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure></li><li><p>联合apisix使用</p><ol><li><p>将刚刚前端编译得到的<code>/dist</code>的内容，放到apisix下的dashboard文件夹</p></li><li><p>修改apisix脚本，添加如下服务：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vi ./bin/apisix</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen 10080;</span><br><span class="line">    # gzip config</span><br><span class="line">    gzip on; </span><br><span class="line">    gzip_min_length 1k; </span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;</span><br><span class="line">    gzip_vary on; </span><br><span class="line">    gzip_disable "MSIE [1-6]\.";</span><br><span class="line"></span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    include /usr/local/openresty/nginx/conf/mime.types;</span><br><span class="line"></span><br><span class="line">    location / &#123; </span><br><span class="line">        alias dashboard/;</span><br><span class="line"></span><br><span class="line">        try_files $uri $uri/index.html /index.html =404;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    location /apisix/admin &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:8080/apisix/admin;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重启apisix<code>./bin/apisix restart</code></p></li></ol></li><li><p>访问<code>http://192.168.81.128:10080/</code>ip根据自己而定。默认登录名<code>admin</code>密码<code>admin</code>，可以在dashboard的<code>conf.json</code>中自己修改。</p></li></ol><h2 id="APISIX的route匹配"><a class="header-anchor" href="#APISIX的route匹配"></a>APISIX的route匹配</h2><p>项目需要，了解下apisix的route匹配方式。<br>首先apisix的架构参考<a href="https://github.com/apache/apisix/blob/master/doc/zh-cn/architecture-design.md" target="_blank" rel="noopener">结构设计</a><br>apisix扩展匹配介绍<a href="https://github.com/apache/apisix/blob/master/doc/router-radixtree.md" target="_blank" rel="noopener">router-radixtree</a></p><h3 id="匹配原理和机制"><a class="header-anchor" href="#匹配原理和机制"></a>匹配原理和机制</h3><p>其核心的实现机制是使用了<code>resty.radixtree</code>这个lua库，<a href="https://github.com/api7/lua-resty-radixtree" target="_blank" rel="noopener">详情</a>。包括路由匹配，域名匹配，方法匹配等。说白，都是字符匹配。<br><code>route</code>匹配源码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">require</span> = <span class="built_in">require</span></span><br><span class="line"><span class="keyword">local</span> router = <span class="built_in">require</span>(<span class="string">"resty.radixtree"</span>)</span><br><span class="line"><span class="keyword">local</span> core = <span class="built_in">require</span>(<span class="string">"apisix.core"</span>)</span><br><span class="line"><span class="keyword">local</span> plugin = <span class="built_in">require</span>(<span class="string">"apisix.plugin"</span>)</span><br><span class="line"><span class="keyword">local</span> <span class="built_in">ipairs</span> = <span class="built_in">ipairs</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">type</span> = <span class="built_in">type</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">error</span> = <span class="built_in">error</span></span><br><span class="line"><span class="keyword">local</span> loadstring = loadstring</span><br><span class="line"><span class="keyword">local</span> user_routes</span><br><span class="line"><span class="keyword">local</span> cached_version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> _M = &#123;version = <span class="number">0.2</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> uri_routes = &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> uri_router</span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">create_radixtree_router</span><span class="params">(routes)</span></span></span><br><span class="line">    routes = routes <span class="keyword">or</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> api_routes = plugin.api_routes()</span><br><span class="line">    core.<span class="built_in">table</span>.clear(uri_routes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, route <span class="keyword">in</span> <span class="built_in">ipairs</span>(api_routes) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(route) == <span class="string">"table"</span> <span class="keyword">then</span></span><br><span class="line">            core.<span class="built_in">table</span>.<span class="built_in">insert</span>(uri_routes, &#123;</span><br><span class="line">                paths = route.uris <span class="keyword">or</span> route.uri,</span><br><span class="line">                methods = route.methods,</span><br><span class="line">                handler = route.handler,</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, route <span class="keyword">in</span> <span class="built_in">ipairs</span>(routes) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(route) == <span class="string">"table"</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> filter_fun, err</span><br><span class="line">            <span class="keyword">if</span> route.value.filter_func <span class="keyword">then</span></span><br><span class="line">                filter_fun, err = loadstring(</span><br><span class="line">                                        <span class="string">"return "</span> .. route.value.filter_func,</span><br><span class="line">                                        <span class="string">"router#"</span> .. route.value.id)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> filter_fun <span class="keyword">then</span></span><br><span class="line">                    core.<span class="built_in">log</span>.<span class="built_in">error</span>(<span class="string">"failed to load filter function: "</span>, err,</span><br><span class="line">                                   <span class="string">" route id: "</span>, route.value.id)</span><br><span class="line">                    <span class="keyword">goto</span> CONTINUE</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                filter_fun = filter_fun()</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            core.<span class="built_in">log</span>.info(<span class="string">"insert uri route: "</span>,</span><br><span class="line">                          core.json.delay_encode(route.value))</span><br><span class="line">            core.<span class="built_in">table</span>.<span class="built_in">insert</span>(uri_routes, &#123;</span><br><span class="line">                paths = route.value.uris <span class="keyword">or</span> route.value.uri,</span><br><span class="line">                methods = route.value.methods,</span><br><span class="line">                priority = route.value.priority,</span><br><span class="line">                hosts = route.value.hosts <span class="keyword">or</span> route.value.host,</span><br><span class="line">                remote_addrs = route.value.remote_addrs</span><br><span class="line">                               <span class="keyword">or</span> route.value.remote_addr,</span><br><span class="line">                vars = route.value.vars,</span><br><span class="line">                filter_fun = filter_fun,</span><br><span class="line">                <span class="comment">--主要处理函数，如果uri_router匹配上了，会调用这个headler</span></span><br><span class="line">                handler = <span class="function"><span class="keyword">function</span> <span class="params">(api_ctx)</span></span></span><br><span class="line">                    api_ctx.matched_params = <span class="literal">nil</span></span><br><span class="line">                    api_ctx.matched_route = route</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            ::CONTINUE::</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    core.<span class="built_in">log</span>.info(<span class="string">"route items: "</span>, core.json.delay_encode(uri_routes, <span class="literal">true</span>))</span><br><span class="line">    uri_router = router.new(uri_routes)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> match_opts = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.match</span><span class="params">(api_ctx)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cached_version <span class="keyword">or</span> cached_version ~= user_routes.conf_version <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 这里生成uri_router</span></span><br><span class="line">        create_radixtree_router(user_routes.values)</span><br><span class="line">        cached_version = user_routes.conf_version</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> uri_router <span class="keyword">then</span></span><br><span class="line">        core.<span class="built_in">log</span>.<span class="built_in">error</span>(<span class="string">"failed to fetch valid `uri` router: "</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    core.<span class="built_in">table</span>.clear(match_opts)</span><br><span class="line">    match_opts.method = api_ctx.var.request_method</span><br><span class="line">    match_opts.host = api_ctx.var.host</span><br><span class="line">    match_opts.remote_addr = api_ctx.var.remote_addr</span><br><span class="line">    match_opts.vars = api_ctx.var</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 这里是匹配核心</span></span><br><span class="line">    <span class="keyword">local</span> ok = uri_router:dispatch(api_ctx.var.uri, match_opts, api_ctx)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        core.<span class="built_in">log</span>.info(<span class="string">"not find any matched route"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.routes</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user_routes <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user_routes.values, user_routes.conf_version</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.init_worker</span><span class="params">(filter)</span></span></span><br><span class="line">    <span class="keyword">local</span> err</span><br><span class="line">    user_routes, err = core.<span class="built_in">config</span>.new(<span class="string">"/routes"</span>, &#123;</span><br><span class="line">            automatic = <span class="literal">true</span>,</span><br><span class="line">            item_schema = core.schema.route,</span><br><span class="line">            filter = filter,</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user_routes <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">error</span>(<span class="string">"failed to create etcd instance for fetching /routes : "</span> .. err)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure><p>而在访问过程中对这个调用方式如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--调用上述的match函数</span></span><br><span class="line">router.router_http.<span class="built_in">match</span>(api_ctx)</span><br><span class="line"><span class="comment">--判断匹配是否成功</span></span><br><span class="line"><span class="keyword">local</span> route = api_ctx.matched_route</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> route <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> core.response.<span class="built_in">exit</span>(<span class="number">404</span>,</span><br><span class="line">                    &#123;error_msg = <span class="string">"failed to match any routes"</span>&#125;)</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="resty-radixtree匹配原理"><a class="header-anchor" href="#resty-radixtree匹配原理"></a>resty.radixtree匹配原理</h4><p>主要分为两个部分，初始化注册<code>router</code>和运行时匹配过滤：<br><strong>初始化：</strong><br><img src="/2020/09/22/APISIX调研和使用/radixtree_init%E6%B5%81%E7%A8%8B%E5%9B%BE.drawio.png" alt></p><ol><li>数据存储和查找的主key都是uri，全量匹配使用hash，通用匹配使用的都是radixtree。数据结构都可以参考图中的表。</li><li>同一个uri有多个route的情况，会以数组的方式扩展，并且使用sort排序，排序顺序依据route中<code>priority</code>参数，越大优先级越高，越优先匹配。</li></ol><p><strong>运行时Match：</strong><br><img src="/2020/09/22/APISIX调研和使用/radixtree_match%E6%B5%81%E7%A8%8B%E5%9B%BE.drawio.png" alt></p><ol><li><p>调用<code>router:match(api_ctx.var.uri, match_opts, ...)</code>时，先使用<code>hash</code>来寻找相应的注册routes(routes在注册的时候，也是根据uri来进行hash表插入，如果hash表设置不能用，才使用radix_tree)。如果hash找不到，就使用<code>radix_tree</code>查找匹配(这部分是c代码，还没看)</p></li><li><p>如果都匹配成功，<code>dispatch</code>会调用<code>route</code>里加入的<code>handler</code>。而<code>match</code>函数会返回<code>metadata</code></p></li><li><p>自定义函数方面，在定义route的时候，自定义<code>filter_fun</code>函数，进行匹配过滤的时候，就会调用<code>filter_fun</code>调用。类似示例如下：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">=== TEST 1: sanity</span><br><span class="line">--- config</span><br><span class="line">    location /t &#123;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            local radix = require("resty.radixtree")</span><br><span class="line">            local rx = radix.new(&#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    paths = "/aa",</span><br><span class="line">                    metadata = "metadata /aa",</span><br><span class="line">                    filter_fun = function(vars)</span><br><span class="line">                        ngx.log(ngx.WARN, "start to filter")</span><br><span class="line">                        return vars['arg_k'] == 'v'</span><br><span class="line">                    end</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            ngx.say(rx:match("/aa", &#123;vars = ngx.var&#125;))</span><br><span class="line">            ngx.say(rx:match("/aa", &#123;&#125;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">--- request</span><br><span class="line">GET /t?k=v</span><br><span class="line">--- no_error_log</span><br><span class="line">[error]</span><br><span class="line">--- error_log</span><br><span class="line">start to filter</span><br><span class="line">--- response_body</span><br><span class="line">metadata /aa</span><br><span class="line">metadata /aa</span><br></pre></td></tr></table></figure></li><li><p>对于自定义变量的读取，比如有header，args和cookie里分别有个stub；nginx.var可以分别通过’http_'，'arg_'和’cookie_'直接读取相应的变量：<br>nginx配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">access_by_lua_block &#123;</span><br><span class="line">     ngx.say("nnnnnnnnngxxxxxxx say:")</span><br><span class="line">     ngx.say(ngx.var['http_stub'])</span><br><span class="line">     ngx.say(ngx.var['arg_stub'])</span><br><span class="line">     ngx.say(ngx.var['cookie_stub'])</span><br><span class="line">     apisix.http_access_phase()</span><br><span class="line"> &#125;   </span><br><span class="line"><span class="meta"> $</span><span class="bash"> curl -H <span class="string">'stub:cloudxx'</span> --cookie <span class="string">"stub=cccccookie"</span> http://192.168.81.128:9080/args/?stub=arrrrg</span></span><br><span class="line"> nnnnnnnnngxxxxxxx say:</span><br><span class="line"> cloudxx</span><br><span class="line"> arrrrg</span><br><span class="line"> cccccookie</span><br><span class="line"> &#123;"error_msg":"failed to match any routes"&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="route匹配成功后server或upstream流程"><a class="header-anchor" href="#route匹配成功后server或upstream流程"></a>route匹配成功后server或upstream流程</h3><p>首先，在route的配置中，<code>plugins</code>、<code>script</code>、<code>upstream/upstream_id</code>、<code>service_id</code>至少选择一个<br>当route匹配成功后会相应执行<code>plugins</code>…(目前猜测是根据优先级)<br>server最后关联的也是upstream，那么主要的还是介绍upstream的外发：<br>在route匹配成功后，会进行server_id和upstream_id的检查，如果有，就将相应的upstream结构赋值到<code>api_ctx.upstream_conf</code>，如果只有一个node，那么可以直接赋值相应的<code>upstream_host</code>，进行负载平衡，负载平衡特点：</p><ol><li>动态支持有权重的 round-robin 负载平衡</li><li>动态支持一致性 hash 的负载均衡。</li><li>启用上游节点的健康检查，将在负载均衡期间自动过滤不健康的节点，以确保系统稳定性。</li><li>可以在 balancer 阶段使用自定义负载均衡算法。</li></ol><h2 id="性能"><a class="header-anchor" href="#性能"></a>性能</h2><h3 id="route匹配性能"><a class="header-anchor" href="#route匹配性能"></a>route匹配性能</h3><p><a href="https://github.com/api7/lua-resty-radixtree" target="_blank" rel="noopener">lua-resty-radixtree</a><br>We wrote some simple benchmark scripts. Machine environment: MacBook Pro (16-inch, 2019), CPU 2.3 GHz Intel Core i9.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc -O2 -g -Wall -fpic -std=c99 -Wno-pointer-to-int-cast -Wno-int-to-pointer-cast -DBUILDING_SO -c src/rax.c -o src/rax.o</span><br><span class="line">cc -O2 -g -Wall -fpic -std=c99 -Wno-pointer-to-int-cast -Wno-int-to-pointer-cast -DBUILDING_SO -c src/easy_rax.c -o src/easy_rax.o</span><br><span class="line">cc -shared -fvisibility=hidden src/rax.o src/easy_rax.o -o librestyradixtree.so</span><br><span class="line"></span><br><span class="line">$ make bench</span><br><span class="line">resty -I=./lib -I=./deps/share/lua/5.1 benchmark/match-parameter.lua</span><br><span class="line">matched res: 1</span><br><span class="line">route count: 100000</span><br><span class="line">match times: 10000000</span><br><span class="line">time used  : 3.3849999904633 sec</span><br><span class="line">QPS        : 2954209</span><br><span class="line">each time  : 0.33849999904633 ns</span><br><span class="line"></span><br><span class="line">resty -I=./lib -I=./deps/share/lua/5.1 benchmark/match-prefix.lua</span><br><span class="line">matched res: 500</span><br><span class="line">route count: 100000</span><br><span class="line">match times: 1000000</span><br><span class="line">time used  : 0.4229998588562 sec</span><br><span class="line">QPS        : 2364066</span><br><span class="line"></span><br><span class="line">resty -I=./lib -I=./deps/share/lua/5.1 benchmark/match-static.lua</span><br><span class="line">matched res: 500</span><br><span class="line">route count: 100000</span><br><span class="line">match times: 10000000</span><br><span class="line">time used  : 0.78799986839294 sec</span><br><span class="line">QPS        : 12690357</span><br><span class="line"></span><br><span class="line">resty -I=./lib -I=./deps/share/lua/5.1 benchmark/match-hosts.lua</span><br><span class="line">matched res: 500</span><br><span class="line">route count: 1000</span><br><span class="line">match times: 100000</span><br><span class="line">time used  : 1.6989998817444 sec</span><br><span class="line">QPS        : 58858</span><br><span class="line"></span><br><span class="line">resty -I=./lib -I=./deps/share/lua/5.1 benchmark/match-wildcard-hosts.lua</span><br><span class="line">matched res: 500</span><br><span class="line">route count: 1000</span><br><span class="line">match times: 50000</span><br><span class="line">time used  : 1.2469999790192 sec</span><br><span class="line">QPS        : 40096</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Netfilter介绍及其实现原理</title>
      <link href="/2020/09/14/Netfilter%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2020/09/14/Netfilter%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>工作需要，了解了一下Net filter的工作原理。(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em>源码的版本：linux-3.10.0-1127.18.2.el7 (centos)</em></p><a id="more"></a><p><a href="https://www.ibm.com/developerworks/cn/linux/network/s-netip/index.html" target="_blank" rel="noopener">简介</a></p><p><em>包含netfilter的基本介绍，iptables规则介绍及使用，netfilter实现原理，自定义match实现，链接跟踪实现、ipset和iptables联动和ipset实现</em></p><h2 id="简介"><a class="header-anchor" href="#简介"></a>简介</h2><p><strong>Netfilter</strong>，在Linux内核中的一个软件框架，用于管理网络数据包。不仅具有网络地址转换（NAT）的功能，也具备数据包内容修改、以及数据包过滤等防火墙功能。利用运作于用户空间的应用软件，如<code>iptables</code>、<code>ebtables</code>和<code>arptables</code>等，来控制Netfilter，系统管理者可以管理通过Linux操作系统的各种网络数据包。<br><strong>iptables：</strong><br>Netfilter中最为常用的一种网络数据包过滤方式——IP包过滤，我们也将重点介绍这种过滤方式。用户在使用<code>iptables</code>时需要超级用户权限，以及内核模块需要<code>Xtables</code>模块做支撑。iptables只能处理ipv4，对应的ipv6则使ip6tables来处理。<br><strong>ebtables</strong><br>ebtables 是以太网桥防火墙，以太网桥工作在数据链路层，ebtables 主要用来过滤数据链路层数据包。使用 ebtables 可以实现 filtering 、NAT 和 brouting。过滤根据 MAC 头包括 VLAN ID 等信息确定是否丢弃该帧。MAC NAT 可以修改 MAC 源和目的地址。Brouting 意为 bridge or route，根据规则确定应该将数据帧路由给上层（iptables）还是通过网桥转给其它的接口。<br>ebtables 和我们熟悉的 iptables 很像，也有规则（rules）、链（chains）和表（tables）的概念。ebtables 使用规则确定应当对数据帧执行什么动作。规则按照不同的链分组，不同的表中包含不同的链。在 ebtables 中有三张表：filter、nat 和 broute，分别对应其三大功能模块。<br>需要注意的是如果一个以太网接口 eth1，它并没有桥接到网桥上，此时，从 eth1 进来的数据包不会走到 ebtables 中。在 bridge check 点，会检查数据包进入的接口是否属于某个桥，如果是则走 ebtables，否则直接走 iptables。也就是说，ebtables 只对桥接网络生效。<br><strong>arptables</strong><br>arptables 是运行在用户空间的应用软件，通过控制Linux内核netfilter模块，来管理地址解析协议(arp)数据包的过滤和转发。<br>arptables基于iptables开发，使用时也与iptables有些类似，都有“表（tables）”、“链（chain）”和“规则（rules）”三个层面。<br>但是arptables功能较单一，仅有filter一个表。并且，也只有INPUT（从内核2.4版）、OUTPUT（从内核2.4版）和FORWARD（从内核2.6版）三个内建链。arptables的主要用途之一是防范ARP欺骗。</p><h3 id="基础结构"><a class="header-anchor" href="#基础结构"></a>基础结构</h3><p><strong>Netfilter</strong> 包含了一组内核钩子 API ，周边内核组件可以使用这些钩子在网络栈中注册回调函数。每一个在网络栈中流通的包到达相应的钩子时，就会触发相应的回调函数，从而能够完成包过滤、网络地址（端口）转换和网络包协议头修改等各种操作。<br>Netfilter 提供了五种钩子：<br><img src="/2020/09/14/Netfilter介绍及其实现原理/Netfilter%20hooks.png" alt="Netfilter hook"></p><ol><li><code>NF_IP_PER_ROUNTING</code> — 当数据包到达计算机立即触发。</li><li><code>NF_IP_LOCAL_IN</code> — 当数据包的目的地就是当前计算机时触发。</li><li><code>NF_IP_FORWARD</code> — 当数据包目的地址是其它的网络接口时触发。</li><li><code>NF_IP_POST_ROUTING</code> — 当数据包即将从计算机发出时触发。</li><li><code>NF_IP_LOCAL_OUT</code> — 当数据包由本地生成并发向外部时触发。</li></ol><p>基于 Netfilter 钩子 API 实现的内核模块主要有 ebtables、arptables、ip(6)tables、nf_tables、NAT、connection tracking 等。如下架构图：<br><img src="/2020/09/14/Netfilter介绍及其实现原理/Netfilter%E6%9E%B6%E6%9E%84.png" alt="Netfilter"></p><p>而数据包在整个Netfilter中的数据流如下图：<br><img src="/2020/09/14/Netfilter介绍及其实现原理/1920px-Netfilter-packet-flow.png" alt="网络数据包流"></p><h3 id="建立规则和链"><a class="header-anchor" href="#建立规则和链"></a>建立规则和链</h3><p>通过向防火墙提供有关对来自某个源、到某个目的地或具有特定协议类型的信息包要做些什么的指令，规则控制信息包的过滤。 通过使用 netfilter/iptables 系统提供的特殊命令 iptables ，建立这些规则，并将其添加到内核空间的特定信息包过滤表内的链中。关于添加／除去／编辑规则的命令的一般语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t table] command [match] [target]</span><br></pre></td></tr></table></figure><h4 id="用法"><a class="header-anchor" href="#用法"></a>用法</h4><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-A --append</td><td>将一个或多个规则添加到所选链的末尾。</td></tr><tr><td>-C --check</td><td>检查与所选链中的规范匹配的规则。</td></tr><tr><td>-D --delete</td><td>从所选链中删除一个或多个规则。</td></tr><tr><td>-F --flush</td><td>逐个删除所有规则。</td></tr><tr><td>-I --insert</td><td>将一个或多个规则作为给定的规则编号插入所选链中。</td></tr><tr><td>-L --list</td><td>显示所选链中的规则。</td></tr><tr><td>-n --numeric</td><td>以数字格式显示IP地址或主机名和邮政编号。</td></tr><tr><td>-N --new-chain <name></name></td><td>创建一个新的用户定义链。</td></tr><tr><td>-v --verbose</td><td>与list选项一起使用时提供更多信息。</td></tr><tr><td>-X --delete-chain <name></name></td><td>删除用户定义的链。</td></tr></tbody></table><h4 id="示例"><a class="header-anchor" href="#示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 列出对应规则</span><br><span class="line">iptables -nL</span><br><span class="line">iptables -t nat -nL</span><br><span class="line">// 列出对应规则的添加命令</span><br><span class="line">iptables -S</span><br><span class="line">// 删除规则</span><br><span class="line">iptables -F</span><br><span class="line">iptables –flush</span><br><span class="line">//设置链的默认策略</span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">//指定IP源和网卡丢弃</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp -s 192.168.100.1 -j DROP</span><br><span class="line">//指定IP源和网卡tcp拒绝</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp -s 192.168.100.1 -j REJECT --reject-with tcp-reset</span><br><span class="line">//拒绝所有的udp包</span><br><span class="line">iptables -A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable</span><br><span class="line">//仅允许来自于192.168.100.0/24域的用户的ssh连接请求</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp -s 192.168.100.0/24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">//端口转发</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -d 192.168.102.37 --dport 422 -j DNAT --to 192.168.102.37:22</span><br><span class="line">//允许多端口访问，也支持端口段：22-443</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp -m multiport --dports 22,80,443 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">//标准port段支持：</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22:443 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">// ip段匹配支持</span><br><span class="line">iptables -A INPUT -m iprange --src-range 192.168.80.109-192.168.80.121 -j DROP</span><br><span class="line">//使用iptables nth将HTTPS流量负载平衡至两个不同的ip地址。</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 8000 -m state --state NEW -m statistic --mode nth --every 2 --packet 0 -j DNAT --to-destination 192.168.17.33:8001</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 8000 -m state --state NEW -m statistic --mode nth --every 2 --packet 1 -j DNAT --to-destination 192.168.17.33:8002</span><br><span class="line">//防火墙服务器上的其中一个网卡连接到外部，另一个网卡连接到内部服务器，使用以下规则允许内部网络与外部网络的通信。此例中，eth1连接到外部网络(互联网)，eth0连接到内部网络(例如:192.168.1.x)。</span><br><span class="line">iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT</span><br><span class="line">//按流量匹配ping次数。（--limit 10/minute表示一分钟产生10个令牌即6秒一个，--limit-burst 5表示令牌桶最多可以放5个令牌，此项默认值就是5。即实现了平均值(--limit)和峰值(--limit-burst)约束）</span><br><span class="line">iptables -I INPUT 1 -p icmp -m limit --limit 10/minute --limit-burst 5 -j ACCEPT</span><br><span class="line">//记录丢弃的数据表</span><br><span class="line">iptables -N LOGGING</span><br><span class="line">iptables -A INPUT -i eth0 -p tcp -s 10.92.2.188 -j LOGGING</span><br><span class="line">iptables -A LOGGING -m limit --limit 2/min -j LOG --log-prefix &quot;IPTables Packet Dropped: &quot; --log-level 4</span><br><span class="line">iptables -A LOGGING -j DROP</span><br><span class="line">cat /var/log/messages | grep IPTables #(centos) 根据syslog的配置来确定位置。</span><br></pre></td></tr></table></figure><h4 id="跟踪iptables规则匹配"><a class="header-anchor" href="#跟踪iptables规则匹配"></a>跟踪iptables规则匹配</h4><p>这里有两种方式跟踪一个包匹配了哪些规则。<a href="https://blog.csdn.net/pgn999/article/details/82796570" target="_blank" rel="noopener">参考</a></p><ol><li>跟踪计数器<br>观察<code>iptables -nvL INPUT</code>返回的第一列pkts是否增长了，可以简单的判断规则被匹配。</li><li>可以在iptables规则前后添加日志，通过观察日志来跟踪规则<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  #添加日志记录在INPUT第一个规则，并且设置日志前缀为 IPTABLES LOG:</span><br><span class="line">iptables -I INPUT -j LOG --log-prefix &quot;IPTABLES LOG: &quot;</span><br><span class="line">#查看日志, 这里可能会出现消息延迟的问题。</span><br><span class="line">dmesg|grep &quot;IPTABLES LOG:&quot;</span><br></pre></td></tr></table></figure></li></ol><h2 id="规则构成"><a class="header-anchor" href="#规则构成"></a>规则构成</h2><p>在我们执行一个iptables命令的时候，往往达到的效果，就是在某个表的某个链中添加某一条规则。而参与这条规则构成的包括表(table)、链（chain）、匹配(match)和目标（target）。下面将详细介绍这几个部分。</p><h3 id="表-table"><a class="header-anchor" href="#表-table"></a>表(table)</h3><p>iptables里包含了4张表，分别是filter、nat、mangle和raw表。而表的作用在于存放规则，比如我们平时执行<code>iptables -nL</code>会得到类似的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:80</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure><p>(policy XXX)表示着默认策略。表中包含的链，表示着表里的规则可生效的链范围。表和链有着如下关系：<br><img src="/2020/09/14/Netfilter介绍及其实现原理/iptables-%E8%A1%A8%E5%92%8C%E9%93%BE.png" alt="iptables的表和链"></p><h3 id="链-chain"><a class="header-anchor" href="#链-chain"></a>链(chain)</h3><p>如果表是存放规则的地方，而链就是决定规则执行的时机，iptables中的5条链PREROUTING、INPUT、OUTPUT、FORWARD和POSTROUTING。而执行的位置也在简介中的netfilter hook原理中给出了。链把相应的表按照一定的顺序串起来，找出表里对应的规则进行执行。<br><img src="/2020/09/14/Netfilter介绍及其实现原理/%5Biptables-%E9%93%BE%E5%92%8C%E8%A1%A8.png" alt="iptables-链和表"></p><h3 id="匹配-match"><a class="header-anchor" href="#匹配-match"></a>匹配(match)</h3><p><code>-m</code>或<code>--match</code>命令所做的工作，当然这部分我们称为扩展匹配，<code>-s -i</code>所执行的也是匹配工作，称为通用匹配。<br><strong>通用匹配</strong><br>类似<code>-s</code>这类的通用匹配，通常在用户态代码，和内核代码都包含了，不需要额外加载module。在iptables规则下发里，也是属于附加的基本参数。<br><strong>扩展匹配</strong><br>首先，我们在使用扩展匹配的时候，可以使用帮助文档：<code>iptables -m the_match_you_want --help</code>。扩展模块要工作的时候，都需要进行模块匹配，用户态匹配对应的libipt_xxx或libxt_xxx。内核态匹配对应的xt_xxx。比如我们使用的<code>-m state</code>在iptables命令执行时，会找<code>libxt_state.so</code>的动态库，规则下发到内核的时候，内核会找对应的<code>xt_state.ko</code>模块。具体源码实现后续会说明。<br>如果想自定义扩展匹配，那么需要写内核模块代码(参考内核模块源码的xt_multiport.c)和用户态模块代码(参考libxt_multiport.c)以及定义的头文件(参考xt_multiport.h)</p><h3 id="目标-target"><a class="header-anchor" href="#目标-target"></a>目标(target)</h3><p><code>-j</code>所做的工作，在包匹配成功后，就会执行<code>-j</code>后面的动作，来对包进行处理。</p><h4 id="通用目标"><a class="header-anchor" href="#通用目标"></a>通用目标</h4><p><code>DROP</code>,<code>ACCEPT</code>,<code>QUEUE</code>和<code>RETURN</code>这几个属于通用匹配，他们同样以模块的形式进行加载和工作，对应的模块是<code>standard</code></p><h4 id="扩展目标"><a class="header-anchor" href="#扩展目标"></a>扩展目标</h4><p>扩展目标和扩展匹配也是相似的工作原理，都是进行模块加载。如果要写自定义模块，需要内核模块代码(参考xt_LOG.c)和用户态模块代码(参考libipt_LOG.c)和头文件(参考xt_LOG.h)</p><h2 id="Netfilter源码实现"><a class="header-anchor" href="#Netfilter源码实现"></a>Netfilter源码实现</h2><p>Netfilter的整体工作方式类似下图：<br><img src="/2020/09/14/Netfilter介绍及其实现原理/iptables%E5%86%85%E6%A0%B8%E9%80%9A%E4%BF%A1.jpg" alt></p><h3 id="基本数据结构"><a class="header-anchor" href="#基本数据结构"></a>基本数据结构</h3><p>由于本人也没有精读源码，所以也只能介绍个大概，一切以源码为准。<br><strong>xt_table与xt_table_info</strong><br>xt_table是Netfilter的核心数据结构，它包含了每个表的所有规则信息，以及匹配处理方法。数据包进入Netfilter后通过查表，匹配相应的规则来决定对数据包的处理结果。下面是xt_table的完整定义（在X_tables.h中）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_table</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* What hooks you will enter on */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> valid_hooks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Man behind the curtain... */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> *<span class="title">private</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set this to THIS_MODULE if you are a module, otherwise NULL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">me</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">u_int8_t</span> af;      <span class="comment">/* address/protocol family */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> priority;     <span class="comment">/* hook order */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A unique name... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> name[XT_TABLE_MAXNAMELEN];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个成员意思见上文定义中的注释，个别成员说明如下：<br>valid_hooks：所支持的hook点类型，决定后续注册hook操作的位置。比如filter表的valid_hoos被指定为：(1 &lt;&lt; NF_INET_LOCAL_IN) | (1 &lt;&lt; NF_INET_FORWARD) | (1 &lt;&lt; NF_INET_LOCAL_OUT))，即在NF_INET_LOCAL_IN、NF_INET_FORWARD、NF_INET_LOCAL_OUT三处注册hook操作；<br>private：xt_table的数据区，包含了所有规则和规则处理方法等信息。xt_table_info详细信息见下文。</p><p>xt_table的所有数据都存在private的成员变量中，private是结构体struct xt_table_info，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Size per table */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of entries: FIXME. --RR */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initial number of entries. Needed for module usage count */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> initial_entries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Entry points and underflows */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hook_entry[NF_INET_NUMHOOKS];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> underflow[NF_INET_NUMHOOKS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Number of user chains. Since tables cannot have loops, at most</span></span><br><span class="line"><span class="comment">     * @stacksize jumps (number of user chains) can possibly be made.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> stacksize;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __percpu *stackptr;</span><br><span class="line">    <span class="keyword">void</span> ***jumpstack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ipt_entry tables: one per CPU */</span></span><br><span class="line">    <span class="comment">/* Note : this field MUST be the last one, see XT_TABLE_INFO_SZ */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *entries[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重要成员说明：<br>hook_entry: 不同hook点的规则的偏移量；<br>entries： 规则存储的入口，为可变区域，必须放在结构末尾。entries本质上是ipt_entry结构。关于ipt_entry定义和成员介绍见下文。</p><p><strong>ipt_entry</strong><br>ipt_entry结构是对规则的描述，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This structure defines each of the firewall rules.  Consists of 3</span></span><br><span class="line"><span class="comment">   parts which are 1) general IP header stuff 2) match specific</span></span><br><span class="line"><span class="comment">   stuff 3) the target to perform if the rule matches */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipt_ip</span> <span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark with fields that we care about. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nfcache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Size of ipt_entry + matches */</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> target_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Size of ipt_entry + matches + target */</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> next_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Back pointer */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> comefrom;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Packet and byte counters. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xt_counters</span> <span class="title">counters</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The matches (if any), then the target. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> elems[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员elems中，保存了一条规则的所有匹配（matchs），以及匹配后的处理操作（target）。在Iptables.c中，generate_entry（）方法新建一个ipt_entry，可以看到如何将matchs和target添加到ipt_entry中的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> *</span></span><br><span class="line"><span class="class"><span class="title">generate_entry</span>(<span class="title">const</span> <span class="title">struct</span> <span class="title">ipt_entry</span> *<span class="title">fw</span>,</span></span><br><span class="line"><span class="class">           <span class="title">struct</span> <span class="title">xtables_rule_match</span> *<span class="title">matches</span>,</span></span><br><span class="line"><span class="class">           <span class="title">struct</span> <span class="title">ipt_entry_target</span> *<span class="title">target</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xtables_rule_match</span> *<span class="title">matchp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    size = <span class="keyword">sizeof</span>(struct ipt_entry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (matchp = matches; matchp; matchp = matchp-&gt;next)</span><br><span class="line">       size += matchp-&gt;match-&gt;m-&gt;u.match_size;</span><br><span class="line"></span><br><span class="line">    e = xtables_malloc(size + target-&gt;u.target_size);</span><br><span class="line">    *e = *fw;</span><br><span class="line">    e-&gt;target_offset = size;</span><br><span class="line">    e-&gt;next_offset = size + target-&gt;u.target_size;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (matchp = matches; matchp; matchp = matchp-&gt;next) &#123;</span><br><span class="line">       <span class="built_in">memcpy</span>(e-&gt;elems + size, matchp-&gt;match-&gt;m, matchp-&gt;match-&gt;m-&gt;u.match_size);</span><br><span class="line">       size += matchp-&gt;match-&gt;m-&gt;u.match_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(e-&gt;elems + size, target, target-&gt;u.target_size);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>见上文的程序片段，ipt_entry的空间占用为：ipt_entry结构自身的size，加之所有match的size总和，加之target的size。填写elems时，首先将所有的match依次拷贝到elems指向的存储位置，紧接着将target拷贝到其后。下图是ipt_entry存储示意图：<br><img src="/2020/09/14/Netfilter介绍及其实现原理/ipt_entry%E5%AD%98%E5%82%A8%E5%88%86%E5%B8%83%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt></p><p><strong>nf_hook_ops</strong><br>nf_hook_ops用于注册一个hook操作，它主要包含了hook操作执行函数、hook类型，以及优先级。我们可以认为，一个nf_hook_ops表征了一个表的一条链，因为它与一个表的一个hook类型唯一对应。其完整定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* User fills in from here down. */</span></span><br><span class="line">    nf_hookfn *hook;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">u_int8_t</span> pf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hooknum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hooks are ordered in ascending priority. */</span></span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重要成员说明：<br>hook：hook操作函数；<br>owner：所属的表；<br>hooknum：hook类型；<br>priority：优先级，决定同一hook点，链（不同表在同一个hook点的链）的执行次序。</p><p><strong>ipt_replace</strong><br>结构主要用于iptables的规则下发，在setsockopt进行规则下发时以此结构体作为传输数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The argument to IPT_SO_SET_REPLACE. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipt_replace</span> &#123;</span></span><br><span class="line"><span class="comment">/* Which table. */</span></span><br><span class="line"><span class="keyword">char</span> name[XT_TABLE_MAXNAMELEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Which hook entry points are valid: bitmask.  You can't</span></span><br><span class="line"><span class="comment">           change this. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> valid_hooks;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Number of entries */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Total size of new entries */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hook entry points. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> hook_entry[NF_INET_NUMHOOKS];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Underflow points. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> underflow[NF_INET_NUMHOOKS];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Information about old entries: */</span></span><br><span class="line"><span class="comment">/* Number of counters (must be equal to current number of entries). */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_counters;</span><br><span class="line"><span class="comment">/* The old entries' counters. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_counters</span> *<span class="title">counters</span>;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* The entries (hang off end: not really an array). */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> <span class="title">entries</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重要成员说明：<br>entries：对应的扩展matches和target的数据集合，其组成方式就是上面对应ip_entry的介绍。</p><h3 id="Netfilter内部数据包处理"><a class="header-anchor" href="#Netfilter内部数据包处理"></a>Netfilter内部数据包处理</h3><p>在简介中已经提到了netfilter的hook机制和hook点，现在我们来了解下具体流程。<br>首先，内核在收到ip包后，会进行一系列的操作，而hook的位置如下：<br><img src="/2020/09/14/Netfilter介绍及其实现原理/ip%E6%8A%A5%E6%96%87hook%E7%82%B9.drawio.png" alt><br>当我们对应的hook点有相应的注册函数时，就会进行相应的注册的hook函数调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Deliver IP Packets to the higher protocol layers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ip_local_deliver</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Reassemble IP fragments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ip_is_fragment(ip_hdr(skb))) &#123;</span><br><span class="line"><span class="keyword">if</span> (ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN, <span class="literal">NULL</span>, skb,</span><br><span class="line">       skb-&gt;dev, <span class="literal">NULL</span>,</span><br><span class="line">       ip_local_deliver_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>ip_input.c</em><br>而实际的hook处理流程如下：<br><img src="/2020/09/14/Netfilter介绍及其实现原理/Netfilter%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E5%8C%85%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.drawio.png" alt><br>这里主要的实现函数<code>nf_hook_slow</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nf_hook_slow</span><span class="params">(struct sk_buff *skb, struct nf_hook_state *state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> *<span class="title">elem</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> verdict;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We may already have this, but read-locks nest anyway */</span></span><br><span class="line">rcu_read_lock();</span><br><span class="line"></span><br><span class="line">elem = list_entry_rcu(&amp;nf_hooks[state-&gt;pf][state-&gt;hook],</span><br><span class="line">      struct nf_hook_ops, <span class="built_in">list</span>);</span><br><span class="line">next_hook:</span><br><span class="line">verdict = nf_iterate(&amp;nf_hooks[state-&gt;pf][state-&gt;hook], skb, state,</span><br><span class="line">     &amp;elem);</span><br><span class="line"><span class="keyword">if</span> (verdict == NF_ACCEPT || verdict == NF_STOP) &#123;</span><br><span class="line">ret = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((verdict &amp; NF_VERDICT_MASK) == NF_DROP) &#123;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">ret = NF_DROP_GETERR(verdict);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = -EPERM;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((verdict &amp; NF_VERDICT_MASK) == NF_QUEUE) &#123;</span><br><span class="line"><span class="keyword">int</span> err = nf_queue(skb, elem, state,</span><br><span class="line">   verdict &gt;&gt; NF_VERDICT_QBITS);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (err == -ECANCELED)</span><br><span class="line"><span class="keyword">goto</span> next_hook;</span><br><span class="line"><span class="keyword">if</span> (err == -ESRCH &amp;&amp;</span><br><span class="line">   (verdict &amp; NF_VERDICT_FLAG_QUEUE_BYPASS))</span><br><span class="line"><span class="keyword">goto</span> next_hook;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>nf_hooks[state-&gt;pf][state-&gt;hook]</code>中，<code>state-&gt;pf</code>是对应的协议，比如<code>NFPROTO_IPV4</code>, <code>state-&gt;hook</code>表示hook的点，比如<code>NF_INET_LOCAL_IN</code>。而nf_hooks是一个全局变量，包含了所有的注册hook。<br>在进入到<code>ipt_do_table</code>函数后，会进行包的匹配和处理，流程如下：<br><img src="/2020/09/14/Netfilter介绍及其实现原理/netfilter%E5%8C%85%E8%BF%87%E6%BB%A4.drawio.png" alt><br><code>ipt_do_table</code>会先匹配基本match，再匹配扩展match，匹配成功后，进行基础target或扩展target的处理。如果匹配不成功，则会一直匹配直到所有matches匹配完。这也导致了iptables规则在命中一条规则后，后续的规则都不会再进行匹配了(除非你target指向其他链)。<br>内部数据包处理大概如上所说，但是我们仍然抱有疑惑，hook函数哪里来？扩展match怎么生效等。这就要归功于netfilter的注册机制。</p><h3 id="Netfilter模块注册"><a class="header-anchor" href="#Netfilter模块注册"></a>Netfilter模块注册</h3><p>模块注册的时机是在模块加载的时候，而模块加载分系统启动时加载，即系统启动时加载netfilter以及编译到内核的模块。<br>而没有编译到内核，而是以独立模块存在的netfilter模块，则会在规则下发的时候，会根据你传入的match或target名称到对应的路径下寻找，并载入模块。<br>netfilter在设计的时候，就设计了强大的模块加载机制，因此也表现出强大的扩展性。<br><img src="/2020/09/14/Netfilter介绍及其实现原理/Netfilter%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt><br>本质上，模块加载结构都是相似的。我们就以<code>iptable_filter.c</code>为例，讲解一下hook的注册过程。<br><img src="/2020/09/14/Netfilter介绍及其实现原理/netfilter%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B.drawio.png" alt><br>对应的部分<code>iptable_filter.c</code>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_table</span> <span class="title">packet_filter</span> = &#123;</span></span><br><span class="line">.name= <span class="string">"filter"</span>,</span><br><span class="line">.valid_hooks= FILTER_VALID_HOOKS,</span><br><span class="line">.me= THIS_MODULE,</span><br><span class="line">.af= NFPROTO_IPV4,</span><br><span class="line">.priority= NF_IP_PRI_FILTER,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">iptable_filter_hook(<span class="keyword">const</span> struct nf_hook_ops *ops, struct sk_buff *skb,</span><br><span class="line">    <span class="keyword">const</span> struct net_device *in, <span class="keyword">const</span> struct net_device *out,</span><br><span class="line">    <span class="keyword">const</span> struct nf_hook_state *state)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ops-&gt;hooknum == NF_INET_LOCAL_OUT &amp;&amp;</span><br><span class="line">    (skb-&gt;len &lt; <span class="keyword">sizeof</span>(struct iphdr) ||</span><br><span class="line">     ip_hdrlen(skb) &lt; <span class="keyword">sizeof</span>(struct iphdr)))</span><br><span class="line"><span class="comment">/* root is playing with raw sockets. */</span></span><br><span class="line"><span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line"></span><br><span class="line">net = dev_net(state-&gt;in ? state-&gt;in : state-&gt;out);</span><br><span class="line"><span class="keyword">return</span> ipt_do_table(skb, ops-&gt;hooknum, state, net-&gt;ipv4.iptable_filter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">iptable_filter_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = register_pernet_subsys(&amp;iptable_filter_net_ops);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register hooks */</span></span><br><span class="line">filter_ops = xt_hook_link(&amp;packet_filter, iptable_filter_hook);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(filter_ops)) &#123;</span><br><span class="line">ret = PTR_ERR(filter_ops);</span><br><span class="line">unregister_pernet_subsys(&amp;iptable_filter_net_ops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">iptable_filter_fini</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">xt_hook_unlink(&amp;packet_filter, filter_ops);</span><br><span class="line">unregister_pernet_subsys(&amp;iptable_filter_net_ops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(iptable_filter_init);</span><br><span class="line">module_exit(iptable_filter_fini);</span><br></pre></td></tr></table></figure><p>netfilter注册的逻辑依赖内核模块注册。内核模块加载的时候，会自动调用module_init，在iptable_filter中，调用<code>iptable_filter_init</code>，执行<code>xt_hook_link</code>函数，将<code>packet_filter</code>全局量挂载到<code>nf_hooks</code>全局量。实际包过滤的时候，就会根据<code>nf_hooks</code>来调用注册的hook。<br>以上就是hook的注册过程，实际在看源码中，match和target等注册过程也是类似的，通过module_init将模块文件的变量注册到全局量中。</p><h3 id="iptables规则下发"><a class="header-anchor" href="#iptables规则下发"></a>iptables规则下发</h3><p>内核空间与用户空间的数据交互通过getsockopt和setsockopt来完成，这个两个函数用来控制相关socket文件描述符的的选项值。先来看这两个函数的原型：<br>set/getsockopt(2)函数的基本使用格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int setsockopt(int sockfd, int proto, int cmd, void *data, int datalen)</span><br><span class="line">int getsockopt(int sockfd, int proto, int cmd, void *data, int datalen)</span><br></pre></td></tr></table></figure><p>在调用<code>setsockopt</code>函数时，实际执行的流程如下：<br><img src="/2020/09/14/Netfilter介绍及其实现原理/%E8%A7%84%E5%88%99%E6%8F%90%E4%BA%A4%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt><br>上图中，从setsockopt()到ip_setsockopt()是常规的setsockopt调用流程；在新的流程中，Netfilter加入的自己的处理函数nf_setsockopt()。<br><img src="/2020/09/14/Netfilter介绍及其实现原理/setsockopt%E6%B5%81%E7%A8%8B%E5%9B%BE.drawio.png" alt><br>上图中，核心函数<code>do_replace</code>，进行的数据拷贝传输，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">do_replace(struct net *net, <span class="keyword">const</span> <span class="keyword">void</span> __user *user, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipt_replace</span> <span class="title">tmp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_table_info</span> *<span class="title">newinfo</span>;</span></span><br><span class="line"><span class="keyword">void</span> *loc_cpu_entry;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> *<span class="title">iter</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;tmp, user, <span class="keyword">sizeof</span>(tmp)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* overflow check */</span></span><br><span class="line"><span class="keyword">if</span> (tmp.num_counters &gt;= INT_MAX / <span class="keyword">sizeof</span>(struct xt_counters))</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="keyword">if</span> (tmp.num_counters == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">tmp.name[<span class="keyword">sizeof</span>(tmp.name)<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">newinfo = xt_alloc_table_info(tmp.size);</span><br><span class="line"><span class="keyword">if</span> (!newinfo)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">loc_cpu_entry = newinfo-&gt;entries;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(loc_cpu_entry, user + <span class="keyword">sizeof</span>(tmp),</span><br><span class="line">   tmp.size) != <span class="number">0</span>) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> free_newinfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = translate_table(net, newinfo, loc_cpu_entry, &amp;tmp);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> free_newinfo;</span><br><span class="line"></span><br><span class="line">duprintf(<span class="string">"Translated table\n"</span>);</span><br><span class="line"></span><br><span class="line">ret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,</span><br><span class="line">   tmp.num_counters, tmp.counters);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> free_newinfo_untrans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> free_newinfo_untrans:</span><br><span class="line">xt_entry_foreach(iter, loc_cpu_entry, newinfo-&gt;size)</span><br><span class="line">cleanup_entry(iter, net);</span><br><span class="line"> free_newinfo:</span><br><span class="line">xt_free_table_info(newinfo);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看到，iptables和内核间的通信，就是通过调用<code>copy_from_user</code>函数进行数据拷贝来完成的。而拷贝的核心数据结构，就是上面介绍过的<code>ipt_replace</code>结构。<br>至此，Netfilter源码实现的主要流程就介绍完了，更多的细节可自行阅读源码。</p><h2 id="自定义match"><a class="header-anchor" href="#自定义match"></a>自定义match</h2><p>主要是为了练习，功能就是命中后打印输出一下。<br>要实现一个iptables的自定义功能，那么，我应该产生三个文件libipt_xx.c、ipt_xx.c和ipt_xx.h(ipt更换为xt一样有效)，并放到对应目录中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipt_xx.c   -&gt; /&lt;linux-kernel-src&gt;/net/ipv4/netfilter/</span><br><span class="line">ipt_xx.h   -&gt; /&lt;linux-kernel-src&gt;/include/uapi/linux/netfilter_ipv4</span><br><span class="line">libipt_xx.c   -&gt; /usr/local/src/iptables-x.x.x/extensions/</span><br></pre></td></tr></table></figure><p>然后再分别编译内核部分ipt_xx.c和ipt_xx.h源码及用户部分libipt_xx.c源码。</p><h3 id="环境准备"><a class="header-anchor" href="#环境准备"></a>环境准备</h3><p><strong>内核源码下载</strong><br>通用的linux内核源码的<a href="https://www.kernel.org/" target="_blank" rel="noopener">下载</a><br>centos/redhat的内核在上面找不到对应的，他们是自己维护的版本，下载方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 先复制及设定 centos-common 源码</span><br><span class="line">[user@host ~]$ git clone  https://git.centos.org/centos-git-common.git</span><br><span class="line">[user@host ~]$ git clone https://git.centos.org/rpms/kernel.git ; cd kernel</span><br><span class="line"># 让我们存取 cenots7 内核</span><br><span class="line">[user@host kernel]$ git checkout c7 </span><br><span class="line"># get_sources会根据你的电脑内核版本，匹配对应的源码。</span><br><span class="line">[user@host kernel]$ ~/centos-git-common/get_sources.sh</span><br></pre></td></tr></table></figure><p>如果你对特定分支感兴趣，也可以下载特定分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b c7 --single-branch https://git.centos.org/rpms/kernel.git</span><br></pre></td></tr></table></figure><p>这里的内核源码也包含了Netfilter的内核源码。</p><p><strong>iptables源码：</strong><br><em>本文使用的是iptables v1.14.21版本，对应的源码也是这个版本</em> <a href="https://www.netfilter.org/projects/iptables/downloads.html" target="_blank" rel="noopener">下载</a></p><h3 id="自定义match源码"><a class="header-anchor" href="#自定义match源码"></a>自定义match源码</h3><p>内核部分：xt_test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pr_fmt(fmt) KBUILD_MODNAME <span class="meta-string">": "</span> fmt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/udp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter/xt_test.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter/x_tables.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter_ipv4/ip_tables.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter_ipv6/ip6_tables.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Netfilter Core Team &lt;coreteam@netfilter.org&gt;"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"Xtables: multiple port matching for TCP, UDP, UDP-Lite, SCTP and DCCP"</span>);</span><br><span class="line">MODULE_ALIAS(<span class="string">"ipt_test"</span>);</span><br><span class="line">MODULE_ALIAS(<span class="string">"ip6t_test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span></span><br><span class="line">test_mt(<span class="keyword">const</span> struct sk_buff *skb, struct xt_action_param *par)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_test</span> *<span class="title">testinfo</span> = <span class="title">par</span>-&gt;<span class="title">matchinfo</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span>;</span></span><br><span class="line">ip = ip_hdr(skb);</span><br><span class="line"><span class="keyword">if</span> (testinfo-&gt;s_addr == ip-&gt;saddr)&#123;</span><br><span class="line">printk(<span class="string">"match ip [%s]"</span>,ip-&gt;saddr);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">check(<span class="keyword">u_int16_t</span> proto)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> proto == IPPROTO_TCP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *</span><br><span class="line">inet_ntoa(struct in_addr ina)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="keyword">sizeof</span> <span class="string">"aaa.bbb.ccc.ddd"</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *ucp = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;ina;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">"%d.%d.%d.%d"</span>,</span><br><span class="line">ucp[<span class="number">0</span>] &amp; <span class="number">0xff</span>,</span><br><span class="line">ucp[<span class="number">1</span>] &amp; <span class="number">0xff</span>,</span><br><span class="line">ucp[<span class="number">2</span>] &amp; <span class="number">0xff</span>,</span><br><span class="line">ucp[<span class="number">3</span>] &amp; <span class="number">0xff</span>);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_mt_check</span><span class="params">(<span class="keyword">const</span> struct xt_mtchk_param *par)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipt_ip</span> *<span class="title">ip</span> = <span class="title">par</span>-&gt;<span class="title">entryinfo</span>;</span></span><br><span class="line">printk(<span class="string">"input ip:%s"</span>, inet_ntoa(ip-&gt;src));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_match</span> <span class="title">test_mt_reg</span> __<span class="title">read_mostly</span> = &#123;</span></span><br><span class="line">.name= <span class="string">"test"</span>,</span><br><span class="line">.family= NFPROTO_IPV4,</span><br><span class="line">.revision= <span class="number">1</span>,</span><br><span class="line">.checkentry= test_mt_check,</span><br><span class="line">.match= test_mt,</span><br><span class="line">.matchsize= <span class="keyword">sizeof</span>(struct xt_test),</span><br><span class="line">.me= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">test_mt_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(<span class="string">"test module init sucess"</span>);</span><br><span class="line"><span class="keyword">return</span> xt_register_match(&amp;test_mt_reg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">test_mt_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">xt_unregister_match(&amp;test_mt_reg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(test_mt_init);</span><br><span class="line">module_exit(test_mt_exit);</span><br></pre></td></tr></table></figure><p>用户部分：libxt_test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xtables.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt; /* INT_MAX in ip_tables.h/ip6_tables.h */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter_ipv4/ip_tables.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter_ipv6/ip6_tables.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netfilter/xt_test.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">O_SOURCE_PORTS = <span class="number">0</span>,</span><br><span class="line">O_DEST_PORTS,</span><br><span class="line">O_SD_PORTS,</span><br><span class="line">F_SOURCE_PORTS = <span class="number">1</span> &lt;&lt; O_SOURCE_PORTS,</span><br><span class="line">F_DEST_PORTS   = <span class="number">1</span> &lt;&lt; O_DEST_PORTS,</span><br><span class="line">F_SD_PORTS     = <span class="number">1</span> &lt;&lt; O_SD_PORTS,</span><br><span class="line">F_ANY          = F_SOURCE_PORTS | F_DEST_PORTS | F_SD_PORTS,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function which prints out usage message. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_help</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(</span><br><span class="line"><span class="string">"test match options:\n"</span></span><br><span class="line"><span class="string">" --source-ip [ip]\n"</span></span><br><span class="line"><span class="string">" NOTE: just for test.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_option_entry</span> <span class="title">test_opts</span>[] = &#123;</span></span><br><span class="line">&#123;.name = <span class="string">"source-ip"</span>, .id = O_SOURCE_PORTS, .type = XTTYPE_STRING,</span><br><span class="line"> .excl = F_ANY, .flags = XTOPT_INVERT&#125;,</span><br><span class="line">XTOPT_TABLEEND,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *</span><br><span class="line">proto_to_name(<span class="keyword">uint8_t</span> proto)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (proto) &#123;</span><br><span class="line"><span class="keyword">case</span> IPPROTO_TCP:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"tcp"</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">parse_srource_ip(<span class="keyword">const</span> <span class="keyword">char</span> *portstring)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> *buffer;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">buffer = strdup(portstring);</span><br><span class="line"><span class="keyword">if</span> (!buffer) xtables_error(OTHER_PROBLEM, <span class="string">"strdup failed"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!inet_aton(buffer, &amp;addr)) xtables_error(OTHER_PROBLEM, <span class="string">"ip not vaild"</span>);</span><br><span class="line"><span class="built_in">free</span>(buffer);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)addr.s_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *</span><br><span class="line">check_proto(<span class="keyword">uint16_t</span> pnum, <span class="keyword">uint8_t</span> invflags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *proto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (invflags &amp; XT_INV_PROTO)</span><br><span class="line">xtables_error(PARAMETER_PROBLEM,</span><br><span class="line">   <span class="string">"test only works with TCP, UDP, UDPLITE, SCTP and DCCP"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((proto = proto_to_name(pnum)) != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> proto;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!pnum)</span><br><span class="line">xtables_error(PARAMETER_PROBLEM,</span><br><span class="line">   <span class="string">"test needs `-p tcp', `-p udp', `-p udplite', "</span></span><br><span class="line">   <span class="string">"`-p sctp' or `-p dccp'"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">xtables_error(PARAMETER_PROBLEM,</span><br><span class="line">   <span class="string">"test only works with TCP, UDP, UDPLITE, SCTP and DCCP"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __test_parse(struct xt_option_call *cb, <span class="keyword">uint16_t</span> pnum,</span><br><span class="line">      <span class="keyword">uint8_t</span> invflags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *proto;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_test</span> *<span class="title">multiinfo</span> = <span class="title">cb</span>-&gt;<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">xtables_option_parse(cb);</span><br><span class="line"><span class="keyword">switch</span> (cb-&gt;entry-&gt;id) &#123;</span><br><span class="line"><span class="keyword">case</span> O_SOURCE_PORTS:</span><br><span class="line"><span class="comment">//proto = check_proto(pnum, invflags);</span></span><br><span class="line">multiinfo-&gt;s_addr = (__be32)parse_srource_ip(cb-&gt;arg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cb-&gt;invert)</span><br><span class="line">xtables_error(PARAMETER_PROBLEM,</span><br><span class="line">   <span class="string">"test.0 does not support invert"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_parse</span><span class="params">(struct xt_option_call *cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipt_entry</span> *<span class="title">entry</span> = <span class="title">cb</span>-&gt;<span class="title">xt_entry</span>;</span></span><br><span class="line"><span class="keyword">return</span> __test_parse(cb,</span><br><span class="line">       entry-&gt;ip.proto, entry-&gt;ip.invflags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_check</span><span class="params">(struct xt_fcheck_call *cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cb-&gt;xflags == <span class="number">0</span>)</span><br><span class="line">xtables_error(PARAMETER_PROBLEM, <span class="string">"test expection an option"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__test_print(<span class="keyword">const</span> struct xt_entry_match *match, <span class="keyword">int</span> numeric,</span><br><span class="line">                  <span class="keyword">uint16_t</span> proto)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_test</span> *<span class="title">multiinfo</span></span></span><br><span class="line"><span class="class">= (<span class="title">const</span> <span class="title">struct</span> <span class="title">xt_test</span> *)<span class="title">match</span>-&gt;<span class="title">data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.s_addr = (<span class="keyword">in_addr_t</span>)multiinfo-&gt;s_addr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" test "</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,inet_ntoa(addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ip_void,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct xt_entry_match *match, <span class="keyword">int</span> numeric)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipt_ip</span> *<span class="title">ip</span> = <span class="title">ip_void</span>;</span></span><br><span class="line">__test_print(match, numeric, ip-&gt;proto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __test_save(<span class="keyword">const</span> struct xt_entry_match *match,</span><br><span class="line">                             <span class="keyword">uint16_t</span> proto)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xt_test</span> *<span class="title">multiinfo</span></span></span><br><span class="line"><span class="class">= (<span class="title">const</span> <span class="title">struct</span> <span class="title">xt_test</span> *)<span class="title">match</span>-&gt;<span class="title">data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.s_addr = (<span class="keyword">in_addr_t</span>)multiinfo-&gt;s_addr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" test "</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,inet_ntoa(addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_save</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ip_void,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> struct xt_entry_match *match)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipt_ip</span> *<span class="title">ip</span> = <span class="title">ip_void</span>;</span></span><br><span class="line">__test_save(match, ip-&gt;proto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">xtables_match</span> <span class="title">test_mt_reg</span> = &#123;</span></span><br><span class="line">.family        = NFPROTO_IPV4,</span><br><span class="line">.name          = <span class="string">"test"</span>,</span><br><span class="line">.revision      = <span class="number">1</span>,</span><br><span class="line">.version       = XTABLES_VERSION,</span><br><span class="line">.size          = XT_ALIGN(<span class="keyword">sizeof</span>(struct xt_test)),</span><br><span class="line">.userspacesize = XT_ALIGN(<span class="keyword">sizeof</span>(struct xt_test)),</span><br><span class="line">.help          = test_help,</span><br><span class="line">.x6_parse      = test_parse,</span><br><span class="line">.x6_fcheck     = test_check,</span><br><span class="line">.print         = test_print,</span><br><span class="line">.save          = test_save,</span><br><span class="line">.x6_options    = test_opts,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">xtables_register_match(&amp;test_mt_reg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头文件：xt_test.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _XT_TEST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _XT_TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Must fit inside union xt_matchinfo: 16 bytes */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xt_test</span> &#123;</span></span><br><span class="line">__be32s_addr;<span class="comment">/* Type of comparison */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*_XT_MULTIPORT_H*/</span></span></span><br></pre></td></tr></table></figure><h3 id="编译"><a class="header-anchor" href="#编译"></a>编译</h3><p>首先把对应的文件放到对应的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xt_test.c   -&gt; /&lt;linux-kernel-src&gt;/net/ipv4/netfilter/</span><br><span class="line">xt_test.h   -&gt; /&lt;linux-kernel-src&gt;/include/uapi/linux/netfilter_ipv4</span><br><span class="line">libxt_test.c   -&gt; /&lt;iptables-x.x.x&gt;/extensions/</span><br></pre></td></tr></table></figure><p>用户态源码编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./autogen.sh</span><br><span class="line">./configure --prefix=/usr/local/iptables</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>内核源码编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;your_kernel_src_path&gt;/net/netfilter</span><br><span class="line">#修改Makefile，新增：obj-$(CONFIG_NETFILTER_XT_MATCH_TEST) += xt_test.o</span><br><span class="line">make CONFIG_NETFILTER_XT_MATCH_TEST=m -C &lt;your_kernel_src_path&gt;  M=`pwd` modules</span><br></pre></td></tr></table></figure><p>如果出现<code>No rule to make target 'tools/objtool/objtool'</code>的错误：</p><ol><li><code>yum install kernel-headers kernel-devel -y</code></li><li>找到<code>/usr/src/kernels/</code>下安装的tools/objtool/objtool/objtool，将可执行文件拷贝到你的内核源码对应目录。</li><li>重新执行make</li></ol><h3 id="测试"><a class="header-anchor" href="#测试"></a>测试</h3><ol><li><p>先把编译得到的<code>xt_test.ko</code>放到<code>/usr/lib/modules/3.10.0.xxxx/kernel/net/netfilter/</code>目录下。</p></li><li><p>添加iptables规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/iptables/sbin/iptables -A INPUT -p tcp -m test --source-ip &lt;ip&gt; -j DROP</span><br></pre></td></tr></table></figure></li><li><p>使用你配置了的<code>&lt;ip&gt;</code>地址的机器来访问目标机器(tcp)</p></li><li><p><code>dmesg</code>命令来查看打印输出的消息。</p></li></ol><p>如果出现<code>Couldn't load match 'test11':No such file or directory</code>证明你用户态代码，没有找到你编译的模块。<br>如果出现<code>iptables:No chain/target/match by the name</code>证明你内核相应的模块没有嵌入。<br>如果<code>dmesg</code>没有显示出你想要的信息，可能是输出日志级别不够，尝试：<code>dmesg -n 7</code>；或者是存在缓存，尝试删除原有iptables规则，重新配置，之前的日志消息就打印了。</p><h2 id="链接跟踪-conntrack"><a class="header-anchor" href="#链接跟踪-conntrack"></a>链接跟踪(conntrack)</h2><p>功能就是给链接做标识。这一章节主要都是参考(也就是抄[狗头])Netfilter<a href="http://blog.chinaunix.net/uid-26517122-id-4281274.html" target="_blank" rel="noopener">链接跟踪简介</a>(想看更详细内容最好看原文，我这里只是简单截取了主要核心部分，就不重复copy了)，他其他的netfilter相关的解析也写的挺好，建议去看看。</p><h4 id="conntrack介绍"><a class="header-anchor" href="#conntrack介绍"></a>conntrack介绍</h4><p>我们期望一种场景，即外网无法访问内网，但是内网能够访问外网。但配置了拒绝所有外网来的数据包以后，内网访问外网返回的包也无法进入内网，导致内网访问外网失败。因此我们可以利用conntrack(链接跟踪)来解决这一问题。<br>通用的数据访问方式分两种：</p><ol><li>TCP这种面向连接的协议，源和目的的连接终止时，状态防火墙通过检查TCP头的控制标记来跟踪整个过程，并动态地将该连接从状态表中删除。</li><li>DP和ICMP不是面向连接的协议，无法通过报文来判断连接是否终止。状态防火墙会把将UDP流量看成是有连接的，通过在状态表中设置一个定时器，来定期的老化删除一些无用连接。</li></ol><p>期望连接：<br>有一些协议，连接时会分为控制连接和数据连接，我们把数据连接称为是控制连接的期望连接。<br>我们以tftp协议为例来说明一下期望连接：<br><img src="/2020/09/14/Netfilter介绍及其实现原理/%E6%9C%9F%E6%9C%9B%E9%93%BE%E6%8E%A5.jpg" alt><br>如果，客户端先发起连接，使用熟知的69端口。因为69端口是分给了tftp server的，tftp server接收到连接请求后，会自己申请一个server主机上未用的端口1235（因为tftp server的69端口还需要接收其他client发来的连接请求，所有不能使用69来传输数据），给tftp client发送回应。以后client和server就使用端口1235来进行通信了。<br>现在来看，上面连接是两条不同的连接。我们把第二条连接是其一条连接的期望连接。<br>比如防火墙上只放开了目的端口号69的访问，当内网访问外网的tftp server时，回应报文就会被拦截，导致tftp 功能失效。状态防火墙提出期望连接，当回应报文根据目的端口号发现该回应是已存在连接的期望连接，防火墙放过该回应报文，这样tftp功能OK。<br>做个实验：<br>在一台主机上配置如下规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables  -P  INPUT DROP   //丢弃所有到本机的报文</span><br><span class="line">iptables -A INPUT -p udp --dport 69 -j ACCEPT //放行目的端口69的报文</span><br></pre></td></tr></table></figure><p>这时把该主机当tftp client，从tftp server下载东西是无法下载的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -m conntrack --ctstatus EXPECTED -j ACCEPT//放行期望连接</span><br></pre></td></tr></table></figure><p>这时tftp功能OK。</p><p>因此，为了满足上述需求，链接跟踪实现了以下功能：</p><ol><li>建立一张连接状态表，来存放连接记录</li><li>连接状态表中，有定时的垃圾回收机制</li><li>根据报文进行连接状态的建立及对已有连接状态的更新</li><li>期望连接的建立和关联</li><li>在连接跟踪上需要提供易于扩展的接口，来实现用户自定义的一些功能。<br>下面本文将从两个方向来描述链接跟踪，一是从模块扩展上，模块如何注册到conntrack中，提供报文的处理方法；第二是数据流上，报文时如何一步步的在netfilter框架中流动，被conntrack处理的。</li></ol><h3 id="conntrack标识"><a class="header-anchor" href="#conntrack标识"></a>conntrack标识</h3><p>连接跟踪是根据报文的L3，L4层头信息来标识一条连接的，而这些标识需要一个数据结构来进行定义和存储。改数据结构包含了一条连接的全部信息，并且链接跟踪的查找，建立，关联和更新都是依据该数据结构，我们称该数据结构为元组。<br><strong>元组数据结构：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_man</span> <span class="title">src</span>;</span>  <span class="comment">//源端信息</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//目的端信息。</span></span><br><span class="line">    <span class="comment">/* These are the parts of the tuple which are fixed. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">union</span> nf_inet_addr u3;  <span class="comment">//目的IP地址</span></span><br><span class="line">　　  <span class="comment">//目的端口的信息，不同协议使用不同的报文字段</span></span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">             <span class="comment">/* Add other protocols here. */</span></span><br><span class="line">            __be16 all;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                __be16 port;<span class="comment">//TCP报文就使用目的端口</span></span><br><span class="line">            &#125; tcp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                 __be16 port;<span class="comment">//UDP报文就使用目的端口</span></span><br><span class="line">            &#125; udp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                <span class="keyword">u_int8_t</span> type, code;<span class="comment">//ICMPP报文使用type，cod两个字段</span></span><br><span class="line">            &#125; icmp;</span><br><span class="line">            ... <span class="comment">//其他协议此处省略</span></span><br><span class="line">        &#125; u;</span><br><span class="line">        <span class="comment">//传输层协议类型，既L4协议类型</span></span><br><span class="line">        <span class="keyword">u_int8_t</span> protonum;</span><br><span class="line">        <span class="comment">//标识连接的方向，一条连接分两个方向，一来一回</span></span><br><span class="line">        <span class="comment">/* The direction (for tuplehash) */</span></span><br><span class="line">        <span class="keyword">u_int8_t</span> dir;</span><br><span class="line">    &#125; dst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_man</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">union</span> nf_inet_addr u3; <span class="comment">//IP地址</span></span><br><span class="line">    <span class="comment">//L4协议源端信息</span></span><br><span class="line">    <span class="keyword">union</span> nf_conntrack_man_proto u;</span><br><span class="line">    <span class="comment">//L3协议类型</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> l3num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//L4层源端的信息。</span></span><br><span class="line"><span class="keyword">union</span> nf_conntrack_man_proto</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Add other protocols here. */</span></span><br><span class="line">    __be16 all;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        __be16 port;</span><br><span class="line">    &#125; tcp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        __be16 port;</span><br><span class="line">    &#125; udp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        __be16 id;</span><br><span class="line">    &#125; icmp;</span><br><span class="line">    .... <span class="comment">//其他协议此处省略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面数据结构定义看，标识一条连接的元组为：<br>TCP  源IP，源端口，L3协议类型，目的IP，目的端口号，L4协议类型<br>UDP  源IP，源端口，L3协议类型，目的IP，目的端口号，L4协议类型<br>ICMP 源IP，L3协议类型，目的IP，id，type，code,，L4协议类型</p><p><strong>conntrack数据结构：</strong><br>一个连接包含正反两个方向的两条报文流.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> &#123;</span></span><br><span class="line">    <span class="comment">//对连接的引用计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack</span> <span class="title">ct_general</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正向和反向的连接元组信息。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> <span class="title">tuplehash</span>[<span class="title">IP_CT_DIR_MAX</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//该连接的连接状态</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果该连接是期望连接，指向跟其关联的主连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">master</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接垃圾回收定时器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*存储特定协议的连接跟踪信息*/</span></span><br><span class="line">    <span class="keyword">union</span> nf_conntrack_proto proto;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*指向扩展结构，该结构中包含一些基于连接的功能扩展处理函数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_ct_ext</span> *<span class="title">ext</span>;</span></span><br><span class="line">   <span class="comment">//网络命名空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">ct_net</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_node</span> <span class="title">hnnode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> <span class="title">tuple</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个struct nf_conn实例代表一个连接。每个skb都有一个指针，指向和它相关联的连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack</span> *<span class="title">nfct</span>;</span><span class="comment">//指向struct nf_conn实例</span></span><br><span class="line"></span><br><span class="line">kmemcheck_bitfield_begin(flags1);</span><br><span class="line">__u8 local_df:<span class="number">1</span>,</span><br><span class="line">cloned:<span class="number">1</span>,</span><br><span class="line">ip_summed:<span class="number">2</span>,</span><br><span class="line">nohdr:<span class="number">1</span>,</span><br><span class="line">nfctinfo:<span class="number">3</span>; <span class="comment">//记录报文的连接状态。</span></span><br><span class="line">kmemcheck_bitfield_end(flags1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>conntrack的存储:</strong><br><em>/include/net/netns/conntrack.h</em><br>每个网络命名空间有如下一个数据结构的实例，来管理和存放生成的连接的一些信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netns_ct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> expect_count;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> htable_size; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">nf_conntrack_cachep</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_head</span> *<span class="title">hash</span>;</span><span class="comment">//存放已经经过确认的连接hash表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> *<span class="title">expect_hash</span>;</span><span class="comment">//期望连接hash表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_head</span> <span class="title">unconfirmed</span>;</span> <span class="comment">//存放没经过确认的连接hash表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_head</span> <span class="title">dying</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_conntrack_stat</span> *<span class="title">stat</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hash_vmalloc;</span><br><span class="line">    <span class="keyword">int</span> expect_vmalloc;</span><br><span class="line">    <span class="keyword">char</span> *slabname;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整体conntrack相关的数据结构如下：<br><img src="/2020/09/14/Netfilter介绍及其实现原理/conntrack%E7%9A%84%E5%AD%98%E5%82%A8.jpg" alt></p><h3 id="conntrack的建立过程"><a class="header-anchor" href="#conntrack的建立过程"></a>conntrack的建立过程</h3><p>我们先来看一下iptables定义的连接状态：<br><strong>INVALID</strong> :无效连接，防火墙一般会丢弃该连接<br><strong>NEW</strong>：新建立的，既只是通信双方中只一方发送了报文，还没有得到回应的<br><strong>ESTABLISHED</strong>：已经得到回应的连接。既通信双方都发送过报文的连接<br><strong>RELATED</strong>:关联的连接，既有期望连接关联的连接<br><strong>UNTRACKED</strong>：不进行连接跟踪的连接<br><strong>SNAT</strong>:配置了SNAT的连接<br><strong>DNAT</strong>:配置了DNAT的连接</p><h4 id="一般连接建立过程："><a class="header-anchor" href="#一般连接建立过程："></a>一般连接建立过程：</h4><p>这里我们拿一个udp通信的例子来走一遍连接建立的过程。先不具体到代码的实现。</p><p>1、首先，PC和SERVER使用udp报文进行通信。<br><img src="/2020/09/14/Netfilter介绍及其实现原理/conntrack%E4%B8%80%E8%88%AC%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B1.jpg" alt><br><strong>PC---------&gt;SERVER</strong></p><p>报文的元组信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sip：1.1.1.6</span><br><span class="line">Sport:1116</span><br><span class="line">Dip:1.1.1.5</span><br><span class="line">Dport:1115</span><br><span class="line">l4protonum:udp</span><br><span class="line">L3num:INET</span><br></pre></td></tr></table></figure><p>报文到达防火墙，防火墙的处理如下：<br><strong>防火墙入口处:</strong></p><ol><li>conntrack模块截获报文。</li><li>根据报文的元组信息在防火墙内的连接表中查找是否已经存在建立的连接，因为第一次通信，没有已建立的连接。</li></ol><p>建立一个新的连接，连接的正反向元组信息如下图，并把该连接的正向连接A挂到unconfirmed链表上<br><img src="/2020/09/14/Netfilter介绍及其实现原理/conntrack%E4%B8%80%E8%88%AC%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B2.jpg" alt><br>如上，新建连接后，把该连接和报文进行关联，连接状态是NEW。</p><p><strong>防火墙出口处：</strong><br>拦截报文后，根据报文携带的连接信息，找到连接，把该连接的正向连接A从unconfirmed链表上摘下来，把该连接的正反向连接A和B加入到连接hash表中。并把该连接确认状态置为confirmed状态，即置位status的IPS_CONFIRMED_BIT位。<br><img src="/2020/09/14/Netfilter介绍及其实现原理/conntrack%E4%B8%80%E8%88%AC%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B3.jpg" alt></p><p><strong>SERVER-----&gt;PC</strong><br>SERVER回应PC的报文元组信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sip：1.1.1.5</span><br><span class="line">Sport:1115</span><br><span class="line">Dip:1.1.1.6</span><br><span class="line">Dport:1116</span><br><span class="line">l4protonum:udp</span><br><span class="line">L3num:INET</span><br></pre></td></tr></table></figure><p>报文到达防火墙，防火墙的处理如下：<br><strong>防火墙入口处:</strong></p><ol><li>conntrack模块截获报文。</li><li>根据报文的元组信息在防火墙内的连接表中查找是否已经存在建立的连接，可以找到已建立的连接B。</li><li>发现连接B里的dir是reply，表明该连接已经有回应报文了，给连接中的status置位IPS_SEEN_REPLY_BIT，表明该连接已经收到了回应报文。这时把报文的连接状态变为ESTABLISHED</li></ol><p><strong>防火墙出口处：</strong></p><ol><li>拦截报文后，根据报文携带的连接信息，找到连接，发现该连接确认状态是confirmed的，直接不进行连接处理。</li></ol><p>至此，连接建立完成。</p><p>后续该连接的正反方向的报文都可以在连接表中查到相应的连接，就可以根据连接进行相应的处理了。</p><h4 id="期望连接的建立过程："><a class="header-anchor" href="#期望连接的建立过程："></a>期望连接的建立过程：</h4><p>这里就不介绍了，详情可看<a href="http://blog.chinaunix.net/uid-26517122-id-4281305.html" target="_blank" rel="noopener">原文</a></p><p><strong>奉上原文后续章节：</strong><br><a href="http://blog.chinaunix.net/uid-26517122-id-4292718.html" target="_blank" rel="noopener">Netfilter中conntrack 功能扩展机制</a><br><a href="http://blog.chinaunix.net/uid-26517122-id-4292730.html" target="_blank" rel="noopener">Netfilter中conntrack helper扩展实现</a><br><a href="http://blog.chinaunix.net/uid-26517122-id-4292946.html" target="_blank" rel="noopener">Netfilter中L3和L4层提供的conntrack处理方法</a><br><a href="http://blog.chinaunix.net/uid-26517122-id-4293010.html" target="_blank" rel="noopener">Netfilter中conntrack的HOOK点</a><br><a href="http://blog.chinaunix.net/uid-26517122-id-4293135.html" target="_blank" rel="noopener">Nefilter中IP conntrack核心函数详解</a></p><h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2><p><a href="https://zh.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Netfilter</a><br><a href="https://www.ibm.com/developerworks/cn/linux/network/s-netip/index.html" target="_blank" rel="noopener">netfilter/iptables 简介</a><br><a href="https://www.xiayinchang.top/post/d617cc74.html" target="_blank" rel="noopener">Netfilter 框架及其周边组件</a><br><a href="https://opengers.github.io/openstack/openstack-base-netfilter-framework-overview/#connection-tracking" target="_blank" rel="noopener">netfilter框架研究</a><br><a href="https://cloud.tencent.com/developer/article/1199506" target="_blank" rel="noopener">使用iptables控制网络流量</a><br><a href="https://xiaoz.co/2020/01/10/a-deep-dive-into-iptables-and-netfilter-architecture/" target="_blank" rel="noopener">深入理解Iptables和Netfilter架构</a><br><a href="http://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener">深入理解Iptables和Netfilter架构</a><br><a href="https://blog.csdn.net/haolipengzhanshen/article/details/85007427" target="_blank" rel="noopener">iptables和netfilter的通信流程</a><br><a href="https://blog.csdn.net/venoy4806/article/details/5136626" target="_blank" rel="noopener">netfilter内核源码分析</a><br><a href="https://blog.csdn.net/venoy4806/article/details/5136626" target="_blank" rel="noopener">Netfilter内核源码分析</a><br><a href="http://chinaunix.net/uid-29547110-id-5038602.html" target="_blank" rel="noopener">Netfilter全面讲解</a><br><a href="http://blog.chinaunix.net/uid-26517122-id-4292718.html" target="_blank" rel="noopener">conntrack详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NETFILTER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker使用</title>
      <link href="/2020/09/14/Docker%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/09/14/Docker%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>苦于python环境的迁移，开始尝试使用docker来实现不同linux平台的环境搬迁。(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em><a href="https://www.docker.com" target="_blank" rel="noopener">Docker官方</a></em><br><em><a href="https://www.runoob.com/docker/centos-docker-install.html" target="_blank" rel="noopener">参考教程1</a>  <a href="https://yeasy.gitbooks.io/docker_practice/install/mirror.html" target="_blank" rel="noopener">参考教程2</a></em><br><em><a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a></em></p><a id="more"></a><h3 id="创建基本镜像"><a class="header-anchor" href="#创建基本镜像"></a>创建基本镜像</h3><p>我这儿的基础镜像是：<code>centos7+python3.7</code>  官方已经不支持centos7以下的版本了。<br>但是由于我想用这个基本镜像做开发，因此还根据我自己添加了其他的一些工具。<br>基本步骤如下<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">参考</a>：<br><strong>脚本安装(懒人)：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh</span><br></pre></td></tr></table></figure><p><strong>安装包安装(离线)：</strong></p><ol><li><p>下载安装包，这儿有三类安装包，保险都下：<a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/" target="_blank" rel="noopener">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a></p></li><li><p>安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install /path/to/package.rpm</span><br></pre></td></tr></table></figure></li><li><p>启动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>验证：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure></li></ol><p><strong>社区版安装：</strong></p><ol><li><p>卸载旧版本docker</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">               docker-client \</span><br><span class="line">               docker-client-latest \</span><br><span class="line">               docker-common \</span><br><span class="line">               docker-latest \</span><br><span class="line">               docker-latest-logrotate \</span><br><span class="line">               docker-logrotate \</span><br><span class="line">               docker-engine</span><br></pre></td></tr></table></figure></li><li><p>由于linux是社区版本(开源)，需要安装docker仓库，以便更新.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">     device-mapper-persistent-data \</span><br><span class="line">     lvm2</span><br></pre></td></tr></table></figure></li><li><p>设置仓库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">     --add-repo \</span><br><span class="line">     https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>官网还有一些配置操作，我这儿做开发，基本用不到。跳过，直接安装。(如果网速慢，自行配置yum源)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li><li><p>查看需要安装的版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br><span class="line"> docker-ce.x86_64            3:19.03.5-3.el7                    docker-ce-stable </span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></li><li><p>安装docker：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br><span class="line">$ sudo yum install docker-ce-19.03.5 docker-ce-cli-19.03.5 containerd.io</span><br></pre></td></tr></table></figure></li><li><p>启动docker：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>检查安装是否成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure></li></ol><p><strong>创建镜像</strong></p><ol><li>最保险的方式，就是创建<code>系统+平台</code>这种镜像，但是缺点是镜像占用空间大。</li><li>直接创建<code>平台</code>镜像，占用空间小，但是有可能在不同版本的系统上运行不畅。</li></ol><p>那么我们两种都试试。<br>老规矩，给docker hub加速，<a href="https://yeasy.gitbooks.io/docker_practice/install/mirror.html" target="_blank" rel="noopener">参考</a>：<br>Ubuntu 16.04+、Debian 8+、CentOS 7<br>对应<code>/etc/docker/daemon.json</code>文件中添加：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">    <span class="string">"https://hub-mirror.c.163.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><ol><li><p>系统+镜像</p><ol><li>上docker hub，注册（docker2jihan）</li><li>找个系统，我喜欢centos7，找个7.5纯净版的。<a href="https://hub.docker.com/_/centos?tab=tags" target="_blank" rel="noopener">官方镜像</a></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull centos:centos7.5.1804</span><br><span class="line">$ docker images</span><br><span class="line">     REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">     centos              centos7.5.1804      cf49811e3cdb        9 months ago        200MB</span><br></pre></td></tr></table></figure><ol start="3"><li>进入到相应该镜像：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i centos:centos7.5.1804 /bin/bash</span><br><span class="line"> &lt;-i 参数后面跟镜像名:标签&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>安装各种你所需要的东西，我这儿安装了常用命令，python等。宿主机到docker拷贝<code>docker cp .vimrc &lt;容器ID&gt;:/root/</code>，反正也一样。</li><li>制作镜像：</li></ol> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m=<span class="string">"init and conda"</span> -a=<span class="string">"jihan"</span> &lt;容器ID&gt; &lt;name&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>上传镜像或者导出镜像：<br>上传：<br>创建tag：<code>docker tag IMAGEID new_repository newTAG</code><br>登录验证：<code>docker login</code><br>上传docker hub：<code>docker push &lt;hub-user&gt;/&lt;repo-name&gt;:&lt;tag&gt;</code><br>导出：<br><code>docker save  &lt;repo-name&gt;:&lt;tag&gt; -o &lt;name&gt;.tar</code><br>导入：<br><code>docker import &lt;name&gt;.tar - &lt;repo-name&gt;:&lt;tag</code></li></ol></li></ol><h3 id="docker应用调研"><a class="header-anchor" href="#docker应用调研"></a>docker应用调研</h3><p>看了一些关于docker优缺点的调研，发现我们产品并不适合docker，或者说只能解决环境不一致的问题，但docker的引入肯定会带来其他新问题。<br>比较了一下docker的优势，以及和我们产品的应用场景</p><ol><li>docker在环境隔离上很强势，一台设备可以跑几千个相互隔离的容器。但我们的产品是主机/虚拟机 独占。</li><li>docker在环境部署上的统一，这的确可以解决我们产品在不同平台适配的问题以及开发测试发布一条龙环境一致。这也是调研docker的主要原因。</li><li>docker动态扩容很强。但我们产品不需要，独占主机嘛，不行就加设备。毕竟toB厂商</li><li>docker有更快速的启动时间，以及资源消耗。emmm，这个对我们产品优点鸡肋，独占主机或者跑在主机的虚拟机上，没有必要需要这个特性。<br>总结：docker除了一致性环境能给我们带来好处，似乎没有其他明显好处了。</li></ol><p>再说一下引入docker带来的问题：</p><ol><li>我们产品是网络设备，加了一层docker，端口映射问题老大难。并且产品在使用过程中会新增监听接口，每加一个都去reload一下docker的映射配置，有点蠢</li><li>docker的数据持久化问题，简单查阅资料显示，docker的数据持久化有需要注意的地方，有坑。但是具体未深究。</li><li>引入docker会增加发布版本包的大小，并且出现问题后的排查也是需要注意的。</li><li>其他未考量到的问题。<br>总结：引入docker明显有3-4个大点或者坑需要注意，并且容器的学习成本比较高，除了开发，测试和运维也需要学习和维护，代价较大。</li></ol><p>最后决定不引入docker，不适合。（虽然我说了也不算）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>技术札记</title>
      <link href="/2020/09/14/%E6%8A%80%E6%9C%AF%E6%9C%AD%E8%AE%B0/"/>
      <url>/2020/09/14/%E6%8A%80%E6%9C%AF%E6%9C%AD%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>谁知道这里面有多少小技巧，没准哪个能帮上你呢？(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　by JiHan</p><hr><a id="more"></a><h3 id="ssh免密登录"><a class="header-anchor" href="#ssh免密登录"></a>ssh免密登录</h3><p>A是主机，B是远程服务器<br><strong>原理：</strong><br><img src="/2020/09/14/技术札记/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86.png" alt="ssh免密登录原理"><br><strong>实际配置：</strong></p><ol><li><p>生成秘钥对：<br>本地主机：</p>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></li><li><p>拷贝公钥到远程主机：</p><ol><li><p>简单方法，在本地主机执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id remote_username@server_ip_address -p port</span><br></pre></td></tr></table></figure><p><em>不加<code>-p</code>默认22端口</em><br>然后输入密码即可</p></li><li><p>先登录远程主机：</p><ol><li><p>获取本地主机的公钥，追加到<code>authorized_keys</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure></li><li><p>修改权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 authorized_keys</span><br></pre></td></tr></table></figure></li><li><p>重启服务(不一定需要)：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>配置ssh名称(可选)<br>为了方便记住输入远程主机设备，可给远程主机配置名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vi ~/.ssh/config</span><br><span class="line">Host remote</span><br><span class="line">User root</span><br><span class="line">Hostname 192.168.0.1</span><br><span class="line">Port 22</span><br><span class="line"># ssh remote</span><br></pre></td></tr></table></figure></li></ol><p><strong>测试：</strong><br>本地主机登录远程主机：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh remote@&lt;ip&gt;</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">ssh <span class="comment">#免密</span></span><br></pre></td></tr></table></figure><p><strong>配置ssh禁用密码登录：</strong><br>增加安全性，避免别人尝试非法登录。</p><ol><li><p>完成上述的免密登录，服务端获得一个公钥，本机获得一个私钥</p></li><li><p>将私钥保存，供其他设备使用</p></li><li><p>设置服务端配置文件<code>/etc/ssh/sshd_config</code>，关闭密码登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#禁用密码验证</span><br><span class="line">PasswordAuthentication no</span><br><span class="line">#启用密钥验证，下面两个默认都是开启的</span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br></pre></td></tr></table></figure></li><li><p>重启sshd服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure></li></ol><h3 id="VSCODE-配置同步到github账号：gotables"><a class="header-anchor" href="#VSCODE-配置同步到github账号：gotables"></a>VSCODE(配置同步到github账号：gotables)</h3><p>插件列表：</p><ol><li>Remote-SSH：远程ssh登录，linux版本太低不支持</li><li>sftp：远程文件同步</li><li>vscode-icons：文件图标显示</li><li>markdown all in one：Markdown插件</li><li>markdown preview  Enhanced：Markdown预览<br>cmd：Markdown Preview Enhanced: Customize Css<br>background-color: rgb(157, 189, 189);<br>font-family: -apple-system, BlinkMacSystemFont, “Segoe UI”, Helvetica, Arial, sans-serif, “Apple Color Emoji”, “Segoe UI Emoji”, “Segoe UI Symbol”, “微软雅黑”;</li><li>tabNine：机器学习补全(可能导致和语言补全冲突)</li><li>go 补全插件，建议使用gopl，之前补全太慢，<a href="https://blog.csdn.net/zhetmdoubeizhanyong/article/details/102534172" target="_blank" rel="noopener">解决</a></li><li>koroFileHeader：用于生成标准格式函数头说明，或者代码文件头说明</li><li>bookmarks：给代码打标签</li><li><a href="http://Draw.io" target="_blank" rel="noopener">Draw.io</a> integration：drawio的绘图插件</li><li>格式补全：在命令行输入：Format Document 或 Format Selection</li><li>koroFileHeader插件对应命令：fileheader或cursorTip（函数头注释）,各种语言都支持</li><li>Doxygen Documentation Generator插件也用于生成注释，只需要输入/**回车就行，文件注释和函数注释都是（貌似只针对c/cpp）</li><li>针对golang的注释插入：安装Go extension for Visual Studio Code，然后在代码中使用/**或者///来开始一个注释块，并按回车键。</li></ol><h3 id="C-段错误处理-Linux"><a class="header-anchor" href="#C-段错误处理-Linux"></a>C 段错误处理(Linux)</h3><ol><li>必须先得到段错误的地址，可以用gdb的bt或者在程序中捕捉段错误堆栈。<code>SIGSEGV, SIGABRT</code></li><li>在可以编译的机器上源码编译，带上行号和函数名，使用<code>addr2line -f -e &lt;file&gt; &lt;addr&gt;</code>来映射到具体的函数位置。</li><li><code>objdump -D &lt;file&gt; | grep -A 50 -B 50 &lt;addr&gt;</code> 也能查到对应汇编代码，从而定位函数。</li></ol><h3 id="进程运行状态查看"><a class="header-anchor" href="#进程运行状态查看"></a>进程运行状态查看</h3><p><code>pstack &lt;pid&gt; </code>查看当前运行程序的运行状态，非常方便排查阻塞和死锁问题。<br><code>ps aux --sort -rss</code> 按照内存占用排序，排查进程内存泄漏。<br><code>ps v &lt;pid&gt;</code>查看某个进程具体的信息，类似top列出的进程信息。</p><h3 id="断言assert"><a class="header-anchor" href="#断言assert"></a>断言assert</h3><p>处理程序中不应该发生的错误，常用在参数检查。<br><a href="http://c.biancheng.net/c/assert/" target="_blank" rel="noopener">参考1</a>, <a href="https://www.runoob.com/w3cnote/c-assert.html" target="_blank" rel="noopener">参考2</a></p><h3 id="ipset源码技巧"><a class="header-anchor" href="#ipset源码技巧"></a>ipset源码技巧</h3><p>ipset源码分析</p><ol><li><p>这里有个很牛皮的操作，在c里面实现的模块化加载。具体操作如下：<br>如果我想在ipset中支持一种新的添加规则，比如hash:ip，那么，我需要改多少源码？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 按照格式写好ipset_hash_ip.c里面包含了hash:ip的传输规则和初始化方法。</span><br><span class="line">2. 重新执行configure，加入这个规则（这里具体实现我没有确认，但猜测如此）</span><br><span class="line">3. 执行make</span><br></pre></td></tr></table></figure><p>那么其具体实现方法如何？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 首先在configure中会根据你配置的支持规则模块生成makefile，makefile中就会包含编译这个模块的源文件。</span><br><span class="line">2. make时会根据配置产生的源文件列表，生成一个type_init.c文件，里面包含了所有规则模块的初始化。</span><br><span class="line">3. 主函数会调用type_init.c源文件，将初始化好的规则加载到一个全局链表中，在规则匹配的时候进行匹配。</span><br></pre></td></tr></table></figure><p>这种方法就实现了模块化的添加和删除规则模块的方法。这种模块化的思想，在其他语言里并不少见，但是在c语言里面实现的，还是少见(菜鸡的我反正第一次见)</p></li><li><p>提供了接口，自定义输出函数和日志输出文件。</p></li><li><p>X Macros宏使用，类似定义一个map，但是比map功能更丰富。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Defines four variables. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VARIABLES \ </span></span><br><span class="line">   X(value1, <span class="number">1</span>) \ </span><br><span class="line">   X(value2, <span class="number">2</span>) \ </span><br><span class="line">   X(value3, <span class="number">3</span>) \ </span><br><span class="line">   X(value4, <span class="number">4</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// driver program. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="comment">// Declaration of every variable </span></span><br><span class="line">   <span class="comment">// is done through macro. </span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> X(value, a) char value[10]; </span></span><br><span class="line">      VARIABLES </span><br><span class="line">   <span class="meta">#<span class="meta-keyword">undef</span> X </span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// String values are accepted </span></span><br><span class="line">   <span class="comment">// for all variables. </span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> X(value, a) scanf(<span class="meta-string">"\n%s"</span>, value); </span></span><br><span class="line">      VARIABLES </span><br><span class="line">   <span class="meta">#<span class="meta-keyword">undef</span> X </span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Values are printed. </span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> X(value, a) printf(<span class="meta-string">"%d) %s\n"</span>, a, value); </span></span><br><span class="line">      VARIABLES </span><br><span class="line">   <span class="meta">#<span class="meta-keyword">undef</span> X </span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上预编译后的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">char</span> value1[<span class="number">10</span>]; </span><br><span class="line">   <span class="keyword">char</span> value2[<span class="number">10</span>]; </span><br><span class="line">   <span class="keyword">char</span> value3[<span class="number">10</span>]; </span><br><span class="line">   <span class="keyword">char</span> value4[<span class="number">10</span>]; </span><br><span class="line"></span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"\n%s"</span>, value1); </span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"\n%s"</span>, value2); </span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"\n%s"</span>, value3); </span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"\n%s"</span>, value4); </span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d) %s\n"</span>, <span class="number">1</span>, value1); </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d) %s\n"</span>, <span class="number">2</span>, value2); </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d) %s\n"</span>, <span class="number">3</span>, value3); </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d) %s\n"</span>, <span class="number">4</span>, value4); </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Defining a macro </span></span><br><span class="line"><span class="comment">// with the values of colors. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLORS \ </span></span><br><span class="line">   X(RED) \ </span><br><span class="line">   X(BLACK) \ </span><br><span class="line">   X(WHITE) \ </span><br><span class="line">   X(BLUE) </span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating an enum of colors </span></span><br><span class="line"><span class="comment">// by macro expansion. </span></span><br><span class="line"><span class="keyword">enum</span> colors &#123; </span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> X(value) value, </span></span><br><span class="line">      COLORS </span><br><span class="line">   <span class="meta">#<span class="meta-keyword">undef</span> X </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility that takes the enum value </span></span><br><span class="line"><span class="comment">// and returns corresponding string value </span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">toString</span><span class="params">(<span class="keyword">enum</span> colors value)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">switch</span> (value) &#123; </span><br><span class="line">      <span class="meta">#<span class="meta-keyword">define</span> X(color) \ </span></span><br><span class="line">         <span class="keyword">case</span> color: \ </span><br><span class="line">            <span class="keyword">return</span> #color; </span><br><span class="line">            COLORS </span><br><span class="line">      <span class="meta">#<span class="meta-keyword">undef</span> X </span></span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// driver program. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">enum</span> colors color = WHITE; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%s"</span>, toString(color)); </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上预编译后的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating an enum of colors. </span></span><br><span class="line"><span class="keyword">enum</span> colors &#123; </span><br><span class="line">   RED, </span><br><span class="line">   BLACK, </span><br><span class="line">   WHITE, </span><br><span class="line">   BLUE </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*A utility that takes the enum value and returns </span></span><br><span class="line"><span class="comment">corresponding string value*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">toString</span><span class="params">(<span class="keyword">enum</span> colors value)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">switch</span> (value) &#123; </span><br><span class="line">   <span class="keyword">case</span> RED: </span><br><span class="line">      <span class="keyword">return</span> <span class="string">"RED"</span>; </span><br><span class="line">   <span class="keyword">case</span> BLACK: </span><br><span class="line">      <span class="keyword">return</span> <span class="string">"BLACK"</span>; </span><br><span class="line">   <span class="keyword">case</span> WHITE: </span><br><span class="line">      <span class="keyword">return</span> <span class="string">"WHITE"</span>; </span><br><span class="line">   <span class="keyword">case</span> BLUE: </span><br><span class="line">      <span class="keyword">return</span> <span class="string">"BLUE"</span>; </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// driver program. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">enum</span> colors color = WHITE; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%s"</span>, toString(color)); </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>X macros 主要适用于多中类型有相同的处理逻辑。简单的类似enum中int到string的映射，复杂的到ipset的多种类型处理。</p></li><li><p>gcc 编译debug模式或者自定义模式。<code>-Dxxx</code>。示例：<br>test.c:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int agv, char *agrs[])&#123;</span><br><span class="line">#ifdef TEST</span><br><span class="line">   printf(&quot;ENABLE TEST\n&quot;);</span><br><span class="line">#endif</span><br><span class="line">   printf(&quot;test over\n&quot;);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行TEST：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c -DTEST -o test</span><br><span class="line">$ ./test</span><br><span class="line">ENABLE TEST</span><br><span class="line">test over</span><br><span class="line">$ gcc test.c -o test</span><br><span class="line">$ ./test</span><br><span class="line">test over</span><br></pre></td></tr></table></figure><p>这种方式在做C的模块编译，以及Debug编译特别有效。DEBUG适合开源代码，不适合现场代码排查。<br><a href="https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/#%E4%BD%BF%E7%94%A8-V%E6%89%93%E5%8D%B0%E6%89%80%E6%9C%89%E7%9A%84%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">15个最常用的GCC编译器参数</a></p></li><li><p>源码编译的时候，缺少依赖库。</p><ul><li>一般的解决方法，都是直接用yum install libxxx-devel.x86_64，再次进行configure。</li><li>如果还不成功，就检查你的<code>PKG_CONFIG_PATH</code>变量是否存在，不存在添加对应的环境变量(默认一般在<code>/usr/lib64/pkgconfig/</code>)。</li><li>如果还不行，就执行<code>/usr/bin/pkg-config --exists --print-errors &quot;libxxx &gt;= x.x.xx&quot;</code>(通常这个命令可以在configure文件中找到)，然后再根据问题来排查。</li><li>最后的方法，就是用<code>./configure --help</code>来找到对应的库的环境变量名称，修改对应的<code>libxxx_LIBS</code></li></ul></li></ol><h3 id="一些工具"><a class="header-anchor" href="#一些工具"></a>一些工具</h3><p><a href="https://golang.hotexamples.com/" target="_blank" rel="noopener">查找各种代码的使用范例</a></p><h3 id="go好用的开源组件"><a class="header-anchor" href="#go好用的开源组件"></a>go好用的开源组件</h3><p>配置文件读写：</p><ul><li><a href="http://github.com/spf13/viper" target="_blank" rel="noopener">github.com/spf13/viper</a></li></ul><p>日志：</p><ul><li><a href="http://go.uber.org/zap" target="_blank" rel="noopener">go.uber.org/zap</a></li></ul><p>web服务：</p><ul><li><a href="http://github.com/gin-gonic/gin" target="_blank" rel="noopener">github.com/gin-gonic/gin</a></li></ul><p>go编写命令：</p><ul><li><a href="http://github.com/urfave/cli/v2" target="_blank" rel="noopener">github.com/urfave/cli/v2</a></li></ul><p>restful 文档生成：</p><ul><li><a href="https://github.com/swaggo/gin-swagger" target="_blank" rel="noopener">https://github.com/swaggo/gin-swagger</a><ul><li><a href="https://awesomeopensource.com/project/swaggo/swag" target="_blank" rel="noopener">全教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/40304004" target="_blank" rel="noopener">教程</a></li><li><a href="https://juejin.im/post/5d3f92356fb9a06b317b3baf" target="_blank" rel="noopener">教程</a></li></ul></li></ul><h3 id="Go技巧"><a class="header-anchor" href="#Go技巧"></a>Go技巧</h3><ol><li>测试<ol><li>单元测试<br>就是常用的以<code>_test.go</code>结尾的文件，函数名<code>Testxx</code>来构成的单元测试。如果你想将单元测试编译出来，可以使用<code>-c</code>参数，执行测试程序的时候，使用<code>-test.xxx</code>来执行test相关命令。例如：<code>go test -run xxx</code>=<code>./a -test.run xxx</code></li><li>性能测试<br>同样在<code>_test.go</code>结尾的文件中，以<code>Benchmark</code>为开头的性能测试，具体用法可以<a href="https://my.oschina.net/solate/blog/3034188" target="_blank" rel="noopener">参考</a>, 生成性能图和火焰图更有利于分析。<a href="https://zhuanlan.zhihu.com/p/80578541" target="_blank" rel="noopener">另外的参考</a></li></ol></li></ol><h3 id="xrags"><a class="header-anchor" href="#xrags"></a>xrags</h3><p>常见的用法：</p><ol><li><code>ls | xargs echo</code> 相当于<code>echo a b c</code></li><li><code>ls | xargs -i echo {}</code> 相当于 <code>echo a; echo b; echo c</code>，<code>-i</code>同<code>-I '{}'</code>，其含义是将<code>{}</code>内的内容替换成前面输出的内容，并且循环执行。</li><li><code>-t</code>参数可以查看你xargs执行的命令。</li></ol><p><strong>注意：</strong> 如果在xargs后的命令参数中，路径参数有空格的或tab的，会导致路径无法识别。比如<code>echo &quot;/home/jihan &quot; | xargs -i ls {}</code>就会报错，虽然实际命令<code>ls /home/jihan&lt;空格&gt;</code>没有问题，但是用xargs+i的形式就有问题。</p><h3 id="shell调试"><a class="header-anchor" href="#shell调试"></a>shell调试</h3><ol><li>-n 命令，显示shell，不执行，通常用于语法检查。</li><li>-x 命令，我经常用，在执行过程中打印shell脚本执行的真实命令。-v是打印原始命令，不做替换。</li><li>bashdb，类似gdb做调试用，命令：<code>bashdb --debug your.sh</code>，一下是常用参数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">一、列出代码和查询代码类：</span><br><span class="line">l  列出当前行以下的10行</span><br><span class="line">-  列出正在执行的代码行的前面10行</span><br><span class="line">.  回到正在执行的代码行</span><br><span class="line">/pat/ 向后搜索pat</span><br><span class="line">？pat？向前搜索pat</span><br><span class="line">二、Debug控制类：</span><br><span class="line">h     帮助</span><br><span class="line">help  命令 得到命令的具体信息</span><br><span class="line">q     退出bashdb</span><br><span class="line">x     算数表达式 计算算数表达式的值，并显示出来</span><br><span class="line">!!    空格Shell命令 参数 执行shell命令</span><br><span class="line">使用bashdb进行debug的常用命令(cont.)</span><br><span class="line">三、控制脚本执行类：</span><br><span class="line">n   执行下一条语句，遇到函数，不进入函数里面执行，将函数当作黑盒</span><br><span class="line">s n 单步执行n次，遇到函数进入函数里面</span><br><span class="line">b   行号n 在行号n处设置断点</span><br><span class="line">del 行号n 撤销行号n处的断点</span><br><span class="line">c   行号n 一直执行到行号n处</span><br><span class="line">R   重新启动当前调试脚本</span><br><span class="line">Finish 执行到程序最后</span><br><span class="line">cond n expr 条件断点</span><br></pre></td></tr></table></figure></li></ol><h3 id="查找与当前进程通信的所有进程"><a class="header-anchor" href="#查找与当前进程通信的所有进程"></a>查找与当前进程通信的所有进程</h3><ol><li>找到当前进程S的进程pid</li><li>获取与S通信A的tcp端口号</li><li>通过A的tcp端口号，获得A的进程pid。这里也可以使用<code>lsof -i:&lt;port&gt;</code>来查看，速度更快。</li><li>或者使用<code>ss -atnp -o 'dport = :7'</code>命令进行查看，更多使用可以看<code>man ss</code>中的示例</li><li>如果遇到瞬时完成的请求，那么可以先增加防火墙，拦住接收接口，抓包观测到有包到来时，执行命令查看。<br><img src="/2020/09/14/技术札记/%E6%9F%A5%E6%89%BE%E4%B8%8E%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%89%80%E6%9C%89%E8%BF%9B%E7%A8%8B.jpg" alt="举个栗子"></li></ol><h3 id="程序执行时的系统调用"><a class="header-anchor" href="#程序执行时的系统调用"></a>程序执行时的系统调用</h3><p><code>strace</code> 是 Linux 中用于监控和篡改进程与内核之间操作的工具。非常强大的工具，能够有效排查程序性能问题，异常操作以及段错误问题。</p><h3 id="程序内存检测"><a class="header-anchor" href="#程序内存检测"></a>程序内存检测</h3><p><code>valgrind</code> <a href="https://www.jianshu.com/p/29a7a7d3d5b1" target="_blank" rel="noopener">参考</a></p><h3 id="Linux文件锁定"><a class="header-anchor" href="#Linux文件锁定"></a>Linux文件锁定</h3><p>在root权限下，有可能对某个文件都没有操作权限，可能是使用<code>chattr</code>对其进行锁定，可使用其进行解除。<code>lsattr</code>查看相应属性。<a href="http://c.biancheng.net/view/874.html" target="_blank" rel="noopener">参考</a></p><h3 id="Linux-内核小版本升级"><a class="header-anchor" href="#Linux-内核小版本升级"></a>Linux 内核小版本升级</h3><p>小版本，就是 <code>3.10.0-862</code>中<code>-</code>后的东西。而我们进行升级的时候，需要(centos为例，3.10.0-693升级到3.10.0-862)：</p><ol><li>大版本相同的一个设备(3.10.0-693)</li><li>想要升级的rpm包(3.10.0-862)<a href="https://www.kernel.org/" target="_blank" rel="noopener">官方</a>，找不到直接Google搜吧。<a href="https://linuxsoft.cern.ch/cern/centos/7/updates/x86_64/repoview/kernel.html" target="_blank" rel="noopener">这个网站很全</a></li><li><code>yum install kernel-3.10.0-862.9.1.el7.x86_64.rpm</code></li><li>grub2看看启动顺序<code>grub2-editenv list</code>以及<code>awk -F \' '$1==&quot;menuentry &quot; {print i++ &quot; : &quot; $2}' /etc/grub2.cfg</code></li><li>reboot</li><li><s>需要源码的情况下，执行<code>yum install kernel-devel</code>会自动根据内核版本下载安装源码到<code>/usr/src/kernels</code>中(会下载最新版本的，郁闷)</s></li><li>需要内核源码的话，从网上搜索对应的源码，执行<code>yum install kernel-devel-xxxx.rpm</code>安装即可。<a href="https://linuxsoft.cern.ch/cern/centos/7/updates/x86_64/repoview/kernel-devel.html" target="_blank" rel="noopener">这个网站很全</a></li></ol><h3 id="linux源码编译"><a class="header-anchor" href="#linux源码编译"></a>linux源码编译</h3><h3 id="内核模块源码编译安装"><a class="header-anchor" href="#内核模块源码编译安装"></a>内核模块源码编译安装</h3><p>用户态的源码编译安装，和普通的其他软件没有什么区别，基本都是make，make install，但是你要进行内核模块的源码构建，那么有如下几种方式:</p><ol><li><p>放在源码树以内(例如iptables)。假如我要自定义一个netfilter的模块，而且希望将他存放于/net/netfilter/目录下，那么要注意，在该目录下存在大量的.c源码文件。如果你的模块文件仅仅只有一两个源文件，你可以直接将其放在该目录下，如果你的模块包含的源文件比较多的话，也许你应该建立一个单独的文件夹，用于专门维护你的模块程序源文件。假如创建一个目录名为：mynetfilter/子目录。接下来需要修改/net/netfilter/目录下的Makefile文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Obj-m += mynetfilter/</span><br></pre></td></tr></table></figure><p>这行编译指令告诉模块构建系统，在编译模块时需要进入mynetfilter/子目录。如果你的模块程序依赖于一个特殊的配置选项。比如，CONFIG_ MYNETFILTER_TEST（该选项在编译内核时，执行make menuconfig命令时用于配置该模块的编译选项），你需要修改/net/netfilter/目录下的Kconfig文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config “MYNETFILTER_TEST”</span><br><span class="line">tristate “netfilter test module”</span><br></pre></td></tr></table></figure><p>编译内核时，执行make menucofnig之后，我们会在配置菜单上看到此选项,随之，需要修改Makefile文件，用下面的指令替换之前的<code>Obj-m += mynetfilter/</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Obj-$(CONFIG_MYNETFILTER_TEST)  += mynetfilter/</span><br></pre></td></tr></table></figure><p>最后，在/net/netfilter/mynetfilter/目录下添加一个Makefile文件，其中需要添加下面的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Obj –m  += mynetfilter.o</span><br></pre></td></tr></table></figure><p>准备就绪了，现在构建系统会进入到mynetfilter/目录下，将mynetfilter.c编译为mynetfilter.ko模块。<br>附：如果你只想编译内核中某个模块的ko，也可以cd到该目录，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make CONFIG_XXX=m –c  /kernel/source/location SUBDIRS=$PWD modules</span><br></pre></td></tr></table></figure></li><li><p>内核源码树之外构建(例如ipset)<br>如果将模块代码放在内核源码树之外单独构建的话，你只需要在你的模块目录下创建一个Makefile文件，添加一行指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Obj-m := mynetfilter.o</span><br></pre></td></tr></table></figure><p>如果你有多个源文件只需添加另一行指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mynetfilter-objs := mynetfiler-init.o mynetfiler-exit.o</span><br></pre></td></tr></table></figure><p>模块在内核内和内核外构建的最大的区别在于构建过程。当模块在内核源代码树之外构建时，你必须告诉make如何找到内核源代码文件和基础Makefile文件。通过下面的指令完成上述功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make –c  /kernel/source/location SUBDIRS=$PWD modules</span><br></pre></td></tr></table></figure><p>其中，/kernel/source/location/ 即为你配置的内核源代码树的位置。SUBDIRS是你需要编译的模块位置。</p></li></ol><h3 id="Linux-内核模块加载"><a class="header-anchor" href="#Linux-内核模块加载"></a>Linux 内核模块加载</h3><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-kernelmodules/?ca=drs" target="_blank" rel="noopener">版本检查机制</a></p><h3 id="Linux路由操作"><a class="header-anchor" href="#Linux路由操作"></a>Linux路由操作</h3><p>路由：某个ip(某个范围ip)应当到哪个网关去找。网关对应下一条路由。</p><h4 id="route命令操作"><a class="header-anchor" href="#route命令操作"></a>route命令操作</h4><p>注意：route命令官方已经废弃，推荐使用ip<br><code>route -n</code><br><strong>添加默认路由：</strong><br><code>route add default gw 192.168.161.11 dev eth0</code><br><strong>添加一般路由：</strong><br><code>route add -net 192.168.62.11 netmask 255.255.255.0 gw 192.168.1.1</code><br>或<br><code>route add -net 192.168.62.0/24 gw 192.168.1.1</code><br><strong>删除路由：</strong><br><code>route del -net 192.168.62.11 netmask 255.255.255.0</code><br>或<br><code>route del -net 192.168.62.0/24</code></p><ul><li><code>net</code> 表示一个ip或者网段</li><li><code>gw</code> 表示网关或下一跳路由</li><li><code>dev</code> 表示对应的出口网卡</li></ul><h4 id="ip命令路由操作"><a class="header-anchor" href="#ip命令路由操作"></a>ip命令路由操作</h4><p><code>ip route list</code><br><code>ip -6 route add &lt;ipv6network&gt;/&lt;prefixlength&gt; dev &lt;device&gt;</code><br><code>ip route add/del &lt;network_ip&gt;/&lt;cidr&gt; via &lt;gateway_ip&gt; dev &lt;network_card_name&gt;</code><br><strong>添加默认路由：</strong><br><code>ip route add default via 10.92.2.1 dev eth0</code><br><strong>添加一般路由：</strong><br><code>ip route add 10.0.3.0/24 via 10.0.3.1 dev eth0</code><br><strong>删除路由：</strong><br><code>ip route del 10.0.3.22 via 10.0.3.1 dev eth0</code></p><h4 id="nm命令操作"><a class="header-anchor" href="#nm命令操作"></a>nm命令操作</h4><h3 id="mysql-性能优化"><a class="header-anchor" href="#mysql-性能优化"></a>mysql 性能优化</h3><p><a href="http://blog.chinaunix.net/uid-26870656-id-4287492.html" target="_blank" rel="noopener">TinkPHP 对mysql 20条优化建议</a></p><h3 id="sudo、su和sudo-s的差别"><a class="header-anchor" href="#sudo、su和sudo-s的差别"></a>sudo、su和sudo -s的差别</h3><h3 id="relocation-error-usr-lib64-libc-so-6-symbol-dl-starting-up"><a class="header-anchor" href="#relocation-error-usr-lib64-libc-so-6-symbol-dl-starting-up"></a>relocation error: /usr/lib64/libc.so.6: symbol _dl_starting_up,</h3><p>relocation error: /usr/lib64/libc.so.6: symbol _dl_starting_up, version GLIBC_PRIVATE not defined in file ld-linux-x86-64.so.2 with link time reference 问题解决<br>在建立一个错误的软连接到ld-linux-x86-64.so.2时，悲剧就这么发生了。此时大部分命令都不能使用，SSH当然也不能登录了。这个时候一定不要退出终端。</p><p>有人说那就把软连接复原吧，可是ln也同样无法使用。。。这时候我们就可以使用可爱的sln命令就可以了，哈哈。</p><p>lsn /usr/lib64/ld-2.17.so /usr/lib64/ld-linux-x86-64.so.2</p><h3 id="linux死亡操作"><a class="header-anchor" href="#linux死亡操作"></a>linux死亡操作</h3><p>随意动<code>/usr/lib64</code>或<code>/lib64</code>下的库，特别是<code>ld、libc</code>之类的，<strong>覆盖、移动和删除</strong>效果都差不多，基本就是系统爆破级别的。特别注意升级openssl，gcc都容易出现这种问题。附上linux文件目录结构（<a href="https://www.runoob.com/linux/linux-system-contents.html" target="_blank" rel="noopener">参考</a>）：<br><img src="/2020/09/14/技术札记/linux%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.jpg" alt></p><h3 id="Gcc静-动态链接库链接顺序"><a class="header-anchor" href="#Gcc静-动态链接库链接顺序"></a>Gcc静/动态链接库链接顺序</h3><p><strong>静态库</strong>链接时搜索路径顺序：</p><ol><li>ld会去找GCC命令中的参数-L</li><li>再找gcc的环境变量LIBRARY_PATH</li><li>再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的</li></ol><p><strong>动态库</strong>链接时、执行时搜索路径顺序:</p><ol><li>编译目标代码时指定的动态库搜索路径</li><li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li><li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li><li>默认的动态库搜索路径/lib</li><li>默认的动态库搜索路径/usr/lib</li></ol><p>链接时相互依赖顺序是从右到左，越是底层，越靠后写。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ ...  obj($?) -l(上层逻辑lib) -l(中间封装lib) -l(基础lib) -l(系统lib)  -o $@</span><br></pre></td></tr></table></figure><p>有关环境变量：<br>LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径<br>LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径</p><p>对于排查链接问题方法：<br><code>ldd &lt;your_lib&gt;</code>：查看可执行程序或者动态库运行时的链接库<br><code>readelf -d &lt;your_lib&gt;</code>：和ldd类似，不用运行程序，查看可执行程序或动态库<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noopener">ELF</a><br><code>LD_DEBUG=libs ./&lt;your_exe&gt;</code>：查看程序执行时的动态库调度过程。很有用。<br><code>ldconfig</code>：它会遍历默认所有共享库目录，比如/lib，/usr/lib等，然后更新所有的软链接，使她们指向最新共享库。替换了新的动态库，有时需要使用该命令来清除<code>search cache</code><br><a href="https://unix.stackexchange.com/questions/353405/cannot-find-shared-object-file-even-though-its-in-library-path" target="_blank" rel="noopener">关于动态链接库找不到的问题汇总</a></p><p>指定动态库版本或路径：<br><code>-Wl,-rpath,&lt;your_lib_path&gt;</code>: 指定程序运行时动态库链接路径。<br>将<code>-lxxx</code>直接修改为<code>/you/path/libxxx</code>，可以指定动态库的绝对路径。</p><p>参考：<br><a href="https://en.wikipedia.org/wiki/Rpath" target="_blank" rel="noopener">wiki rpath</a><br><a href="https://medium.com/nataraj-raghavendra/rpath-vs-runpath-883029b17c45" target="_blank" rel="noopener">rpath vs runpath</a> 附加了许多动态库加载的示例。<br><a href="https://www.cnblogs.com/GnibChen/p/8649476.html" target="_blank" rel="noopener">静态链接与动态链接库的查找顺序</a><br><a href="https://blog.csdn.net/ssmale/article/details/17225345" target="_blank" rel="noopener">gcc 链接库的顺序问题</a><br><a href="https://stackoverflow.com/questions/33373851/gcc-ld-what-is-to-wl-rpath-in-dynamic-linking-what-l-is-to-l-in-static-link/33378137" target="_blank" rel="noopener">gcc/ld: what is to -Wl,-rpath in dynamic linking what -l is to -L in static linking?</a><br><a href="https://stackoverflow.com/questions/25918462/why-ld-library-path-is-bad-and-the-correct-way-to-load-dynamic-libraries" target="_blank" rel="noopener">Why LD_LIBRARY_PATH is BAD and the correct way to load dynamic libraries</a></p><h3 id="有关linux下的目录"><a class="header-anchor" href="#有关linux下的目录"></a>有关linux下的目录</h3><p><a href="#linux%E6%AD%BB%E4%BA%A1%E6%93%8D%E4%BD%9C">上述</a>有相关的linux目录结构，这里说明一下<code>/tmp</code>目录，在linux系统中，<code>/tmp</code>目录在一定周期或者重启等都有可能删除相应部分符合条件的文件。而删除方法是通过执行定时任务<code>/etc/cron.daily/tmpwatch</code>，此定时任务在系统最小安装的情况下，需要手动安装。</p><h3 id="关于系统监控"><a class="header-anchor" href="#关于系统监控"></a>关于系统监控</h3><p>相对大型系统，都需要进行系统监控。特别针对于微服务系统架构。个人理解需要从三个方面进行监控(另<a href="https://zhuanlan.zhihu.com/p/83654617" target="_blank" rel="noopener">可参考</a>)：</p><ol><li>业务逻辑层，负责统计业务访问状态，访问结果，异常等(常用方式log输出。比如syslog)——通常管理员用户都关注</li><li>分布式链路追踪，又称为APM。用于追踪一个业务从开始到结束中间每个阶段的执行情况，用于多组件排错非常方便。(opentracing, Zipkin and Jaeger)——通常管理员关注</li><li>系统整体运行状态，关注系统整体内存，网络，cpu等使用情况。（Prometheus）——管理员关注</li></ol><h3 id="关于软件项目方案评估"><a class="header-anchor" href="#关于软件项目方案评估"></a>关于软件项目方案评估</h3><ol><li>易用性</li><li>可用性</li><li>性能</li><li>安全性</li><li>可维护性(日志，监控系统)</li><li>可扩展性</li></ol><h3 id="tcpdump"><a class="header-anchor" href="#tcpdump"></a>tcpdump</h3><p>非常强大的抓包工具。全面使用教程：<a href="https://colobu.com/2019/07/16/a-tcpdump-tutorial-with-examples/" target="_blank" rel="noopener">https://colobu.com/2019/07/16/a-tcpdump-tutorial-with-examples/</a></p><h3 id="linux环境加载"><a class="header-anchor" href="#linux环境加载"></a>linux环境加载</h3><ol><li>登录式shell加载：/etc/profile -&gt; /etc/profile.d/*.sh -&gt; /etc/environment -&gt; <sub>/.bash_profile（网上也说是</sub>/.profile，但我没发现） -&gt; ~/.bashrc -&gt; /etc/bashrc</li><li>非登录式bash shell窗口： ~/.bashrc -&gt;/etc/bashrc -&gt; /etc/profile.d/*.sh<br>其中系统环境在<code>/etc/environment</code>中配置，但一般不要修改它，如果你需要修改系统环境，对每个用户都生效，可以在<code>/etc/profile.d/</code>下增加sh文件。<br>如果是个人的环境变更，可以修改<code>~/.bash_profile</code>，如果需要执行一些公共方法，或者别名(alias)之类的，可以在<code>~/.bashrc</code>中增加。</li></ol><p><a href="https://blog.csdn.net/wackycrazy/article/details/47998747" target="_blank" rel="noopener">参考</a></p><h3 id="设计模式的六大原则："><a class="header-anchor" href="#设计模式的六大原则："></a>设计模式的六大原则：</h3><p><a href="http://www.uml.org.cn/sjms/201211023.asp" target="_blank" rel="noopener">参考</a><br><strong>单一职责原则</strong>：<br>即一个类只负责一项职责<br><strong>里氏替换原则</strong>：<br>类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。<br><strong>依赖倒置原则</strong>：<br>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。<br><strong>接口隔离原则</strong>：<br>一个模块不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。<br><strong>迪米特法则</strong>：<br>一个对象应该对其他对象保持最少的了解。<br><strong>开闭原则</strong>：<br>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。<br>即：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p><h3 id="mysql-bin-log："><a class="header-anchor" href="#mysql-bin-log："></a>mysql-bin-log：</h3><ol><li>只有特定版本以上支持binlog</li><li>有三种binlog记录模式：row，statement，mixed。<a href="https://www.linuxidc.com/Linux/2018-08/153612.htm" target="_blank" rel="noopener">详情</a></li><li><code>unknown variable 'default-character-set=utf8'</code>解决方法：增加参数<code>--no-defaults</code></li><li>row模式下查看详细sql语句，在mysqlbinlog下增加<code>-v</code>参数。</li><li>mysql5.7.30对应的mysqlbinlog版本是3.4，可以通过<code>mysqlbinlog --version</code>查看</li><li>binlog的查看方式<a href="https://blog.csdn.net/nuli888/article/details/52117646" target="_blank" rel="noopener">参考</a></li></ol><h3 id="linux下载离线rpm包"><a class="header-anchor" href="#linux下载离线rpm包"></a>linux下载离线rpm包</h3><p><a href="https://www.cnblogs.com/daodaotest/p/12452290.html#5" target="_blank" rel="noopener">https://www.cnblogs.com/daodaotest/p/12452290.html#5</a></p><h3 id="git-submodule"><a class="header-anchor" href="#git-submodule"></a>git submodule</h3><p>注意:</p><ol><li>参考中的所有命令，最好都在项目根目录执行。否则容易出现看起来不生效的问题。</li><li>执行<code>git submodule add &lt;url&gt;</code>生成的对应子模块目录，要一并提交，不要删除。</li><li>如何删除submodule：<a href="https://stackoverflow.com/questions/1260748/how-do-i-remove-a-submodule" target="_blank" rel="noopener">How do I remove a Git submodule</a></li></ol><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">参考</a></p><h3 id="git-merge提前检测冲突"><a class="header-anchor" href="#git-merge提前检测冲突"></a>git merge提前检测冲突</h3><p><a href="https://www.zhihu.com/question/319861963" target="_blank" rel="noopener">参考</a></p><h3 id="排查cpu占用高，或进程死锁问题"><a class="header-anchor" href="#排查cpu占用高，或进程死锁问题"></a>排查cpu占用高，或进程死锁问题</h3><ol><li>使用<code>top</code>查看当前系统状态。<a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316399.html" target="_blank" rel="noopener">命令用法</a>，<code>free</code>命令协助查看内存占用。<a href="https://www.cnblogs.com/ultranms/p/9254160.html" target="_blank" rel="noopener">free命令详解</a>(<code>-h</code>已经不行了，要<code>-m</code>)</li><li>使用<code>strace</code>打出当前进程的系统调用，分析是什么系统调用导致异常。</li><li>多线程的情况下，可以使用<code>pstack</code>打印每个线程的堆栈信息，对死锁问题有很大帮助。</li><li>可以考虑使用<code>gdb</code>调试跟踪进程(会影响进程正常工作)，发现更详细问题。</li></ol><h3 id="关于unix-sock和localhost-tcp对比"><a class="header-anchor" href="#关于unix-sock和localhost-tcp对比"></a>关于unix sock和localhost tcp对比</h3><p><a href="https://lists.freebsd.org/pipermail/freebsd-performance/2005-February/001143.html" target="_blank" rel="noopener">unix domain sockets vs. internet sockets</a></p><h3 id="Go和Rust的区别"><a class="header-anchor" href="#Go和Rust的区别"></a>Go和Rust的区别</h3><p><a href="https://jishuin.proginn.com/p/763bfbd31320" target="_blank" rel="noopener">参考</a></p><h3 id="git代码仓库管理"><a class="header-anchor" href="#git代码仓库管理"></a>git代码仓库管理</h3><p><a href="https://blog.csdn.net/bocai_xiaodaidai/article/details/103814409" target="_blank" rel="noopener">中文参考</a><br><a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">英文参考</a></p><h3 id="网络快速学习"><a class="header-anchor" href="#网络快速学习"></a>网络快速学习</h3><p><a href="https://mp.weixin.qq.com/s/IOCUGXjKCQV8qPycxhM2YA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/IOCUGXjKCQV8qPycxhM2YA</a><br>路由中有个类似:<code>192.168.88.0/24 dev eth1 scope link</code>这种路由，如果你<code>ping 192.168.88.0/24</code>网段的ip，那么会进行路由匹配，命中改路由，认为这个是本地路由，直接进行本地广播链接</p><p><strong>为什么需要三次握手？</strong></p><ul><li>第一次握手：客户发送请求，此时服务器知道客户能发；</li><li>第二次握手：服务器发送确认，此时客户知道服务器能发能收；</li><li>第三次握手：客户发送确认，此时服务器知道客户能收。</li></ul><p><strong>客户端TIME_WAIT为什么需要等待2MSL?</strong></p><ul><li>最后一个报文没有确认；</li><li>确保发送方的ACK可以到达接收方；</li><li>2MSL时间内没有收到，则接收方会重发；</li><li>确保当前连接的所有报文都已经过期。</li></ul><p><strong>TCP四次挥手，为什么是四次？</strong><br><a href="https://blog.csdn.net/Shuffle_Ts/article/details/93909003" target="_blank" rel="noopener">关于为何要四次挥手</a></p><h3 id="Go自动化测试"><a class="header-anchor" href="#Go自动化测试"></a>Go自动化测试</h3><p><a href="https://www.infoq.cn/article/goyirzr19vqvtupois92" target="_blank" rel="noopener">一个 Golang 项目的测试实践全记录</a><br><a href="https://learnku.com/articles/52896#9daa8c" target="_blank" rel="noopener">GoLang快速上手单元测试</a><br><a href="https://github.com/golang/mock/" target="_blank" rel="noopener">GoMock</a>：</p><ol><li>用于接口，测试方法是实现你某个函数的接口，来测试你上次业务逻辑。httpmock就是自定义实现<code>Transport</code>来实现。</li><li>可以无侵入式测试业务逻辑，可脱离数据库，网络等底层带有<code>interface</code>的依赖</li></ol><p><a href="net/http/httptest">httptest</a>：<br>官方提供的一个http测试桩的库，在依赖第三方服务时，可使用该测试脱离第三方测试。<br><a href="https://www.cnblogs.com/Detector/p/9769840.html" target="_blank" rel="noopener">使用标准库httptest完成HTTP请求的Mock测试</a></p><p><a href="https://github.com/smartystreets/goconvey" target="_blank" rel="noopener">GoConvey</a>：<br>严格上来说，只是一个用于test的ui页面展示工具，方便查看代码的测试覆盖情况和通过情况等。</p><p><a href="https://github.com/DATA-DOG/go-sqlmock" target="_blank" rel="noopener">sqlmock</a><br>用于提供数据库的mock</p><p><a href="https://github.com/agiledragon/gomonkey" target="_blank" rel="noopener">gomonkey</a><br>做函数和变量替换。进行打桩</p><p><strong>自动化测试常见场景：</strong><br><a href="https://new.qq.com/omn/20210727/20210727A0AWOH00.html" target="_blank" rel="noopener">一文说尽Golang单元测试实战的那些事儿</a></p><p>单元测试：<br>使用官方推荐的test即可，保证逻辑拆分以及每个模块都写上单元测试。</p><p>表格驱动测试：<br>表格驱动测试通过定义一组不同的输入，可以让代码得到充分的测试，同时也能有效地测试负路径。比如在<code>golang</code>中使用<code>t.Run(name string, subTest func(t *T))</code>来测试多种情况。<br>可以使用更强大直观的<code>GoConvey</code>在配置多个测试用例</p><p>http接口依赖：<br>可使用<code>httptest</code>解除依赖</p><p>依赖底层接口或者第三方函数：<br>接口依赖，可以使用<code>GoMock</code>解决<br>第三方函数依赖，可以使用<code>gomonkey</code>进行函数替换解决</p><p>数据库依赖：<br><code>mysql</code>依赖：可使用<code>sqlmock</code><br><code>redis</code>依赖: 可以使用<code>miniredis</code>搭建一个微型服务器。<br>通常数据库都是以接口形式实现的，也可以通过<code>GoMock</code>来自定义做自定义返回。</p><h3 id="查看哪个进程向我发送了信号"><a class="header-anchor" href="#查看哪个进程向我发送了信号"></a>查看哪个进程向我发送了信号</h3><p><code>strace -p 59951 -e 'trace=!all'</code></p><h3 id="缓存技术"><a class="header-anchor" href="#缓存技术"></a>缓存技术</h3><ol><li>FIFO</li><li>LFU</li><li>LRU<ol><li>LUR-K: LRU-2常用</li><li>2Q: FIFO+LRU</li></ol></li></ol><h3 id="linux-向本地syslog发数据"><a class="header-anchor" href="#linux-向本地syslog发数据"></a>linux 向本地syslog发数据</h3><p><a href="https://blog.csdn.net/u011630575/article/details/52055116" target="_blank" rel="noopener">logger详解</a><br>示例：<code>logger -i -t &quot;my_test&quot; -p local3.notice &quot;test_info&quot; </code></p><h3 id="证书常用命令"><a class="header-anchor" href="#证书常用命令"></a>证书常用命令</h3><ol><li><p>pfx格式转crt格式（未验证，有问题）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -in myssl.pfx -nodes -out server.pem</span><br><span class="line">openssl rsa -in server.pem -out server.key</span><br><span class="line">openssl x509 -in server.pem -out server.crt</span><br></pre></td></tr></table></figure></li><li><p>crt格式转pfx<br><code>openssl pkcs12 -export -in server.crt -inkey server.key -out server.pfx</code></p></li><li><p>crt的key增加密码<br><code>openssl pkey -in server.key -out server_1.key -passout pass:&quot;12345678&quot;</code></p></li><li><p>查看pem证书</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -noout -text -in myserver.key</span><br><span class="line">openssl req -noout -text -in myserver.csr</span><br><span class="line">openssl x509 -noout -text -in ca.crt</span><br></pre></td></tr></table></figure></li></ol><h3 id="kill-9无法杀死的情况"><a class="header-anchor" href="#kill-9无法杀死的情况"></a>kill -9无法杀死的情况</h3><p><a href="https://www.ibm.com/support/pages/why-cant-i-kill-my-process" target="_blank" rel="noopener">参考</a><br>正常情况<code>kill</code>命令发送的是<code>SIGTERM</code>信号，表示用户想要中断，进程可以优雅的退出。<br>而<code>kill -9</code>发送的是<code>SIGKILL</code>信号，表示直接杀死进程，但是有两种情况是杀不掉的：</p><ol><li>该进程是<a href="https://blog.csdn.net/eunice_fan1207/article/details/81387417" target="_blank" rel="noopener">僵尸进程</a>，此时进程已经释放所有的资源，但是没有被父进程释放。僵尸进程要等到父进程结束，或者重启系统才可以被释放。</li><li>进程处于“核心态”，并且在等待不可获得的资源，处于“核心态 ”的资源默认忽略所有信号。只能重启系统。</li></ol><h3 id="进程通信的各种情况，以及适用场景"><a class="header-anchor" href="#进程通信的各种情况，以及适用场景"></a>进程通信的各种情况，以及适用场景</h3><p><a href="https://blog.csdn.net/zy20150613/article/details/80089704" target="_blank" rel="noopener">共享内存的实现详解</a></p><h3 id="性能排查工具大全"><a class="header-anchor" href="#性能排查工具大全"></a>性能排查工具大全</h3><p><a href="https://www.cnblogs.com/sjli-blog/p/15076966.html" target="_blank" rel="noopener">参考</a><br><img src="/2020/09/14/技术札记/linux%E6%80%A7%E8%83%BD%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%85%A8.png" alt></p><h3 id="wireshark解密https："><a class="header-anchor" href="#wireshark解密https："></a>wireshark解密https：</h3><p>secret<br><a href="https://www.cnblogs.com/yurang/p/11505741.html" target="_blank" rel="noopener">参考</a></p><ol><li>证书导入：<ol><li>首先导出pkcs12类型的证书(会要求输入密码)：<code>openssl pkcs12 -export -in gateway.pem -out key.pkcs12</code></li><li>在wireshark中选择编辑-&gt;首选项-&gt;协议-&gt;tls，选择RSA key list：<br><img src="/2020/09/14/技术札记/wireshark_1.jpg" alt></li><li>导入服务器证书：<img src="/2020/09/14/技术札记/wireshark_2.jpg" alt></li></ol></li><li>环境配置导入：<ol><li>设置环境变量：SSLKEYLOGFILE=路径\sslkey.log</li><li>wireshark中配置相应链接文件：<img src="/2020/09/14/技术札记/wireshark_3.jpg" alt></li></ol></li></ol><h3 id="方案调研方法"><a class="header-anchor" href="#方案调研方法"></a>方案调研方法</h3><ol><li>明确需求</li><li>从网上查找对应的解决方案：<ol><li>GitHub的<a href="https://github.com/topics" target="_blank" rel="noopener">topic</a></li><li>工具索引对比类网站<a href="https://stackshare.io/feed" target="_blank" rel="noopener">stackshare</a>，<a href="https://www.libhunt.com/" target="_blank" rel="noopener">LibHunt</a></li></ol></li></ol><h3 id="代码覆盖率统计"><a class="header-anchor" href="#代码覆盖率统计"></a>代码覆盖率统计</h3><p><a href="https://www.jianshu.com/p/a42bbd9de1b7" target="_blank" rel="noopener">关于代码覆盖lcov的使用</a></p><h3 id="linux下C死锁排查"><a class="header-anchor" href="#linux下C死锁排查"></a>linux下C死锁排查</h3><p><a href="https://blog.csdn.net/zsiming/article/details/126695393" target="_blank" rel="noopener">https://blog.csdn.net/zsiming/article/details/126695393</a></p><h3 id="valgrind使用"><a class="header-anchor" href="#valgrind使用"></a>valgrind使用</h3><p>内存泄漏分析，性能分析:<a href="https://zhuanlan.zhihu.com/p/92074597" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/92074597</a></p><h3 id="gdb十六进制打印"><a class="header-anchor" href="#gdb十六进制打印"></a>gdb十六进制打印</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /5xb ptr</span><br></pre></td></tr></table></figure><p>格式: x /nfu<br>参数说明：<br>n表示要显示的内存单元的个数<br>f表示显示方式, 可取如下值<br>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>i 指令地址格式<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。<br>u 表示一个地址单元的长度<br>b 表示单字节，<br>h 表示双字节，<br>w 表示四字节，<br>g 表示八字节</p><h3 id="基于nc的反向代理"><a class="header-anchor" href="#基于nc的反向代理"></a>基于nc的反向代理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkfifo nc_proxy</span><br><span class="line">(nc dst_ip dst_port &lt; nc_porxy) | (nc -k -l 0.0.0.0 12345 &gt; ./nc_porxy)</span><br></pre></td></tr></table></figure><p>-k 表示可以建立多条sock<br>上述命令含义：<br>上行：在当前设备上建立12345监听，接收数据输出到管道nc_proxy，nc_proxy作为<code>nc dst_ip dst_port &lt; nc_porxy</code>输入<br>下行：<code>nc dst_ip dst_port &lt; nc_porxy</code>命令输出下行数据，通过<code>|</code>输入给<code>nc -k -l 0.0.0.0 12345 &gt; ./nc_porxy</code></p><h3 id="堆栈段偏移排查"><a class="header-anchor" href="#堆栈段偏移排查"></a>堆栈段偏移排查</h3><p>对于一些堆栈溢出的日志，可以通过下面命令排查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr2line -e [进程] [相对地址]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./lb(dumpBacktrace+0x44f)[0x6f32fd]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x3ef20)[0x7ff61b3a5f20]</span><br><span class="line">./lb(clientSessionRemove+0x277)[0x476713]</span><br><span class="line">./lb(clientTcpMsgProc+0x63e)[0x47a914]</span><br><span class="line">./lb(HTTP2JobMaster+0x122)[0x45f6fa]</span><br><span class="line">./lb(Http2JobEntry+0x100)[0x46017f]</span><br><span class="line">./lb(ScheProcMsg+0x245)[0x68292c]</span><br><span class="line">./lb(IoThread+0x173)[0x683878]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ addr2line -e ./lb 0x47a914</span><br><span class="line">/home/xxxx/src/http2-client.c:1226</span><br></pre></td></tr></table></figure><h3 id="zsh快捷键"><a class="header-anchor" href="#zsh快捷键"></a>zsh快捷键</h3><p>基本命令：<br><strong>ctrl + u：清空当前行</strong><br><strong>ctrl + a：移动到行首</strong><br><strong>ctrl + e：移动到行尾</strong><br>ctrl + f：向前移动<br>ctrl + b：向后移动<br>ctrl + p：上一条命令<br>ctrl + n：下一条命令<br><strong>ctrl + r：搜索历史命令</strong><br><strong>ctrl + y：召回最近用命令删除的文字</strong><br>ctrl + h：删除光标之前的字符<br>ctrl + d：删除光标所指的字符<br><strong>ctrl + w：删除光标之前的单词</strong><br><strong>ctrl + k：删除从光标到行尾的内容</strong><br>ctrl + t：交换光标和之前的字符</p><p>命令自动补全(zsh-autosuggestions)：<br><strong>ctrl + →：到自动补全命令的下一个单词</strong><br><strong>→：到自动补全命令末尾</strong></p><h3 id="const"><a class="header-anchor" href="#const"></a>const</h3><p><code>const char *ptr;</code>: const 修饰的是<code>*ptr</code>，意味着指针指向的数据不能修改<br><code>char const *ptr;</code>：同<code>const char *ptr;</code><br><code>char * const ptr;</code>:const 修饰的是<code>ptr</code>，意味着指针本身不能修改</p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于如何写文档</title>
      <link href="/2020/09/14/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%86%99%E6%96%87%E6%A1%A3/"/>
      <url>/2020/09/14/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%86%99%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>技术文档如何写的清晰明了？ 头大。(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><a id="more"></a><p>上一个我比较喜欢的技术文档书写风格<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-kernelmodules/?ca=drs" target="_blank" rel="noopener">示例</a></p><p><strong>题目：</strong> 表述你文档核心内容<br><strong>概述：</strong> 做基础背景介绍或目的介绍(默认阅读相关内容的人有相关行业背景)<br><strong>内容：</strong> 按照一定逻辑进行叙述(大-&gt;小、流程顺序、时间顺序、依赖操作顺序)<br><strong>其他：</strong> 引用和备注</p><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: xxx技术分析</span><br><span class="line">date: 2021-03-09 10:29:26</span><br><span class="line">categories: 技术杂谈</span><br><span class="line">tags: [xxx]</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">从实践入门介绍nginx(•̀⌄•́)</span><br><span class="line">　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</span><br><span class="line">* * *</span><br><span class="line">&lt;概要&gt;：从模块开发了解nginx的使用以及nginx整体结构。从源码原理解析了解nginx底层设计和各种优化操作。</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">## 序</span><br><span class="line">背景，或者预先需要了解什么</span><br><span class="line"></span><br><span class="line">## 主要内容</span><br><span class="line">### 观点1</span><br><span class="line">### 观点2</span><br><span class="line">### 观点3</span><br><span class="line"></span><br><span class="line">###  其他</span><br><span class="line">#### 可以列出相关的看过的书籍，或者问题参考链接网页一类的。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客使用指南</title>
      <link href="/2020/09/14/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2020/09/14/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>久了不更新博客，就不知道怎么搞环境了，换了环境又得查。索性自己写个简单的(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　by JiHan</p><hr><a id="more"></a><p>可根据自己的需求进行快速定位，本文对应的发布环境是GitHub</p><h3 id="从0-1搭建hexo网站"><a class="header-anchor" href="#从0-1搭建hexo网站"></a>从0-1搭建hexo网站</h3><p>我就不做copper了，直接上链接：<br><a href="https://godweiyang.com/2018/04/13/hexo-blog/" target="_blank" rel="noopener">超详细Hexo+Github博客搭建小白教程</a><br><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">hexo主题next</a>（我自己用的）<br><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">hexo主题推荐</a><br><a href="https://www.jianshu.com/p/3ff20be8574c" target="_blank" rel="noopener">hexo主题美化1</a><br><a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">hexo主题美化2</a><br><a href="https://valine.js.org/" target="_blank" rel="noopener">评论系统</a></p><h3 id="已有博客，环境迁移"><a class="header-anchor" href="#已有博客，环境迁移"></a>已有博客，环境迁移</h3><p>主要是相应环境安装：</p><ol><li><p>node.js <a href="https://nodejs.org/zh-cn/download/releases/" target="_blank" rel="noopener">官方下载</a>, 我这里选择的是12.x的版本。<br>windows直接点安装<br>Linux下载解压后，配置路径<code>export PATH=$PATH:xxxx/node-v14.10.0-linux-x64/bin</code></p></li><li><p>git安装<br>windows直接点安装<br>Liunx <code>sudo yum install git</code>或<code>sudo apt install git</code></p></li><li><p>安装hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-cli -g</span><br><span class="line"></span><br><span class="line"> #配置git扩展，在你自己的博客里肯定已经配置了项目地址关联</span><br><span class="line">npm i hexo-deployer-git</span><br></pre></td></tr></table></figure></li><li><p>可能有必要<br>如果项目里没有node_modules文件夹，需要到博客根目录重新安装一波：<code>npm install</code></p></li></ol><h3 id="已有环境，新发文"><a class="header-anchor" href="#已有环境，新发文"></a>已有环境，新发文</h3><p>发文常用命令(通常都是顺序执行)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 新建文章</span><br><span class="line">hexo new post &quot;article title&quot;</span><br><span class="line"># 生成博客网页文件</span><br><span class="line">hexo g  </span><br><span class="line"># 本地预览博客</span><br><span class="line">hexo s  </span><br><span class="line">hexo s -i 0.0.0.0 -p 8080 #指定监听地址端口</span><br><span class="line"># 上传网页文件到github</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>博客源码备份：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">git add -u</span><br><span class="line">git commit -m &quot;new post&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="常用Markdown语法"><a class="header-anchor" href="#常用Markdown语法"></a>常用Markdown语法</h3><p>主要针对GitHub，参考<a href="https://docs.github.com/cn/free-pro-team@latest/github/writing-on-github/basic-writing-and-formatting-syntax" target="_blank" rel="noopener">官方文档</a><br><em>注意语法中的空格</em></p><h4 id="标题"><a class="header-anchor" href="#标题"></a>标题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 最大标题</span><br><span class="line">## 第二大标题</span><br><span class="line">###### 最小标题</span><br></pre></td></tr></table></figure><h4 id="样式文本"><a class="header-anchor" href="#样式文本"></a>样式文本</h4><table><thead><tr><th>样式</th><th>语法</th></tr></thead><tbody><tr><td>粗体</td><td>** ** 或 __ __</td></tr><tr><td>斜体</td><td>* * 或 _ _</td></tr><tr><td>删除线</td><td>~~ ~~</td></tr><tr><td>粗体和嵌入的斜体</td><td>** ** 和 _ _</td></tr><tr><td>全部粗体和斜体</td><td>*** ***</td></tr></tbody></table><h4 id="引用文本"><a class="header-anchor" href="#引用文本"></a>引用文本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用的文本</span><br></pre></td></tr></table></figure><h4 id="引用代码"><a class="header-anchor" href="#引用代码"></a>引用代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`单行代码引用`</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```json(代码类型)</span><br><span class="line"> 多行代码引用</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>如果想在代码块中显示```, 只需要外层的` 比内层的多即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```` 代码块标识</span><br><span class="line">```json</span><br><span class="line">显示的代码</span><br><span class="line">```</span><br><span class="line">````</span><br></pre></td></tr></table></figure><h4 id="链接"><a class="header-anchor" href="#链接"></a>链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[普通链接](https://jihanhuang.github.io/)</span><br><span class="line">![图片链接](./技术札记/ssh免密登录原理.png)</span><br><span class="line">[下载链接](./《mysql必知必会》读书笔记/mysql_scripts.zip)</span><br><span class="line">[文章导航链接](#已有博客环境迁移)</span><br></pre></td></tr></table></figure><h4 id="列表"><a class="header-anchor" href="#列表"></a>列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. James Madison</span><br><span class="line">2. James Monroe</span><br><span class="line">3. John Quincy Adams</span><br></pre></td></tr></table></figure><p><code>*</code>或<code>-</code>都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- George Washington</span><br><span class="line">- John Adams</span><br><span class="line">- Thomas Jefferson</span><br></pre></td></tr></table></figure><p>嵌套(子列表的<code>-</code>需在父列表的第一个字下)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 第一个列表项</span><br><span class="line">   -  第一个嵌套列表项</span><br><span class="line">     - 第二个嵌套列表项</span><br></pre></td></tr></table></figure><p>任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- [x] 完成更改</span><br><span class="line">- [ ] 推送提交到 GitHub</span><br><span class="line">- [ ] 打开拉取请求</span><br><span class="line">- [ ] \(Optional) 规避[]后的()</span><br></pre></td></tr></table></figure><h4 id="表格"><a class="header-anchor" href="#表格"></a>表格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|列标题|列标题|</span><br><span class="line">|---|---|</span><br><span class="line">|数据11|数据21 &lt;br&gt; br表示换行|</span><br><span class="line">|数据12|数据22|</span><br></pre></td></tr></table></figure><h4 id="绘图"><a class="header-anchor" href="#绘图"></a>绘图</h4><p>hexo自身都不支持Markdown标准绘图和Mermaid。需要进行配置：<br>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-filter-mermaid-diagrams</span><br><span class="line">npm install --save hexo-filter-sequence</span><br><span class="line">npm install --save hexo-filter-flowchart</span><br></pre></td></tr></table></figure><p>Mermaid配置可以阅读：<a href="https://tyloafer.github.io/posts/7790/" target="_blank" rel="noopener">Hexo中引入Mermaid流程图</a>，引用部分如下：</p><blockquote><p>Mermaid还需要进行配置(根目录下_config.yml)，增加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; # mermaid chart</span><br><span class="line">&gt; mermaid: ## mermaid url https://github.com/knsv/mermaid</span><br><span class="line">&gt;   enable: true  # default true</span><br><span class="line">&gt;   version: &quot;7.1.2&quot; # default v7.1.2</span><br><span class="line">&gt;   options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span><br><span class="line">&gt;     #startOnload: true  // default true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>以及修改js，我这里使用的是<code>next</code>主题。在文件<code>themes/next/layout/_partials/footer.swig</code>后&gt;加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123;% if (theme.mermaid.enable)  %&#125;</span><br><span class="line">&gt;   &lt;script src=&apos;https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">&gt;   &lt;script&gt;</span><br><span class="line">&gt;     if (window.mermaid) &#123;</span><br><span class="line">&gt;       mermaid.initialize(&#123;theme: &apos;forest&apos;&#125;);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;   &lt;/script&gt;</span><br><span class="line">&gt; &#123;% endif %&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>语法绘图：<br>graphviz：较为复杂，特别是时序图，但功能强大。<a href="https://sketchviz.com/new" target="_blank" rel="noopener">graphviz在线绘图</a>，<a href="https://onlookerliu.github.io/2017/12/28/dot%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/#1-%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener">graphviz dot语法总结</a><br>plantuml：绘图风格单一(个人不觉得丑)，但画时序图很快，模板多，本体使用需要java支持。<a href="https://www.planttext.com/" target="_blank" rel="noopener">plantmul在线绘图</a>：多个模板供选择。能接受画面的，还是推荐使用<br>Mermaid：功能简单，绘图较快，美观度还可以，很多Markdown编辑器都支持。<a href="https://mermaid-js.github.io/mermaid/#/" target="_blank" rel="noopener">语法</a>，个人使用感觉功能太少(可能是插件支持不友好)</p><h5 id="示例"><a class="header-anchor" href="#示例"></a>示例</h5><p><em><a href="https://www.runoob.com/markdown/md-advance.html" target="_blank" rel="noopener">来源</a></em></p><p><strong>Mermaid：</strong><br><a href="https://mermaid-js.github.io/mermaid/#/" target="_blank" rel="noopener">语法</a><br>流程图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```&lt;添加标签：mermaid&gt;</span><br><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a=1| D[结果1]</span><br><span class="line">    C --&gt; |a=2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果：</p><pre class="mermaid">graph TDA[方形] --> B(圆角)    B --> C{条件a}    C --> |a=1| D[结果1]    C --> |a=2| E[结果2]    F[竖向流程图]</pre><p>UML样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```&lt;添加标签：mermaid&gt;</span><br><span class="line">  sequenceDiagram</span><br><span class="line">    participant 张三</span><br><span class="line">    participant 李四</span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line">    loop 健康检查</span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line">    end</span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...</span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line">    李四--&gt;王五: 很好!</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果：</p><pre class="mermaid">  sequenceDiagram    participant 张三    participant 李四    张三->王五: 王五你好吗？    loop 健康检查        王五->王五: 与疾病战斗    end    Note right of 王五: 合理 食物 <br>看医生...    李四-->>张三: 很好!    王五->李四: 你怎么样?    李四-->王五: 很好!</pre><p>甘特图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">````&lt;添加标签：mermaid&gt;</span><br><span class="line">      gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title 软件开发甘特图</span><br><span class="line">        section 设计</span><br><span class="line">        需求                      :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        原型                      :active,  des2, 2014-01-09, 3d</span><br><span class="line">        UI设计                     :         des3, after des2, 5d</span><br><span class="line">    未来任务                     :         des4, after des3, 5d</span><br><span class="line">        section 开发</span><br><span class="line">        学习准备理解需求                      :crit, done, 2014-01-06,24h</span><br><span class="line">        设计框架                             :crit, done, after des2, 2d</span><br><span class="line">        开发                                 :crit, active, 3d</span><br><span class="line">        未来任务                              :crit, 5d</span><br><span class="line">        耍                                   :2d</span><br><span class="line">        section 测试</span><br><span class="line">        功能测试                              :active, a1, after des3, 3d</span><br><span class="line">        压力测试                               :after a1  , 20h</span><br><span class="line">        测试报告                               : 48h</span><br><span class="line">````</span><br></pre></td></tr></table></figure><p>效果：</p><pre class="mermaid">      gantt        dateFormat  YYYY-MM-DD        title 软件开发甘特图        section 设计        需求                      :done,    des1, 2014-01-06,2014-01-08        原型                      :active,  des2, 2014-01-09, 3d        UI设计                     :         des3, after des2, 5d    未来任务                     :         des4, after des3, 5d        section 开发        学习准备理解需求                      :crit, done, 2014-01-06,24h        设计框架                             :crit, done, after des2, 2d        开发                                 :crit, active, 3d        未来任务                              :crit, 5d        耍                                   :2d        section 测试        功能测试                              :active, a1, after des3, 3d        压力测试                               :after a1  , 20h        测试报告                               : 48h</pre><p><strong>Markdown标准支持：</strong><br>流程图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">``` &lt;添加标签：flow&gt;</span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果：</p><div id="flowchart-0" class="flow-chart"></div><p>流程图(横向)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```&lt;添加标签：flow&gt;</span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果：</p><div id="flowchart-1" class="flow-chart"></div>UML样例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```&lt;添加标签：sequence&gt;</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果：</p><div id="sequence-0"></div>UML复杂样例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```&lt;添加标签：sequence&gt;</span><br><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果：</p><div id="sequence-1"></div><h4 id="段落"><a class="header-anchor" href="#段落"></a>段落</h4><p>通过在文本行之间留一个空白行，可创建新段落。</p><h4 id="忽略Markdown格式"><a class="header-anchor" href="#忽略Markdown格式"></a>忽略Markdown格式</h4><ol><li>使用代码块</li><li>使用<code>\</code></li></ol><h4 id="使用表情符号"><a class="header-anchor" href="#使用表情符号"></a>使用表情符号</h4><p>通过键入 <code>:EMOJICODE:</code> 可在您的写作中添加表情符号。<br>比如<code>:+1:</code> 👍<br>hexo默认是不支持表情符号的，因此我把hexo的Markdown引擎改为了<code>hexo-renderer-markdown-it</code>来支持表情。听说这个渲染更快，还支持插件（我尝试增加了几个插件markdown-it-mermaid，markdown-it-graphviz之类的，支持的都不好）。<a href="http://baishusama.github.io/2016/12/24/hexo-render-markdown-it-and-its-plugins/" target="_blank" rel="noopener">详情请参考</a></p><p>更多表情符号参考<a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">emoji-cheat-sheet</a> 😎</p><h3 id="可能遇到问题"><a class="header-anchor" href="#可能遇到问题"></a>可能遇到问题</h3><p><strong>发布图片视频音频：</strong><br>图片发布很简单：<br>你在<code>hexo new post &quot;xxx&quot;</code>会在__posts下生成一个对应xxx.md和一个xxx文件夹。图片放在文件夹里，文章里引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![hello](xxx/image.jpg)</span><br></pre></td></tr></table></figure><p>这里可能发现本地可以显示图片，上传到GitHub就不能显示了。可以安装以下插件解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/26a7fc7cc185" target="_blank" rel="noopener">视频发布</a><br><strong>github配置域名发布后被清空：</strong><br>在对应source目录下新建一个CNAME文件，只放置一行你指向的域名。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># tree Blog/source/ -L 1</span><br><span class="line">Blog/source/</span><br><span class="line">|-- categories</span><br><span class="line">|-- CNAME</span><br><span class="line">|-- download</span><br><span class="line">|-- _posts</span><br><span class="line">|-- tags</span><br><span class="line">`-- uploads</span><br><span class="line"># cat Blog/source/CNAME </span><br><span class="line">xxx.com</span><br></pre></td></tr></table></figure><p><strong>执行<code>hexo d</code>时，上传提示使用token</strong><br><a href="https://whale3070.github.io/2021/08/15/github%E5%AF%86%E7%A0%81%E5%A4%B1%E6%95%88-hexo-d%E5%A4%B1%E8%B4%A5/" target="_blank" rel="noopener">参考</a><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始框op=>operation: 处理框cond=>condition: 判断框(是或否?)sub1=>subroutine: 子流程io=>inputoutput: 输入输出框e=>end: 结束框st->op->condcond(yes)->io->econd(no)->sub1(right)->op</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">st=>start: 开始框op=>operation: 处理框cond=>condition: 判断框(是或否?)sub1=>subroutine: 子流程io=>inputoutput: 输入输出框e=>end: 结束框st(right)->op(right)->condcond(yes)->io(bottom)->econd(no)->sub1(right)->op</textarea><textarea id="flowchart-1-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">对象A->对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B-->对象A: 我很好(响应)对象A->对象B: 你真的好吗？</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">Title: 标题：复杂使用对象A->对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B-->对象A: 我很好(响应)对象B->小三: 你好吗小三-->>对象A: 对象B找我了对象A->对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩</textarea><textarea id="sequence-1-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script></p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ipset消息通信</title>
      <link href="/2020/05/18/ipset%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1/"/>
      <url>/2020/05/18/ipset%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>这里列出了一些ipset消息通信的格式，并且附加了ipset命令的debug版本。(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em>先看之前的<a href="/2020/05/06/libipset源码分析/" title="libipset源码分析">libipset源码分析</a></em></p><a id="more"></a><p>源码分析里讲解了ipset的通信机制，这里主要是列出一些示例。也就是ipset通信时的消息体部分。再挂一下这张图：<br><img src="/2020/05/18/ipset消息通信/netlink%E6%95%B0%E6%8D%AE%E5%85%B3%E7%B3%BB.png" alt="netlink数据结构之间的关系"><br><em><a href="https://blog.csdn.net/zhao_h/article/details/80943226" target="_blank" rel="noopener">图片来源</a></em></p><p><strong>示例</strong><br>尝试运行命令<code>ipset list test_net</code>得到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jihan]# ./ipset list test_net</span><br><span class="line">Name: test_net</span><br><span class="line">Type: hash:net</span><br><span class="line">Revision: 1</span><br><span class="line">Header: family inet hashsize 1024 maxelem 65536</span><br><span class="line">Size in memory: 16816</span><br><span class="line">References: 0</span><br><span class="line">Members:</span><br><span class="line">1.1.2.0/31</span><br></pre></td></tr></table></figure><p><em>当然test_net是我之前就添加好了的。这里只是举例，是个ipset正确命令就行。</em><br>这里显示的就是正常ipset命令下的运行结果，我编译了一个ipset的<a href="/download/ipset_DD">debug版本</a>(对应源码libipset7.6)，并且加了一些打印，可以得到一下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Message header: received cmd  LIST (7)</span><br><span class="line">len 140</span><br><span class="line">flag EXIST</span><br><span class="line">seq 1589773040</span><br><span class="line">Command attributes:</span><br><span class="line">PROTOCOL: 6</span><br><span class="line">SETNAME: test_net</span><br><span class="line">TYPENAME: hash:net</span><br><span class="line">REVISION: 1</span><br><span class="line">FAMILY: 2</span><br><span class="line">CREATE attributes:</span><br><span class="line">HASHSIZE: 1024</span><br><span class="line">MAXELEM: 65536</span><br><span class="line">REFERENCES: 0</span><br><span class="line">MEMSIZE: 16816</span><br><span class="line">ADT attributes:</span><br><span class="line">IP: 1.1.2.0</span><br><span class="line">CIDR: 31</span><br><span class="line">Recv hdr:</span><br><span class="line">0x8c 0x00 0x00 0x00 0x07 0x06 0x02 0x00 0xf0 0x02 0xc2 0x5e 0xe5 0x2b 0x01 0x00 </span><br><span class="line">Recv msg:</span><br><span class="line">0x02 0x00 0x00 0x00 //ex header</span><br><span class="line">0x05 0x00 0x01 0x00 0x06 0x00 0x00 0x00  //PROTOCOL</span><br><span class="line">0x0d 0x00 0x02 0x00 0x74 0x65 0x73 0x74 0x5f 0x6e 0x65 0x74 0x00 0x00 0x00 0x00 //SETNAME</span><br><span class="line">0x0d 0x00 0x03 0x00 0x68 0x61 0x73 0x68 0x3a 0x6e 0x65 0x74 0x00 0x00 0x00 0x00 //TYPENAME</span><br><span class="line">0x05 0x00 0x05 0x00 0x02 0x00 0x00 0x00 //FAMILY</span><br><span class="line">0x05 0x00 0x04 0x00 0x01 0x00 0x00 0x00 //REVISION</span><br><span class="line">0x24 0x00 0x07 0x80 //DATA</span><br><span class="line">0x08 0x00 0x12 0x40 0x00 0x00 0x04 0x00 </span><br><span class="line">0x08 0x00 0x13 0x40 0x00 0x01 0x00 0x00 </span><br><span class="line">0x08 0x00 0x19 0x40 0x00 0x00 0x00 0x00 </span><br><span class="line">0x08 0x00 0x1a 0x40 0x00 0x00 0x41 0xb0 </span><br><span class="line">0x1c 0x00 0x08 0x80 //ADT</span><br><span class="line">0x18 0x00 0x07 0x80 //DATA</span><br><span class="line">0x0c 0x00 0x01 0x80 //IP</span><br><span class="line">0x08 0x00 0x01 0x00 0x01 0x01 0x02 0x00 //1.1.2.0</span><br><span class="line">0x05 0x00 0x03 0x00 0x1f 0x00 0x00 0x00 //CIDR</span><br></pre></td></tr></table></figure><p>其中单个属性的组成模式类似tlv结构(<a href="/2019/08/27/TLV数据传输协议及简单实现-C/" title="TLV数据传输协议及简单实现(C)">TLV数据传输协议及简单实现(C)</a>)，不过这里是ltv结构。比如<code>0x05 0x00 0x01 0x00 0x06 0x00 0x00 0x00</code>中<code>0x05 0x00</code>是指长度为5，<code>0x01 0x00</code>是标志PROTOCOL(源码里有映射表)，后面的就是值了，这里的实际传输长度为8，是因为进行了对齐操作。</p><p>如果你需要进行其他ipset通信的分析，执行上面提到的ipset的debug版本对应命令，进行解析即可。</p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPSET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C语言缺陷与陷阱》读书笔记</title>
      <link href="/2020/05/15/%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%BC%BA%E9%99%B7%E4%B8%8E%E9%99%B7%E9%98%B1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/15/%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%BC%BA%E9%99%B7%E4%B8%8E%E9%99%B7%E9%98%B1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>虽然这本书已经有些古老了，但是还好，C语言相对来说也挺古老，并且近些年的变化还不算大。虽然其中描述的有些问题，现在已经不存在，或者说编译器已经将其禁止，但是依旧有很多可以学到的技巧。(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em>以下内容都是根据书中的章节目录，并且根据自己的缺陷进行记录的。</em><br><em>如果有兴趣，推荐先阅读原著，再看笔记。</em></p><a id="more"></a><h3 id="前言"><a class="header-anchor" href="#前言"></a>前言</h3><p>心智模式(mental model)：被解释为‘’人们深植心中，对于周遭世界如何运作的看法和行为‘’。《心灵的新科学》中认为，人们的心智模式决定了人们如何认识周遭世界。《列子》一书中有个典型故事，说有个人遗失了一把斧头，他怀疑是邻居孩子偷的，暗中观察他的行为，怎么看怎么像偷斧子的人；后来他在自己家中找到了遗失的斧头，再碰到邻居的孩子时，怎么看也不像会是偷他斧头的人了。</p><p>你是否愿意购买一个返修率很高的厂家所生产的汽车？如果厂家声明他已经做出了改进，你的态度是否会改变？用户为你找出程序中的Bug，你真正损失的是什么？</p><h3 id="第一章"><a class="header-anchor" href="#第一章"></a>第一章</h3><p><strong>词法分析</strong><br>词法分析中的“贪心法”：尽可能长的读取字符将其作为一个符号。</p><h3 id="第二章"><a class="header-anchor" href="#第二章"></a>第二章</h3><p><strong>理解函数声明</strong><br><code>int *a </code>中a表示为一个int指针，相应的<br><code>(int *)</code> 表示“int指针”的强制类型转换。<br>同理：<br>float (*h)() 表示h是一个指向返回值为浮点数的函数指针，那么，<br>(float (*)()) 表示“指向返回值为浮点数的函数指针”的强制类型转换。<br>那么：<br><code>( * (void (*) () )0 ) ();</code>含义是什么？<br>首先，<code>(void (*) () )</code>表示 “返回值为void型的函数指针”的强制转换。而强制转换的对象是0，意味着0这个地址被强制转换为了一个函数指针，而最开始的*表示指向函数指针所代表的地址，也就是0地址，综合起来：<br>调用地址为0处的函数。<br>普通调用方式：<br><code>fun();</code><br>实际上为<code>(*fun)();</code>的简写，fun实质还是一个函数指针。</p><p>上述定义，我们也可以使用<code>typedef</code>来得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*funcptr)</span> <span class="params">()</span></span>; </span><br><span class="line">(* (funcptr)<span class="number">0</span>) ();</span><br></pre></td></tr></table></figure><p>这里可以说明一下：<code>typedef</code>的实际功能就是为一个类型声明一个别名。在第一行代码中，我们可以理解为<code>funcptr=void(*)()</code>。那么，在第二行代码中，<code>funcptr</code>是个强制转换，只有类型，没有实际声明变量。将<code>funcptr</code>进行替换，就能得到实际的类型声明：<br><code>(* (void(*)())0) ();</code><br>书中还提到了第二种关于signal的声明 <code>void(*signal(int, void(*)(int)))();</code>等效于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*HANDLER)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">HANDLER <span class="title">signal</span><span class="params">(<span class="keyword">int</span>, HANDLER)</span></span>;</span><br></pre></td></tr></table></figure><p>这儿<code>signal(int, HANDLER)</code>是一个<code>HANDLER</code>变量，先将其带入到<code>typedef</code>中：<code>void (*signal(int, HANDLER))(int);</code>，再将signal内部HANDLER变量声明<code>HANDLER=void(*)(int)</code>进行替换：<code>void (*signal(int, void(*)(int)))(int);</code></p><h3 id="第三章"><a class="header-anchor" href="#第三章"></a>第三章</h3><p><strong>指针与数组</strong><br><code>int (*ap)[31]</code>含义是：声明了<code>*ap</code>是一个拥有31个整数元素的数组，因此ap就是指向这样一个数组的指针。注意，这里只是声明了一个指针ap，后面的<code>[31]</code>是在表示这个指针的类型。更加通俗：假如声明<code>int A[31]</code>,那么<code>A=(*ap)</code>,即<code>ap=&amp;A</code>.所有操作将<code>A</code>和<code>(*ap)</code>进行等效替换就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *hello;</span><br><span class="line"><span class="keyword">char</span> hello[];</span><br></pre></td></tr></table></figure><p>这两种声明第一种是一个指向char类型的指针，第二种是代表指向一个char数组的指针。明显第一种范围更广。如果使用中都是代表一个char数组指针的时候，二者是等效的，在参数传递中混用编译器也不会报错。主要是看哪种更能表现出自己的意图。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])&#123;</span><br><span class="line">&#125;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种写法都等效，唯一不同就在第一种更加强调<code>argv</code>是某一字符串的起始地址。而通常我们也是更关心某个传入参数，而不是某个参数中的某个字符。</p><h3 id="第五章"><a class="header-anchor" href="#第五章"></a>第五章</h3><p><strong>使用errno检测错误</strong><br>用处是检测最后一次系统错误。当调用某个与系统相关的函数，返回的是错误值时，可以调用此函数。(猜测：库函数中应该都会有错误码)<br><strong>库函数signal</strong><br>函数声明形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line">signal(signal type, handle function);</span><br></pre></td></tr></table></figure><p>这个函数时非常有用的，特别是针对出现段错误的情况。当出现段错误时，会发出<code>SIGSEGV</code>信号给程序，而程序中一开始调用了<code>signal</code>后，它将会接收对应信号量并使用相应的<code>function</code>来处理。我们在处理函数中使用<code>backtrace</code>及相关的函数即可将发生段错误时的函数堆栈信息打印出来，即可追溯到对应的错误函数。<br>下面是<a href="https://blog.csdn.net/astrotycoon/article/details/8142588" target="_blank" rel="noopener">参考其他人</a>后进行了相应修改的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* <span class="built_in">array</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">size_t</span> arr_size, i;</span><br><span class="line">    <span class="keyword">char</span> **strings = <span class="literal">NULL</span>;</span><br><span class="line">    signal(SIGSEGV, SIG_IGN);</span><br><span class="line">    <span class="comment">//signal(other signal type, SIG_IGN);</span></span><br><span class="line">    </span><br><span class="line">    arr_size = backtrace (<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]));</span><br><span class="line">    strings = backtrace_symbols (<span class="built_in">array</span>, arr_size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Signal:[%s], PID:(%d), Stack trace:\n"</span>, strsignal(sig), getpid());  </span><br><span class="line">    <span class="keyword">if</span> (strings) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr_size; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">"%ld: %s\n"</span>, i + <span class="number">1</span>, strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span> (strings);</span><br><span class="line">    &#125;</span><br><span class="line">    raise(sig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *segement = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,segement);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func_c();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func_b();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGSEGV, dump) == SIG_ERR)</span><br><span class="line">        perror(<span class="string">"can't catch SIGSEGV"</span>);</span><br><span class="line">    func_a();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译命令：<br><code>gcc -g -rdynamic signal.c -o a.out</code><br>这里需要注意，添加-O2进行优化后，可能导致backtrace_symbols输出不了函数名。其最终结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Signal:[Segmentation fault], PID:(<span class="number">4248</span>), Stack trace:</span><br><span class="line"><span class="number">1</span>: ./a.out(dump+<span class="number">0x3d</span>) [<span class="number">0x400afa</span>]</span><br><span class="line"><span class="number">2</span>: /lib64/libc.so<span class="number">.6</span>(+<span class="number">0x35270</span>) [<span class="number">0x7f20db113270</span>]</span><br><span class="line"><span class="number">3</span>: /lib64/libc.so<span class="number">.6</span>(+<span class="number">0x86c31</span>) [<span class="number">0x7f20db164c31</span>]</span><br><span class="line"><span class="number">4</span>: /lib64/libc.so<span class="number">.6</span>(_IO_puts+<span class="number">0xc</span>) [<span class="number">0x7f20db14af2c</span>]</span><br><span class="line"><span class="number">5</span>: ./a.out(func_c+<span class="number">0x1c</span>) [<span class="number">0x400bd5</span>]</span><br><span class="line"><span class="number">6</span>: ./a.out(func_b+<span class="number">0xe</span>) [<span class="number">0x400be5</span>]</span><br><span class="line"><span class="number">7</span>: ./a.out(func_a+<span class="number">0xe</span>) [<span class="number">0x400bf5</span>]</span><br><span class="line"><span class="number">8</span>: ./a.out(main+<span class="number">0x38</span>) [<span class="number">0x400c2f</span>]</span><br><span class="line"><span class="number">9</span>: /lib64/libc.so<span class="number">.6</span>(__libc_start_main+<span class="number">0xf5</span>) [<span class="number">0x7f20db0ffc05</span>]</span><br><span class="line"><span class="number">10</span>: ./a.out() [<span class="number">0x4009f9</span>]</span><br><span class="line"><span class="function">Segmentation <span class="title">fault</span> <span class="params">(core dumped)</span></span></span><br></pre></td></tr></table></figure><p>这里可以非常明显的看到，是执行a.out时其中func_c函数出错，而其错误是由于IO输出导致的。简直不要太明显。<br>如果添加了优化选项，代码结构会改变，不方便定位。<br>添加-O2选项后的输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Signal:[Segmentation fault], PID:(<span class="number">4367</span>), Stack trace:</span><br><span class="line"><span class="number">1</span>: ./a.out(dump+<span class="number">0x2c</span>) [<span class="number">0x400b1c</span>]</span><br><span class="line"><span class="number">2</span>: /lib64/libc.so<span class="number">.6</span>(+<span class="number">0x35270</span>) [<span class="number">0x7fd5b3951270</span>]</span><br><span class="line"><span class="number">3</span>: /lib64/libc.so<span class="number">.6</span>(+<span class="number">0x86c31</span>) [<span class="number">0x7fd5b39a2c31</span>]</span><br><span class="line"><span class="number">4</span>: /lib64/libc.so<span class="number">.6</span>(_IO_puts+<span class="number">0xc</span>) [<span class="number">0x7fd5b3988f2c</span>]</span><br><span class="line"><span class="number">5</span>: ./a.out(main+<span class="number">0x20</span>) [<span class="number">0x4009f0</span>]</span><br><span class="line"><span class="number">6</span>: /lib64/libc.so<span class="number">.6</span>(__libc_start_main+<span class="number">0xf5</span>) [<span class="number">0x7fd5b393dc05</span>]</span><br><span class="line"><span class="number">7</span>: ./a.out() [<span class="number">0x400a2c</span>]</span><br><span class="line"><span class="function">Segmentation <span class="title">fault</span> <span class="params">(core dumped)</span></span></span><br></pre></td></tr></table></figure><p>我们可以把可执行文件编程汇编代码，看看发生了啥<br><code>objdump -d a.out &gt; a.s</code><br>a.s中对应的出错位置就是在[0x4009f0]地址处，而这个地址也实实在在的在main函数中：<br><img src="/2020/05/15/《C语言缺陷与陷阱》读书笔记/%E4%BC%98%E5%8C%96%E5%90%8E%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81.png" alt="优化后汇编代码"><br>优化过程中删减了中间两层的函数调用。厉害。也正是因为这样，导致在函数跟踪的时候，只能到看到main函数。<br>而没有优化过的代码，就和原始结构一样：<br><img src="/2020/05/15/《C语言缺陷与陷阱》读书笔记/%E5%8E%9F%E5%A7%8B%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81.png" alt="原始汇编代码"></p><h3 id="第六章"><a class="header-anchor" href="#第六章"></a>第六章</h3><p>简单一句话概括，define功能就是做宏替换，它啥功能也没有，就是简简单单的字符替换。</p><h3 id="第七章"><a class="header-anchor" href="#第七章"></a>第七章</h3><p>主要讲的是移植性问题，虽然C最初开发的目的就是为了可移植性。但是后续不断的发展，导致C上层库出现了偏差，最显而易见的就是windows和linux的C代码兼容性很差，特别是系统调用级别的，基本是两套api了。<br>其中还讲到了关于内存重复利用问题，也就是realloc函数。主要用途还是用于原有的空间不够，进行扩展。这样是比你free掉之前的空间，然后重新malloc要快。并且realloc时，是可以拷贝数据到新的地方的。当然，realloc的空间小于之前的空间，那么会产生截断。总之，realloc时需要有很多注意事项，如果不是对空间利用率有较高的要求，可以不用使用。</p><h3 id="第八章"><a class="header-anchor" href="#第八章"></a>第八章</h3><p>建议，尽量在写代码的时候，多想，特别是结构。代码写完后多检查，测试。<br>尽量覆盖异常问题，但避免过多的防御式编程。</p><h3 id="总结"><a class="header-anchor" href="#总结"></a>总结</h3><p>这本书还是相当的老了，很多书中的问题，在现在来看已经不是问题。但是还是有些地方的提出的注意事项，值得参考和学习。加上全书不长，可以快速一看，然后发现自己缺失的点即可。<br>2020.5.7</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libipset源码分析</title>
      <link href="/2020/05/06/libipset%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/05/06/libipset%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>由于语言需求，需要使用go实现libipset的功能，与内核通信，就简单的看了一下源码(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em><a href="http://ipset.netfilter.org/" target="_blank" rel="noopener">ipset官网</a></em><br><em><a href="http://ipset.netfilter.org/libipset.man.html" target="_blank" rel="noopener">libipset手册</a></em><br><em><a href="https://netfilter.org/projects/libmnl/" target="_blank" rel="noopener">libmnl</a></em></p><p><em>本文主要根据ipset 7.x版本来进行介绍的。</em></p><a id="more"></a><h3 id="简单介绍"><a class="header-anchor" href="#简单介绍"></a>简单介绍</h3><h4 id="简介"><a class="header-anchor" href="#简介"></a>简介</h4><p>ipset是 Linux 防火墙 iptables 的一个协助工具。 通过这个工具可以轻松愉快地屏蔽一组IP地址。–<a href="https://wiki.archlinux.org/index.php/Ipset_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">来自wiki</a><br>ipset主要解决的是iptables在屏蔽大量ip产生的效率低下问题。搞一张图看看效率差距：<br><img src="/2020/05/06/libipset源码分析/iptables-nfhipac-ipset.jpg" alt="iptables和ipset性能对比"><br>–<a href="http://people.netfilter.org/kadlec/nftest.pdf" target="_blank" rel="noopener">测评来源</a><br>并且，iptables在进行规则插入和删除的时候，也只能一条条的进行，速度也是非常慢的。我自己在自己的设备上测试效果如下(time + 脚本测试的)：</p><table><thead><tr><th>添加Iptables数量</th><th>1</th><th>500</th><th>1000</th><th>2000</th><th>4000</th><th>10000</th></tr></thead><tbody><tr><td>花费时间</td><td>0.002s</td><td>2.831s</td><td>4.115s</td><td>10.725s</td><td>33.365s</td><td>2m55.954s</td></tr></tbody></table><p><strong>那么</strong>，如果你有需求使用iptables屏蔽大量的ip，就可以考虑使用ipset。</p><h4 id="使用"><a class="header-anchor" href="#使用"></a>使用</h4><p>看源码之前，首先需要了解ipset有什么用，简单给个示例来屏蔽一个ip：<br>你要有两台机器，可以是自己的虚拟机，在一台机器上配置ipset + iptables，另外一台机器去ping测试。<br>安装(centos)：<code>yum install ipset</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipset create hash_test hash:ip #创建一个集合</span><br><span class="line">ipset add hash_test 192.168.1.120 #添加一个成员到集合</span><br><span class="line">iptables -I INPUT -m set --match-set hash_test src -j DROP  #iptables配置匹配项</span><br></pre></td></tr></table></figure><p>你也可以进行更多的尝试，参见<a href="http://ipset.netfilter.org/" target="_blank" rel="noopener">官网</a><br>ipset的使用不是本文主要目的，简单给个示例就行了。</p><h3 id="基本流程"><a class="header-anchor" href="#基本流程"></a>基本流程</h3><p>libipset属于用户态部分的代码，负责与内核通信，真正的ipset工作的地方是在内核的netfilter中。<br>我们就根据上面<code>ipset create hash_test hash:ip</code>命令来分析大概的流程。<br><img src="/2020/05/06/libipset源码分析/ipset_source_flow.png" alt="libipset流程图"><br>特殊说明在流程图里都有备注，顺便说明一下几个固定列表的位置：</p><ul><li>各种类型的类型列表，包含所支持的命令，以及需要的参数：ipset_&lt;type_name&gt;.c<br><img src="/2020/05/06/libipset源码分析/haship.jpg" alt="haship"></li><li>错误码：errcode.c<br><img src="/2020/05/06/libipset源码分析/errcode.jpg" alt="errcode"></li><li>输入命令参数列表(主要是-s这种类型的参数)：ipset.c<br><img src="/2020/05/06/libipset源码分析/ipset.jpg" alt="ipset"></li><li>输入命令参数列表(主要是add这种类型的参数)：args.c<br><img src="/2020/05/06/libipset源码分析/args.jpg" alt="args"></li><li>某个命令的消息协议：PROTOCOL<br><img src="/2020/05/06/libipset源码分析/protocol.jpg" alt="protocol"></li></ul><h3 id="消息格式"><a class="header-anchor" href="#消息格式"></a>消息格式</h3><p>ipset使用的消息是Netlink通信，在ipset用户态构造的sock参数：AF_NETLINK，SOCK_RAW，NETLINK_NETFILTER，sock具体用法自己去查。ipset用户态构造的sock需要进行bind才能使用，因为它不能像udp这种自动分配发送端的端口。<br>首先来看看netlink的消息格式(<a href="https://www.cnblogs.com/wenqiang/p/6306727.html" target="_blank" rel="noopener">主要参考</a>)：<br><code>struct sockaddr_nl</code>结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> &#123;</span></span><br><span class="line">     <span class="keyword">__kernel_sa_family_t</span>    nl_family;  <span class="comment">/* AF_NETLINK （跟AF_INET对应）*/</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">short</span>  nl_pad;     <span class="comment">/* zero */</span></span><br><span class="line">     __u32       nl_pid;     <span class="comment">/* port ID  （通信端口号）*/</span></span><br><span class="line">     __u32       nl_groups;  <span class="comment">/* multicast groups mask */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>struct nlmsghd</code> 结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* struct nlmsghd 是netlink消息头*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> &#123;</span>   </span><br><span class="line">    __u32       nlmsg_len;  <span class="comment">/* Length of message including header */</span></span><br><span class="line">    __u16       nlmsg_type; <span class="comment">/* Message content */</span></span><br><span class="line">    __u16       nlmsg_flags;    <span class="comment">/* Additional flags */</span> </span><br><span class="line">    __u32       nlmsg_seq;  <span class="comment">/* Sequence number */</span></span><br><span class="line">    __u32       nlmsg_pid;  <span class="comment">/* Sending process port ID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通常这个头消息的构造，在ipset中是下面的代码(其中seq是一个自增检验数，pid通常设置0)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">ipset_mnl_fill_hdr(struct ipset_handle *handle, <span class="keyword">enum</span> ipset_cmd cmd,</span><br><span class="line">   <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> len UNUSED, <span class="keyword">uint8_t</span> envflags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfg</span>;</span></span><br><span class="line"></span><br><span class="line">assert(handle);</span><br><span class="line">assert(buffer);</span><br><span class="line">assert(cmd &gt; IPSET_CMD_NONE &amp;&amp; cmd &lt; IPSET_MSG_MAX);</span><br><span class="line"></span><br><span class="line">nlh = mnl_nlmsg_put_header(buffer);</span><br><span class="line">nlh-&gt;nlmsg_type = cmd | (NFNL_SUBSYS_IPSET &lt;&lt; <span class="number">8</span>);</span><br><span class="line">nlh-&gt;nlmsg_flags = cmdflags[cmd - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (envflags &amp; IPSET_ENV_EXIST)</span><br><span class="line">nlh-&gt;nlmsg_flags &amp;=  ~NLM_F_EXCL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这儿是扩展头，通常是固定的\x02\x00\x00\x00</span></span><br><span class="line">nfg = mnl_nlmsg_put_extra_header(nlh, <span class="keyword">sizeof</span>(struct nfgenmsg));</span><br><span class="line">nfg-&gt;nfgen_family = AF_INET;</span><br><span class="line">nfg-&gt;version = NFNETLINK_V0;</span><br><span class="line">nfg-&gt;res_id = htons(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>struct msghdr</code> 结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span>                    <span class="comment">/* Scatter/gather array items */</span></span><br><span class="line">     <span class="keyword">void</span>  *iov_base;              <span class="comment">/* Starting address */</span></span><br><span class="line">     <span class="keyword">size_t</span> iov_len;               <span class="comment">/* Number of bytes to transfer */</span></span><br><span class="line"> &#125;;</span><br><span class="line">  <span class="comment">/* iov_base: iov_base指向数据包缓冲区，即参数buff，iov_len是buff的长度。msghdr中允许一次传递多个buff，</span></span><br><span class="line"><span class="comment">    以数组的形式组织在 msg_iov中，msg_iovlen就记录数组的长度 （即有多少个buff）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">     <span class="keyword">void</span>         *msg_name;       <span class="comment">/* optional address */</span></span><br><span class="line">     <span class="keyword">socklen_t</span>     msg_namelen;    <span class="comment">/* size of address */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>        <span class="comment">/* scatter/gather array */</span></span><br><span class="line">     <span class="keyword">size_t</span>        msg_iovlen;     <span class="comment">/* # elements in msg_iov */</span></span><br><span class="line">     <span class="keyword">void</span>         *msg_control;    <span class="comment">/* ancillary data, see below */</span></span><br><span class="line">     <span class="keyword">size_t</span>        msg_controllen; <span class="comment">/* ancillary data buffer len */</span></span><br><span class="line">     <span class="keyword">int</span>           msg_flags;      <span class="comment">/* flags on received message */</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">/* msg_name： 数据的目的地址，网络包指向sockaddr_in, netlink则指向sockaddr_nl;</span></span><br><span class="line"><span class="comment">    msg_namelen: msg_name 所代表的地址长度</span></span><br><span class="line"><span class="comment">    msg_iov: 指向的是缓冲区数组</span></span><br><span class="line"><span class="comment">    msg_iovlen: 缓冲区数组长度</span></span><br><span class="line"><span class="comment">    msg_control: 辅助数据，控制信息(发送任何的控制信息)</span></span><br><span class="line"><span class="comment">    msg_controllen: 辅助信息长度</span></span><br><span class="line"><span class="comment">    msg_flags: 消息标识</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>这个结构体主要在ipset接收消息的时候使用。具体代码包含在libmnl库中，需要<a href="https://netfilter.org/projects/libmnl/downloads.html" target="_blank" rel="noopener">下载源码</a>。然后就可以看到以下的接收消息的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> mnl_socket_recvfrom(<span class="keyword">const</span> struct mnl_socket *nl, <span class="keyword">void</span> *buf,</span><br><span class="line">    <span class="keyword">size_t</span> bufsiz)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span> = &#123;</span></span><br><span class="line">.iov_base= buf,</span><br><span class="line">.iov_len= bufsiz,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span> = &#123;</span></span><br><span class="line">.msg_name= &amp;addr,</span><br><span class="line">.msg_namelen= <span class="keyword">sizeof</span>(struct sockaddr_nl),</span><br><span class="line">.msg_iov= &amp;iov,</span><br><span class="line">.msg_iovlen= <span class="number">1</span>,</span><br><span class="line">.msg_control= <span class="literal">NULL</span>,</span><br><span class="line">.msg_controllen= <span class="number">0</span>,</span><br><span class="line">.msg_flags= <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line">ret = recvmsg(nl-&gt;fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msg.msg_flags &amp; MSG_TRUNC) &#123;</span><br><span class="line">errno = ENOSPC;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (msg.msg_namelen != <span class="keyword">sizeof</span>(struct sockaddr_nl)) &#123;</span><br><span class="line">errno = EINVAL;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的netlink消息数据结构，也就是ipset里使用的主要结构，而这些消息结构的关系如下：<br><img src="/2020/05/06/libipset源码分析/netlink%E6%95%B0%E6%8D%AE%E5%85%B3%E7%B3%BB.png" alt="netlink数据结构之间的关系"><br><em><a href="https://blog.csdn.net/zhao_h/article/details/80943226" target="_blank" rel="noopener">图片来源</a></em><br>上述示例的就是ipset中使用到的主要消息结构了，更多细节，还是在源码中查看。</p><h3 id="示例Demo"><a class="header-anchor" href="#示例Demo"></a>示例Demo</h3><p>这里我们列出两个语言的demo，C和Go的。</p><h4 id="C"><a class="header-anchor" href="#C"></a>C</h4><p>c的相对简单，因为只需要调用libipset提供的接口就行。这里推荐写法和官方的ipset的main函数写法一致。<br><strong>官方main函数</strong>(这个函数只有在ipset 7版本中才有)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;/* assert */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;/* fprintf */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;/* exit */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libipset/ipset.h&gt;/* ipset library */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipset</span> *<span class="title">ipset</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Load set types */</span></span><br><span class="line">ipset_load_types();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize ipset library */</span></span><br><span class="line">ipset = ipset_init();</span><br><span class="line"><span class="keyword">if</span> (ipset == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot initialize ipset, aborting."</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = ipset_parse_argv(ipset, argc, argv);</span><br><span class="line"></span><br><span class="line">ipset_fini(ipset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是简单到爆。<br><strong>第二种</strong>，是使用libipset中的session结构体(<a href="https://github.com/Lekensteyn/dnsallow/blob/master/ipset.c" target="_blank" rel="noopener">参考来源</a>)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libipset/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libipset/session.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libipset/data.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setname X which can be used in "ipset list X". */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETNAME_IPV4 <span class="meta-string">"ipset-ipv4"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETNAME_IPV6 <span class="meta-string">"ipset-ipv6"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipset_state</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipset_session</span> *<span class="title">session</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> family;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ip4_addr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">ip6_addr</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">try_ipset_cmd</span><span class="params">(struct ipset_session *session, <span class="keyword">enum</span> ipset_cmd cmd,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *setname, <span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ipset_session_data_set(session, IPSET_SETNAME, setname);</span><br><span class="line">    <span class="keyword">if</span> (!ipset_type_get(session, cmd)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot find ipset %s: %s\n"</span>, setname,</span><br><span class="line">                ipset_session_error(session));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ipset_session_data_set(session, IPSET_OPT_FAMILY, &amp;family);</span><br><span class="line">    ipset_session_data_set(session, IPSET_OPT_IP, addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ipset_cmd(session, cmd, <span class="comment">/*lineno*/</span> <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to add to set %s: %s\n"</span>, setname,</span><br><span class="line">                ipset_session_error(session));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">try_ipset_create</span><span class="params">(struct ipset_session *session, <span class="keyword">const</span> <span class="keyword">char</span> *setname,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">typename</span>, <span class="keyword">int</span> family)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipset_type</span> *<span class="title">type</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> timeout;</span><br><span class="line"></span><br><span class="line">    ipset_session_data_set(session, IPSET_SETNAME, setname);</span><br><span class="line">    ipset_session_data_set(session, IPSET_OPT_TYPENAME, <span class="keyword">typename</span>);</span><br><span class="line">    type = ipset_type_get(session, IPSET_CMD_CREATE);</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot find ipset type %s: %s\n"</span>, <span class="keyword">typename</span>,</span><br><span class="line">                ipset_session_error(session));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timeout = <span class="number">0</span>; <span class="comment">/* timeout support, but default to infinity */</span></span><br><span class="line">    ipset_session_data_set(session, IPSET_OPT_TIMEOUT, &amp;timeout);</span><br><span class="line">    ipset_session_data_set(session, IPSET_OPT_TYPE, type);</span><br><span class="line">    ipset_session_data_set(session, IPSET_OPT_FAMILY, &amp;family);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ipset_cmd(session, IPSET_CMD_CREATE, <span class="comment">/*lineno*/</span> <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to create ipset %s: %s\n"</span>, setname,</span><br><span class="line">                ipset_session_error(session));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ipset_state *<span class="title">ipset_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipset_state</span> *<span class="title">state</span>;</span></span><br><span class="line"></span><br><span class="line">    state = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*state));</span><br><span class="line">    <span class="keyword">if</span> (!state)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ipset_load_types();</span><br><span class="line"></span><br><span class="line">    state-&gt;session = ipset_session_init(<span class="built_in">printf</span>);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;session) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot initialize ipset session.\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return success on attempts to create a compatible ipset or attempts to</span></span><br><span class="line"><span class="comment"> *      * add an existing rule. */</span></span><br><span class="line">    ipset_envopt_parse(state-&gt;session, IPSET_ENV_EXIST, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!try_ipset_create(state-&gt;session, SETNAME_IPV4, <span class="string">"hash:ip"</span>, NFPROTO_IPV4))</span><br><span class="line">        <span class="keyword">goto</span> err_set;</span><br><span class="line">    <span class="keyword">if</span> (!try_ipset_create(state-&gt;session, SETNAME_IPV6, <span class="string">"hash:ip"</span>, NFPROTO_IPV6))</span><br><span class="line">        <span class="keyword">goto</span> err_set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line"></span><br><span class="line">err_set:</span><br><span class="line">err_session:</span><br><span class="line">    ipset_session_fini(state-&gt;session);</span><br><span class="line">    <span class="built_in">free</span>(state);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ipset_add_ip</span><span class="params">(struct ipset_state *state, struct address *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipset_session</span> *<span class="title">session</span> = <span class="title">state</span>-&gt;<span class="title">session</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr-&gt;family) &#123;</span><br><span class="line">    <span class="keyword">case</span> AF_INET:</span><br><span class="line">        try_ipset_cmd(session, IPSET_CMD_ADD, SETNAME_IPV4, NFPROTO_IPV4, &amp;addr-&gt;ip4_addr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AF_INET6:</span><br><span class="line">        try_ipset_cmd(session, IPSET_CMD_ADD, SETNAME_IPV6, NFPROTO_IPV6, &amp;addr-&gt;ip6_addr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Unrecognized address family 0x%04x\n"</span>, addr-&gt;family);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ipset_session_report_reset(session);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ipset_fini</span><span class="params">(struct ipset_state *state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ipset_session_fini(state-&gt;session);</span><br><span class="line">    <span class="built_in">free</span>(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//for test</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.family = AF_INET;</span><br><span class="line">    inet_aton(<span class="string">"192.168.1.10"</span>, &amp;addr.ip4_addr);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipset_state</span> *<span class="title">state</span> = <span class="title">ipset_init</span>();</span></span><br><span class="line">    ipset_add_ip(state, &amp;addr);</span><br><span class="line">    ipset_fini(state);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译</strong>(根据各自的环境调整)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -O2 -Wall -Werror -c ipset_test.c -o ipset_test.o</span><br><span class="line">gcc -g -O2 -Wall -Werror ./ipset_test.o -o a.out -L/usr/lib64/ -lipset</span><br></pre></td></tr></table></figure><h4 id="GO"><a class="header-anchor" href="#GO"></a>GO</h4><p>go有三种方式来调用ipset，第一种是用执行命令的方式，第二种是使用cgo的方式，第三种是使用netlink通信的方式。这里简单给下第二种和第三种的demo：<br><strong>cgo：</strong><br>ipset.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// #cgo LDFLAGS: -L$&#123;SRCDIR&#125;/ -Wl,-rpath,$&#123;SRCDIR&#125;/ -lcipset -L/usr/lib64/  -lipset</span></span><br><span class="line"><span class="comment">// #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">// #include "cipset.h"</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"C"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">import</span> <span class="string">"unsafe"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cip := C.CString(<span class="string">"10.92.2.100"</span>)</span><br><span class="line"><span class="keyword">defer</span> C.free(unsafe.Pointer(cip))</span><br><span class="line"><span class="keyword">var</span> caddr C.struct_address</span><br><span class="line">C.ip2addr(cip, &amp;caddr)</span><br><span class="line"><span class="comment">//caddr.family = C.AF_INET</span></span><br><span class="line"><span class="comment">//C.inet_aton(cip, caddr.ip4_addr)</span></span><br><span class="line"><span class="keyword">var</span> cstate *C.struct_ipset_state = C.ipset_init()</span><br><span class="line">C.ipset_add_ip(cstate, &amp;caddr)</span><br><span class="line">C.ipset_fini(cstate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cipset.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __cipset</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __cipset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Setname X which can be used in "ipset list X". */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETNAME_IPV4 <span class="meta-string">"ipset-ipv4"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETNAME_IPV6 <span class="meta-string">"ipset-ipv6"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipset_state</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ipset_state *<span class="title">ipset_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ipset_add_ip</span><span class="params">(struct ipset_state *state, struct address *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ipset_fini</span><span class="params">(struct ipset_state *state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ip2addr</span><span class="params">(<span class="keyword">char</span> *ip, struct address *addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>cipset.c 和上面的C第二种示例代码一致，这里就不占空间了。</p><p><strong>编译执行：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -O2 -Wall -Werror -rdynamic -fPIC -shared -o ./libcipset.so ./cipset.c  #动态库生成</span><br><span class="line">go run ipset.go  #执行go程序</span><br></pre></td></tr></table></figure><p><strong>goipset实现：</strong><br>我已经初步用golang实现了ipset，详情可我的开源：<a href="https://github.com/JiHanHuang/goipset" target="_blank" rel="noopener">https://github.com/JiHanHuang/goipset</a></p><p>以上，如果有什么问题，欢迎随时交流。-(￢∀￢)σ</p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> IPSET </tag>
            
            <tag> NETLINK </tag>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>•ᴗ•颜文字•ᴗ•</title>
      <link href="/2020/04/30/%E2%80%A2%E1%B4%97%E2%80%A2%E9%A2%9C%E6%96%87%E5%AD%97%E2%80%A2%E1%B4%97%E2%80%A2/"/>
      <url>/2020/04/30/%E2%80%A2%E1%B4%97%E2%80%A2%E9%A2%9C%E6%96%87%E5%AD%97%E2%80%A2%E1%B4%97%E2%80%A2/</url>
      
        <content type="html"><![CDATA[<p>啦啦啦啦(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><a id="more"></a><p>（ '▿ ’ ）</p><p>(•̀⌄•́)</p><p>｡◕‿◕｡</p><p>ヾ(❀╹◡╹)ﾉ~</p><p>（<em>＾ワ＾</em>）</p><p>ヾ(●´∇｀●)ﾉ哇～</p><p>ʘᴗʘ</p><p>•ᴗ•</p><p>´◡`</p><p>´･ᴗ･`</p><p>∩_∩</p><p>﹋o﹋</p><p>(｡◝ᴗ◜｡)</p><p>(๑`･ᴗ･´๑)</p><p><sup>o</sup></p><p><sub>(≧▽≦)/</sub></p><p>-(￢∀￢)σ</p><p>(ꈍᴗꈍ)</p><hr><p>(ー_ー)!!</p><p>┐(´-｀)┌</p><p>→_→</p><p>-_-||</p><p>▼_▼</p><p>╭(╯ε╰)╮</p><hr><p>┑(￣Д ￣)┍</p><p>〣( ºΔº )〣</p><p>(⊙o⊙)</p><p>(╯‵□′)╯︵┻━┻</p><p>ヽ(‘⌒´メ)ノ</p><p>╰_╯╬</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TLV数据传输协议及简单实现(C)</title>
      <link href="/2019/08/27/TLV%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-C/"/>
      <url>/2019/08/27/TLV%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-C/</url>
      
        <content type="html"><![CDATA[<p>有关TLV协议的相关内容，以及基于C语言的简单实现。都是个人理解，有许多不足，仅供参考(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><a id="more"></a><h2 id="概要介绍"><a class="header-anchor" href="#概要介绍"></a>概要介绍</h2><p>首先，关于TLV协议本质，网上有许多讲解，可以先搜索<a href="http://www.wtango.com/tlv%E7%BC%96%E7%A0%81%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener">TLV相关讲解</a>，我自己的实现思路参考<a href="https://www.cnblogs.com/tml839720759/archive/2014/07/13/3841820.html" target="_blank" rel="noopener">这篇帖子</a>。<br>这里通俗概括：<br>T：Type，表示字段标签和编码格式。<br>L：Length，表示数据长度。<br>V：Value，表示实际传输内容。<br><img src="/2019/08/27/TLV数据传输协议及简单实现-C/TLV.png" alt="TLV"><br><a href="http://www.wtango.com/tlv%E7%BC%96%E7%A0%81%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener">图片来源</a>：<a href="http://www.wtango.com/" target="_blank" rel="noopener">http://www.wtango.com/</a></p><h2 id="TLV的优势"><a class="header-anchor" href="#TLV的优势"></a>TLV的优势</h2><p>而使用TLV的作用是什么呢？概括为将格式数据序列化处理（可能表述不太专业），并且能够有一个约定的通信方式进行通信。意思是，方便你在网络中传输结构体。例如：<br>你想传输结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Message&#123;    </span><br><span class="line">    unsigned int id; </span><br><span class="line">    long num;</span><br><span class="line">    char name[128];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你会开辟一片buf来存放这个结构体，然后传输过去，如果其中有指针，还需要数据整理。<br>这个思路意味着你传输数据针对的是你结构体中的每一个数据。而如果你要增加一个字段，则需要关注你传输代码的正确与否。例如你增加一个<code>char new[1024]</code>那么，你开辟的buf，返回的数据对应，都需要检查。正如你买菜的时候需要关注每一样菜放的位置对不对。并且，不同设备和语言之间传输数据时，这种传输方式就显得非常难受，甚至不可用。<br>使用TLV的好处，在于将你的传输数据进行打包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T：0x01</span><br><span class="line">L：136</span><br><span class="line">V：</span><br><span class="line">struct Message&#123;    </span><br><span class="line">    unsigned int id; </span><br><span class="line">    long num;</span><br><span class="line">    char name[128];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样你在以TLV格式编写传输代码的时候，就不会关注实际传输内容是什么。仅仅将内容当成一个装满蔬菜的篮子，而非每个蔬菜。这样，你如何更改菜篮子里的蔬菜，对于整个传输过程来说，都不受影响。并且只要支持标准的TLV传输协议的，不论什么底层平台和语言，都能够相互传输。说白了，就是一个网络传输的通用性封装。┐(´-｀)┌</p><h2 id="简单示例代码"><a class="header-anchor" href="#简单示例代码"></a>简单示例代码</h2><p>代码参考两篇文章：<a href="https://www.cnblogs.com/tml839720759/archive/2014/07/13/3841820.html" target="_blank" rel="noopener">TLV简介</a><br><a href="https://blog.csdn.net/lovekun1989/article/details/41042273" target="_blank" rel="noopener">C语言socket编程</a> 其中关于实际数据的大小端转换没有做，在同平台计算机没有影响。并且我这儿只是非常简单的示例，没有按照标准的TLV进行TAG解析以及Length处理。有兴趣的可以按照这个<a href="https://www.cnblogs.com/tml839720759/archive/2014/07/13/3841820.html" target="_blank" rel="noopener">更加标准的示例</a>来看。</p><p>TLV.c:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Created By Jihan on 2019/8/26.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &quot;TLV.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int send_tlv(int sk, unsigned char *buf, int buf_len, int status)&#123;</span><br><span class="line">    TLV_ENTITY *send_tlv=NULL;</span><br><span class="line">    int tag = sk;</span><br><span class="line"></span><br><span class="line">    if (buf == NULL)&#123;</span><br><span class="line">        printf(&quot;buffer is null!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    send_tlv = (TLV_ENTITY *)malloc(buf_len+TLV_TAG_LEN);</span><br><span class="line">    memset(send_tlv,0,buf_len+TLV_TAG_LEN);</span><br><span class="line"></span><br><span class="line">    //把数据整合到TLV结构中</span><br><span class="line">    send_tlv-&gt;length = htonl(buf_len);</span><br><span class="line">    send_tlv-&gt;tag = htonl(tag);</span><br><span class="line">    send_tlv-&gt;value = (unsigned char*)send_tlv +TLV_TAG_LEN;</span><br><span class="line">    memcpy(send_tlv-&gt;value,buf,buf_len);</span><br><span class="line"></span><br><span class="line">    //发送TLV结构</span><br><span class="line">    send(sk, (char *)send_tlv, sizeof(struct Message)+TLV_TAG_LEN,status);</span><br><span class="line"></span><br><span class="line">    if (send_tlv != NULL)&#123;</span><br><span class="line">        free(send_tlv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int recv_tlv(int sk, unsigned char *buf, int buf_len, int status)&#123;</span><br><span class="line">    TLV_ENTITY send_tlv = &#123;0, 0, NULL&#125;;</span><br><span class="line">    int onece = 0, dataNum = 0;</span><br><span class="line">    char tmp_tlv[1024];</span><br><span class="line"></span><br><span class="line">    if (buf == NULL)&#123;</span><br><span class="line">        printf(&quot;buffer is null!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取TLV数据结构头</span><br><span class="line">    onece = recv(sk, tmp_tlv, TLV_TAG_LEN, status);</span><br><span class="line">    memcpy(&amp;send_tlv.tag, tmp_tlv, 4);</span><br><span class="line">    send_tlv.tag = ntohl(send_tlv.tag);</span><br><span class="line">    memcpy(&amp;send_tlv.length, tmp_tlv+4, 4);</span><br><span class="line">    send_tlv.length = ntohl(send_tlv.length);</span><br><span class="line">    send_tlv.value = (unsigned char *) malloc(send_tlv.length);</span><br><span class="line"></span><br><span class="line">    //根据头数据接收后续value数据</span><br><span class="line">    while (dataNum &lt; send_tlv.length)&#123;</span><br><span class="line">        onece = recv(sk, tmp_tlv, 1024, status);</span><br><span class="line">        memcpy(send_tlv.value + dataNum, tmp_tlv, onece);</span><br><span class="line">        dataNum += onece;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(buf_len &lt; send_tlv.length)&#123;</span><br><span class="line">        printf(&quot;buffer overflow!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memcpy(buf, send_tlv.value, send_tlv.length);</span><br><span class="line">    if (send_tlv.value != NULL)&#123;</span><br><span class="line">        free(send_tlv.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dataNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TLV.h：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Created By Jihan on 2019/8/26.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#ifndef __TLV_H__</span><br><span class="line">#define __TLV_H__</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define TLV_TAG_LEN 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Message&#123;</span><br><span class="line">    unsigned int id;</span><br><span class="line">    long num;</span><br><span class="line">    char name[128];</span><br><span class="line">    char hello[24];</span><br><span class="line">    char new[128];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int recv_tlv(int sk, unsigned char *buf, int buf_len, int status);</span><br><span class="line">int send_tlv(int sk, unsigned char *buf, int buf_len, int status);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>test.c:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;TLV.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define SERVER_PORT 9111</span><br><span class="line"></span><br><span class="line">int server()&#123;</span><br><span class="line">    int sk;</span><br><span class="line">    struct sockaddr_in server_addr, clientAddr;</span><br><span class="line">    int addr_len = sizeof(clientAddr);</span><br><span class="line">    int client;</span><br><span class="line">//    char buffer[200];</span><br><span class="line">    int iDataNum = 0;</span><br><span class="line"></span><br><span class="line">    struct Message MSG;</span><br><span class="line">    //char recvbuf[1024];</span><br><span class="line">    //int recvNum;</span><br><span class="line"></span><br><span class="line">    if((sk = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;err socket\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(&amp;server_addr, 0, sizeof(server_addr));</span><br><span class="line">    //初始化服务器端的套接字，并用htons和htonl将端口和地址转成网络字节序</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    //ip可是是本服务器的ip，也可以用宏INADDR_ANY代替，代表0.0.0.0，表明所有地址</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    //对于bind，accept之类的函数，里面套接字参数都是需要强制转换成(struct sockaddr *)</span><br><span class="line">    //bind三个参数：服务器端的套接字的文件描述符，</span><br><span class="line">    if(bind(sk, (struct sockaddr *)&amp;server_addr, sizeof(server_addr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;err connect\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置服务器上的socket为监听状态</span><br><span class="line">    if(listen(sk, 5) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;err listen\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">        printf(&quot;Listening on port: %d\n&quot;, SERVER_PORT);</span><br><span class="line">        //调用accept函数后，会进入阻塞状态</span><br><span class="line">        //accept返回一个套接字的文件描述符，这样服务器端便有两个套接字的文件描述符，</span><br><span class="line">        //serverSocket和client。</span><br><span class="line">        //serverSocket仍然继续在监听状态，client则负责接收和发送数据</span><br><span class="line">        //clientAddr是一个传出参数，accept返回时，传出客户端的地址和端口号</span><br><span class="line">        //addr_len是一个传入-传出参数，传入的是调用者提供的缓冲区的clientAddr的长度，以避免缓冲区溢出。</span><br><span class="line">        //传出的是客户端地址结构体的实际长度。</span><br><span class="line">        //出错返回-1</span><br><span class="line">        client = accept(sk, (struct sockaddr *) &amp;clientAddr, (socklen_t * ) &amp; addr_len);</span><br><span class="line">        if (client &lt; 0) &#123;</span><br><span class="line">            printf(&quot;err accept\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\nrecv client data...\n&quot;);</span><br><span class="line">        //inet_ntoa   ip地址转换函数，将网络字节序IP转换为点分十进制IP</span><br><span class="line">        //表达式：char *inet_ntoa (struct in_addr);</span><br><span class="line">        printf(&quot;IP is %s\n&quot;, inet_ntoa(clientAddr.sin_addr));</span><br><span class="line">        printf(&quot;Port is %d\n&quot;, ntohs(clientAddr.sin_port));</span><br><span class="line"></span><br><span class="line">        iDataNum = recv_tlv(client, (unsigned char*)&amp;MSG, sizeof(MSG), 0);</span><br><span class="line">        if (iDataNum &lt;= 0) &#123;</span><br><span class="line">            printf(&quot;err recv\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;%d  %ld  %s  %s %s\n&quot;,MSG.id, MSG.num, MSG.name, MSG.hello, MSG.new);</span><br><span class="line"></span><br><span class="line">/*        while (1) &#123;</span><br><span class="line">            iDataNum = recv(client, buffer, 1024, 0);</span><br><span class="line">            if (iDataNum &lt;= 0) &#123;</span><br><span class="line">                printf(&quot;err recv\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer[iDataNum] = &apos;\0&apos;;</span><br><span class="line">            printf(&quot;%drecv data is %s\n&quot;, iDataNum, buffer);</span><br><span class="line">            send(client, buffer, iDataNum, 0);</span><br><span class="line">        &#125;*/</span><br><span class="line">        close(client);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sk);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int client()&#123;</span><br><span class="line">    //客户端只需要一个套接字文件描述符，用于和服务器通信</span><br><span class="line">    int clientSocket;</span><br><span class="line">    //描述服务器的socket</span><br><span class="line">    struct sockaddr_in serverAddr;</span><br><span class="line">   // char sendbuf[200];</span><br><span class="line">   // char recvbuf[200];</span><br><span class="line">   // int iDataNum;</span><br><span class="line"></span><br><span class="line">    struct Message MSG = &#123;100, 54321, &quot;huangjiahao&quot;, &quot;world&quot;, &quot;tttttest&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    if((clientSocket = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;err socket\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverAddr.sin_family = AF_INET;</span><br><span class="line">    serverAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    //指定服务器端的ip，本地测试：127.0.0.1</span><br><span class="line">    //inet_addr()函数，将点分十进制IP转换成网络字节序IP</span><br><span class="line">    serverAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">    if(connect(clientSocket, (struct sockaddr *)&amp;serverAddr, sizeof(serverAddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;err connect\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;connect with destination host...\n&quot;);</span><br><span class="line"></span><br><span class="line">    //数据格式转化为tlv，进行发送</span><br><span class="line">    send_tlv(clientSocket,(unsigned char *)&amp;MSG, sizeof(MSG), 0);</span><br><span class="line"></span><br><span class="line">/*    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Input your word:&gt;&quot;);</span><br><span class="line">        scanf(&quot;%s&quot;, sendbuf);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">        send(clientSocket, sendbuf, strlen(sendbuf), 0);</span><br><span class="line">        if(strcmp(sendbuf, &quot;quit&quot;) == 0)</span><br><span class="line">            break;</span><br><span class="line">        iDataNum = recv(clientSocket, recvbuf, 200, 0);</span><br><span class="line">        recvbuf[iDataNum] = &apos;\0&apos;;</span><br><span class="line">        printf(&quot;recv data of my world is: %s\n&quot;, recvbuf);</span><br><span class="line">    &#125;*/</span><br><span class="line">    close(clientSocket);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argv, char* arg[])&#123;</span><br><span class="line"></span><br><span class="line">    if (argv &gt; 1)&#123;</span><br><span class="line">        printf(&quot;start client...\n&quot;);</span><br><span class="line">        client();</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">        printf(&quot;start server...\n&quot;);</span><br><span class="line">        server();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Makefile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"># by jihan</span><br><span class="line">DIR_INC = .</span><br><span class="line">DIR_SRC = .</span><br><span class="line">DIR_OBJ = .</span><br><span class="line">DIR_BIN = .</span><br><span class="line"></span><br><span class="line">EVENT_LIB = /usr/local/lib</span><br><span class="line">EVENT_INC = /usr/local/include</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ALL_LD = -L$&#123;EVENT_LIB&#125;</span><br><span class="line">#ALL_INC = -I$&#123;EVENT_INC&#125;</span><br><span class="line">ALL_LIB = -lssl</span><br><span class="line"></span><br><span class="line">CXX = g++</span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -g -O2 -Wall -Werror</span><br><span class="line">MPIF90 = mpiif90</span><br><span class="line"></span><br><span class="line">SRC = $(wildcard $&#123;DIR_SRC&#125;/*.c)</span><br><span class="line">OBJ = $(patsubst %.c,$&#123;DIR_OBJ&#125;/%.o,$(notdir $&#123;SRC&#125;))</span><br><span class="line"></span><br><span class="line">TARGET = a.out</span><br><span class="line"></span><br><span class="line">BIN_TARGET = $&#123;DIR_BIN&#125;/$&#123;TARGET&#125;</span><br><span class="line"></span><br><span class="line">.PHONY:all</span><br><span class="line">all: $&#123;BIN_TARGET&#125;</span><br><span class="line"></span><br><span class="line">$&#123;BIN_TARGET&#125;: $&#123;OBJ&#125;</span><br><span class="line">$(CC) $(CFLAGS) $(OBJ)  -o $@ $(ALL_LD) $(ALL_LIB)</span><br><span class="line"></span><br><span class="line">$&#123;DIR_OBJ&#125;/%.o:$&#123;DIR_SRC&#125;/%.c</span><br><span class="line">$(CC) $(CFLAGS)  -c $&lt; -o $@ $(ALL_INC)</span><br><span class="line"></span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">-rm -f *.out</span><br><span class="line">-rm -f *.o</span><br><span class="line">#-rm -f ./ncfile/*.nc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fixed=xy04c</span><br><span class="line">.PHONY:$&#123;fixed&#125;</span><br><span class="line">$&#123;fixed&#125;: $&#123;fixed&#125;.c</span><br><span class="line">$(CC) $(CFLAGS) -o $@.out $&lt; $(ALL_LD) $(ALL_INC) $(ALL_LIB)</span><br><span class="line"></span><br><span class="line">IN=$(in)</span><br><span class="line">.PHONY:one</span><br><span class="line">one: $&#123;IN&#125;.c</span><br><span class="line">$(CC) $(CFLAGS) -o $&#123;IN&#125;.out $&lt; $(ALL_LD) $(ALL_INC) $(ALL_LIB)</span><br><span class="line"></span><br><span class="line">.PHONY:maketest</span><br><span class="line">maketest:</span><br><span class="line">-echo $&#123;SRC&#125;</span><br><span class="line">-echo $&#123;OBJ&#125; $&#123;BIN_TARGET&#125;</span><br><span class="line">-echo $(notdir $&#123;SRC&#125;)</span><br><span class="line"></span><br><span class="line">#（1）Makefile中的 符号 $@, $^, $&lt; 的意思：</span><br><span class="line">#　　$@  表示目标文件</span><br><span class="line">#　　$^  表示所有的依赖文件</span><br><span class="line">#　　$&lt;  表示第一个依赖文件</span><br><span class="line">#　　$?  表示比目标还要新的依赖文件列表</span><br><span class="line"></span><br><span class="line">#（2）wildcard、notdir、patsubst的意思：</span><br><span class="line">#　　wildcard : 扩展通配符</span><br><span class="line">#　　notdir ： 去除路径</span><br><span class="line">#　　patsubst ：替换通配符</span><br><span class="line"></span><br><span class="line">#（3）PHONY 表示伪目标，比如clean，如果文件中</span><br><span class="line">#  存在clean文件，那么添加了此关键字依旧能</span><br><span class="line">#  执行rm操作。</span><br></pre></td></tr></table></figure><p>linux 平台下：<br><code>make</code><br><code>./a.out</code>运行server<br><code>./a.out</code>运行client</p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TLV </tag>
            
            <tag> TCP </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非常有用的网站-持续更新</title>
      <link href="/2019/07/24/%E9%9D%9E%E5%B8%B8%E6%9C%89%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
      <url>/2019/07/24/%E9%9D%9E%E5%B8%B8%E6%9C%89%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>最好是大家都能科学上网，否则有些网站可能访问不了哟~ (๑`･ᴗ･´๑)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><a id="more"></a><h2 id="技术类"><a class="header-anchor" href="#技术类"></a>技术类</h2><h3 id="通用"><a class="header-anchor" href="#通用"></a>通用</h3><p><a href="https://www.google.com" target="_blank" rel="noopener">google：</a>：(ꈍᴗꈍ) 用<a href="https://cn.bing.com" target="_blank" rel="noopener">bing</a>也可以，百度什么的。。。<br><a href="https://github.com" target="_blank" rel="noopener">GitHub</a>：这个不用说了<br><a href="http://stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a>：全球最大的IT问答平台<br><a href="https://devdocs.io" target="_blank" rel="noopener">各种语言的API大集合</a>：基本所有语言的通用API都能找到，但是要注意平台。<br><a href="https://zh.cppreference.com/" target="_blank" rel="noopener">中文版C/C++API</a>:个人不太喜欢这个，同样要注意平台。比如C里的一些_s后缀的函数，gcc就不支持。</p><h3 id="Linux软件开发"><a class="header-anchor" href="#Linux软件开发"></a>Linux软件开发</h3><p><a href="https://www.ubuntu.com" target="_blank" rel="noopener">Ubuntu官网</a>，<a href="https://www.centos.org/" target="_blank" rel="noopener">Centos官网</a>：可能需要翻墙┐(´-｀)┌，先试试呗<br><a href="http://man.linuxde.net/" target="_blank" rel="noopener">linux常用命令</a>： 集成了几乎所有常用的linux命令，并且分类明确，示例丰富。包含gcc，php等软开命令<br><a href="https://linux.die.net/man/" target="_blank" rel="noopener">linux C函数</a>：几乎包含了linux下c语言开发所有的API文档。个人觉得说明不是特别详细。<br><a href="https://blog.csdn.net/scaleqiao/article/details/45153379" target="_blank" rel="noopener">vim命令大全</a>：的确很全，如果觉得不好找具体命令，可直接在页面使用ctrl+f查找<br><a href="https://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile" target="_blank" rel="noopener">Makefile编写</a>：较为全面的Makefile教程，也有<a href="https://www.cnblogs.com/Anker/p/3242207.html" target="_blank" rel="noopener">简单的</a>，以及我自己写的可<a href="https://github.com/JiHanHuang/Box/tree/master/Makefile" target="_blank" rel="noopener">直接用的</a>。<br>gdb调试：较为系统的gdb教程，附上<a href="https://blog.csdn.net/gnuhpc/article/details/4368831" target="_blank" rel="noopener">gdb命令大全</a>。还有界面比较华丽的<a href="https://www.gdbgui.com/" target="_blank" rel="noopener">gdbgui</a>。<br><a href="https://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">shell教程和基础教程</a>。初学用这个还不错，可以现场跑代码。</p><h3 id="Windows开发"><a class="header-anchor" href="#Windows开发"></a>Windows开发</h3><p><a href="https://docs.microsoft.com/en-us/windows/desktop/api/" target="_blank" rel="noopener">微软window开发中心</a>：官方网站，啥API查不到？</p><h2 id="其他"><a class="header-anchor" href="#其他"></a>其他</h2><h3 id="推荐平台"><a class="header-anchor" href="#推荐平台"></a>推荐平台</h3><p><a href="https://www.tutorialspoint.com/codingground.htm" target="_blank" rel="noopener">在线编程环境</a>：一个在线的开发环境，主流语言基本都支持，这个挺帅的ヾ(❀╹◡╹)ﾉ~</p><h3 id="图片资源网站"><a class="header-anchor" href="#图片资源网站"></a>图片资源网站</h3><p><a href="http://www.iconfont.cn/plus" target="_blank" rel="noopener">阿里图标站</a>，<a href="https://www.easyicon.net/" target="_blank" rel="noopener">easyicon图标</a><br><a href="http://wallpaperswide.com/" target="_blank" rel="noopener">高清壁纸</a>，<a href="https://unsplash.com/" target="_blank" rel="noopener">各种类型的高清图</a></p><h3 id="实用工具"><a class="header-anchor" href="#实用工具"></a>实用工具</h3><p><a href="http://www.yishimei.cn/network/290.html?=microkms_17.06.25" target="_blank" rel="noopener">Windows破解</a>：激活系统，破解office，及各种office软件下载。<br><a href="https://pyecharts.org/#/zh-cn/3d_charts" target="_blank" rel="noopener">python绘图工具</a>：非常方便实用，各种图形，图表，3D图形绘制。这里有简单<a href="https://www.zhihu.com/question/24590883" target="_blank" rel="noopener">样例</a>，还有一些其他python工具。<br><a href="http://weareoutman.github.io/markdoc/" target="_blank" rel="noopener">Markdown在线编辑</a> : 快捷方便，能够下载上传。<br><a href="https://www.diagrams.net/" target="_blank" rel="noopener">各种流程图，思维导图在线绘制</a>:非常方便，功能全面。并且支持Chrome插件。强推<br><a href="https://hotexamples.com/" target="_blank" rel="noopener">github示例代码搜索</a>:搜索git上的函数示例代码。除去看函数文档，这个也不失为一种好方法。可能学到骚操作哟。<br><a href="https://sketchviz.com/new" target="_blank" rel="noopener">graphviz手绘风格图</a>:用于dot语法绘图，常用流程图，时序图都能搞定，但需要点学习成本<br><a href="https://onlookerliu.github.io/2017/12/28/dot%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/#1-%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener">graphviz dot语法总结</a><br><a href="https://superdoctranslator.com/translator/zh/en_zh" target="_blank" rel="noopener">在线文档翻译软件</a>，<a href="https://www.bilibili.com/video/BV1zF411v7X2/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=9d76f4aee73aa8aa8f8ed448c1759a4d" target="_blank" rel="noopener">视频教程</a>， 对应<a href="https://api.fanyi.baidu.com/manage/developer" target="_blank" rel="noopener">百度翻译api开发者平台</a>，结果<a href="https://fanyi.baidu.com/mtpe-individual/#/editor/quickImport" target="_blank" rel="noopener">百度翻译</a>自己直接支持文档翻译(下载要vip)。<br><a href="https://www.ilovepdf.com/" target="_blank" rel="noopener">pdf的各种处理网站</a>，很强<br>电子书搜索：<br><a href="https://www.jiumodiary.com/" target="_blank" rel="noopener">摩鸠搜书</a></p><p>IT：<a href="https://hao.panziye.com/" target="_blank" rel="noopener">程序员专属网站</a><br>端游：<a href="https://game.nga.cn/" target="_blank" rel="noopener">端游测评网站</a>， IGN<br>手游测评:taptap<br>漫画：腾讯，快看<br>动漫：哔哩哔哩<br>政治：各大国内网站<br>经济：（知乎关注栏里）</p><h3 id="有那么一点点用的网站"><a class="header-anchor" href="#有那么一点点用的网站"></a>有那么一点点用的网站</h3>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
