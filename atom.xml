<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JiHan&#39;s Blog</title>
  
  <subtitle>随笔写写啦 (๑`･ᴗ･´๑)</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-07-14T06:46:35.949Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JiHan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生活工作的工具推荐和选择指南</title>
    <link href="http://yoursite.com/2023/01/28/%E7%94%9F%E6%B4%BB%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%E5%92%8C%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2023/01/28/生活工作的工具推荐和选择指南/</id>
    <published>2023-01-28T01:24:14.000Z</published>
    <updated>2023-07-14T06:46:35.949Z</updated>
    
    <content type="html"><![CDATA[<p>想要工作生活有条不紊的进行，免不了要借助一些工具，工具人(本人)给你提供了一点点关于工具选取和使用的建议呢(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　by JiHan</p><hr><a id="more"></a><h2 id="写在前面"><a class="header-anchor" href="#写在前面"></a>写在前面</h2><p>工具能使我们更好的学习，工作和生活，帮助我们解决一些问题。本文将包含以下内容，期望对您有所帮助：</p><ol><li>为何要使用工具</li><li>怎么从0到1选择工具</li><li>怎么选择好的工具</li><li>工具类别</li><li>个人工具推荐：笔记相关，计划相关，代办相关，文档相关…</li></ol><h2 id="为何使用工具"><a class="header-anchor" href="#为何使用工具"></a>为何使用工具</h2><h3 id="一个故事"><a class="header-anchor" href="#一个故事"></a>一个故事</h3><p>前几天，听一个朋友说，他有个弟弟，大学在读，假期太慢，就负责处理家里一部分小生意，也当是锻炼了。但是一天下来，搞得手忙脚乱，收货，货架整理，资金收支，一团乱麻。然后那个朋友就让他使用思维导图，把每一项列举出来，注意事项等。<br>后面他弟弟用了过后：“哇塞，简直太清晰了，我知道怎么把这个事情搞好了。你也太厉害了吧。”<br>我朋友，狗生第一次收到弟弟的赞扬（笑哭）</p><h3 id="工具的作用"><a class="header-anchor" href="#工具的作用"></a>工具的作用</h3><p>能帮助你脱离现在的困境，或者帮助你快速前行。有时候像你调到枯井里上面垂下的绳子，或者你跑半马时穿的跑鞋。是人类和动物的区别(狗头)</p><h2 id="工具的选择"><a class="header-anchor" href="#工具的选择"></a>工具的选择</h2><p>相信我，你遇到过的问题，别人都遇到过。但是别人中了彩票，你不一定中，哈哈<br>搜索引擎是21世纪最伟大的发明，也是我用的最多的软件。利用搜索软件(现在是个社交软件都有搜索引擎)看看和你有相同困境的人吧。</p><h3 id="从0到1选择工具"><a class="header-anchor" href="#从0到1选择工具"></a>从0到1选择工具</h3><h4 id="你的需求"><a class="header-anchor" href="#你的需求"></a>你的需求</h4><p>首先明确你的需求是什么，如果你老是丢三落四，那么你需求就是找个记忆的；如果你是自行车坏了，那你可能需要一个扳手。先明确自己的需求。</p><h4 id="选择适合的"><a class="header-anchor" href="#选择适合的"></a>选择适合的</h4><p>同类型的工具有很多，现在的时代，除非真的是自行车坏了，基本都是在依托手机工作和生活。因此明确需求过后，进行网上搜索，找到相关app进行下载和使用，选择一个用着最舒服，最合适的，<strong>是最合适的，而不是最好的</strong>。当然你不可能找到一个完全契合你的app，无妨，能够顺利解决问题就好。</p><h4 id="不轻易更换"><a class="header-anchor" href="#不轻易更换"></a>不轻易更换</h4><p>如果一个工具能顺利解决你所遇到的问题.并且使用比较舒适，就不要随意更换了，工具的使用和熟悉是需要成本的，同类工具的频繁更换只会浪费你的时间，而且新工具，多多少少还是有其他问题的。</p><h2 id="工具类型"><a class="header-anchor" href="#工具类型"></a>工具类型</h2><p>分类是个人随意想法分类的，不严谨也不全面，随便看看</p><h3 id="生活类"><a class="header-anchor" href="#生活类"></a>生活类</h3><ul><li>金钱 (支付宝，微信，各大行软件)</li><li>通信 (QQ，微信，手机本身，运营商软件)</li><li>外卖 (美团，饿了么)</li><li>影音娱乐 (网易云，腾讯视频，QQ音乐、哔哩哔哩)</li><li>出行 (百度地图，国航app)</li><li>辅助记忆：备忘录，TODO，笔记，日常记录</li><li>习惯养成：番茄时间，日常习惯打卡</li><li>学习：各类字典，阅读软件，视频软件，浏览器</li></ul><h3 id="工作类"><a class="header-anchor" href="#工作类"></a>工作类</h3><ul><li>文档 (word，wps)</li><li>通信 (钉钉，企业微信…)</li><li>人事软件 (OA, 邮箱…)</li><li>专业相关 (编程软件，绘图软件，设计软件…)</li><li>辅助类型：备忘，TODO，笔记，思维导图，时序图，浏览器</li></ul><h3 id="学习类"><a class="header-anchor" href="#学习类"></a>学习类</h3><ul><li>通信 (网课软件，聊天软件，浏览器)</li><li>阅读 (词典，浏览器，读书软件)</li><li>实体书或笔纸</li></ul><h3 id="个人推荐"><a class="header-anchor" href="#个人推荐"></a>个人推荐</h3><p>常见的软件，和娱乐类型的软件，我就不推荐了，大家都知道，我就列举一些能够更方便提升生活和学习质量的软件：</p><ul><li>印象笔记：主要用于笔记记录，支持跨平台，用了好些年了。你可以选择一个适合的软件，笔记软件有很多笔记积累，选好了基本不会换了，要谨慎。</li><li>坚果云：跨平台自动文档同步，文档相关数据同步很方便</li><li>怡养：坚果云同一公司，文档类型软件，包括思维导图，流程图，TODO，并且内嵌的word，excel，ppt（这个让我有些意外）</li><li>utools：电脑端效率提升工具，非常方便的去查找文件，启动程序，截图，图文转换等等，类似快捷的工具箱。支持插件化</li><li>vscode：主要文本编辑软件，和编程软件</li><li>朝暮计划：跨平台app，主要包含习惯养成，番茄时间，TODO表，备忘录等功能</li><li>护眼软件：苦逼社畜，不爱护眼睛，不注意身体。推荐一个根据时间动态调解平面亮度：<a href="https://justgetflux.com/" target="_blank" rel="noopener">f.lux</a>， 一个定时提醒你喝水休息的软件：<a href="http://www.fadetop.com/" target="_blank" rel="noopener">fadetop</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想要工作生活有条不紊的进行，免不了要借助一些工具，工具人(本人)给你提供了一点点关于工具选取和使用的建议呢(•̀⌄•́)&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　by JiHan&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Diameter协议学习笔记</title>
    <link href="http://yoursite.com/2023/01/17/Diameter%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2023/01/17/Diameter协议学习笔记/</id>
    <published>2023-01-17T08:30:36.000Z</published>
    <updated>2023-01-17T08:54:30.544Z</updated>
    
    <content type="html"><![CDATA[<p>工作需要，了解以下Diameter协议以及应用场景(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em><a href="https://baike.baidu.com/item/Diameter?fromModule=lemma_search-box" target="_blank" rel="noopener">Diameter协议介绍</a></em><br><em><a href="https://www.rfc-editor.org/rfc/rfc3588.html" target="_blank" rel="noopener">RFC3588</a></em></p><a id="more"></a><h2 id="简介"><a class="header-anchor" href="#简介"></a>简介</h2><h3 id="协议简介"><a class="header-anchor" href="#协议简介"></a>协议简介</h3><p>Diameter协议是<a href="https://baike.baidu.com/item/RADIUS/3073981" target="_blank" rel="noopener">Radius</a>(<a href="https://www.rfc-editor.org/rfc/rfc2865" target="_blank" rel="noopener">RFC2865</a>)的下一代<a href="https://baike.baidu.com/item/AAA/150315?fromtitle=AAA%E5%8D%8F%E8%AE%AE&amp;fromid=1161567&amp;fromModule=lemma_search-box" target="_blank" rel="noopener">AAA协议</a>（AAA是认证（Authentication）、授权（Authorization）和计费（Accounting）的简称，是网络安全中进行访问控制的一种安全管理机制，提供认证、授权和计费三种安全服务。），主要用于移动IP、NAS请求和移动代理的认证、授权和计费工作。</p><p>其中主要的业界实现：一个基于diameter的资源的策略管理的接口<a href="https://www.arib.or.jp/english/html/overview/doc/STD-T63v9_40/5_Appendix/Rel10/29/29214-a60.pdf" target="_blank" rel="noopener">3GPP 29.214</a></p><h3 id="关联简介"><a class="header-anchor" href="#关联简介"></a>关联简介</h3><p><a href="https://baike.baidu.com/item/RADIUS/3073981" target="_blank" rel="noopener">Radius简介</a><br><a href="https://www.cnblogs.com/ranzhong/p/14410221.html" target="_blank" rel="noopener">RADIUS和Diameter</a><br><a href="https://support.huawei.com/enterprise/zh/doc/EDOC1100086522" target="_blank" rel="noopener"><strong>RADIUS如何工作</strong></a>，文章比较详细的介绍了Radius的工作原理和场景<br><a href="https://blog.csdn.net/iteye_7332/article/details/82485179" target="_blank" rel="noopener">Diameter 协议详解</a><br><a href="https://baike.baidu.com/item/pap/4760747" target="_blank" rel="noopener">密码认证协议（PAP）</a></p><h2 id="Diameter的RFC标准"><a class="header-anchor" href="#Diameter的RFC标准"></a>Diameter的RFC标准</h2><h2 id="Radius环境搭建及使用"><a class="header-anchor" href="#Radius环境搭建及使用"></a>Radius环境搭建及使用</h2><h2 id="Diameter环境搭建及使用"><a class="header-anchor" href="#Diameter环境搭建及使用"></a>Diameter环境搭建及使用</h2><h2 id="业界实现环境搭建和使用"><a class="header-anchor" href="#业界实现环境搭建和使用"></a>业界实现环境搭建和使用</h2><h2 id="业界实现的源码阅读"><a class="header-anchor" href="#业界实现的源码阅读"></a>业界实现的源码阅读</h2><h2 id="Diameter在具体场景中的应用"><a class="header-anchor" href="#Diameter在具体场景中的应用"></a>Diameter在具体场景中的应用</h2><h2 id="其他"><a class="header-anchor" href="#其他"></a>其他</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作需要，了解以下Diameter协议以及应用场景(•̀⌄•́)&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://baike.baidu.com/item/Diameter?fromModule=lemma_search-box&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Diameter协议介绍&lt;/a&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc3588.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RFC3588&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术杂谈" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="Diameter" scheme="http://yoursite.com/tags/Diameter/"/>
    
  </entry>
  
  <entry>
    <title>《万历十五年》读书笔记</title>
    <link href="http://yoursite.com/2023/01/16/%E3%80%8A%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2023/01/16/《万历十五年》读书笔记/</id>
    <published>2023-01-16T02:17:30.000Z</published>
    <updated>2023-01-31T15:53:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>与其说是笔记，不如说是读后感。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><a id="more"></a><p>最开始因为推荐看这本书，推荐理由大概是：书中采用了独特的视角看待历史，用一种大历史观去评判历史。按照这种推荐，我尝试看了看，期初，我并没有感到什么是大历史观，书中章节通过几大人物为切入点来描述万历年间的历史，而我看到的这些人物，都是普普通通的人，感觉很是平凡，没有对清官的称赞，没有对改革者功绩的肯定，没有对大将军的夸赞。感觉他们只是尽力而为的普通人，都郁郁而终。<br>从对万历皇帝的描述，我感受到了一个从孩童懵懂-&gt;少年的励志-&gt;青年的壮志-&gt;中年的摆烂。年少的皇帝，九岁即位，上有母后，师长，下有群臣百姓。没有快乐的童年，年少即位，对于很多事情都依赖师长——张居正。少年时期努力学习，青年时期跟随张居正开始尝试改革；张居正死后，由于立太子的心愿无法达成，加上从小到大文官对自己的约束，而又无力改变。开始摆烂。<br>而张居正，则是一心想要进行改革的人，虽然书中对他的描写并感觉不到什么赞扬。可惜整个经济体制的结构，时代限制，文官集团限制，最后改革也并未成功，死前奉为太师，死后差点挖坟。<br>申时行则因为张居正的前车之鉴，加上自己又受张居正提携。他做首辅之时，则不敢大刀阔斧的改革，而是想采用中庸的办法来缓解朝廷内部的矛盾，按我们现在的话说，就是和事老。<br>而海瑞的描述，感觉就是一个偏执的人，一丝不苟正直的作风，有股出淤泥而不染的作风。但可惜的是，他想让这摊浑水变清澈。<br>我从其他地方得知的戚继光，完美抗倭英雄；用兵如神的大将军。而这里面，他的确非常有带兵打仗的军事天赋，并且能够在有限的条件下达到如此成就，也的确不凡。可惜也随着张居正倒台随之郁郁不得志了。<br>李贽说是一个哲学家，不如说一个空想家。好在有些才华，不然感觉很难混下去。按作者的说法，他最大的功绩在于：我们又多了一个视角看待当时的世界。<br>总体来说，上面六人，都是有心想要做出改革的人。张居正和申时行作为政治家，想通过政策改变来改变明朝当时的现状，海瑞也是同样如此。戚继光则想壮大国家的军事实力，万历皇帝当然想得到“尧舜之帝”的称颂；李贽则想从思想层面来找出道路。无一例外都失败了，和万历皇帝的“摆烂”关系不大，和张居正的“贪腐”关系不大，和申时行的“不作为”关系不大，和海瑞“刚愎自用”的改革关系不大，当然和李贽不切实际的哲学理论关系更不大了。关键在于当时整个社会固化的小农经济体制，对商业的不重视，以道德代替法律的政治框架导致。<br>直到最后，我才渐渐明白这就是大历史观，历史的兴衰不在乎个人的英明或贪腐，而在整个社会形态(意识和经济基础)和政治体系是否脱节，个人的作用往往只能减缓或加速这一进程。而作者之所以专门拿出万历十五年来写(每个朝代都存在这种脱节)，估计是万历年间是中国在世界的地位由胜到衰的转折点吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与其说是笔记，不如说是读后感。&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>《C++ Primer Plus》读书笔记</title>
    <link href="http://yoursite.com/2023/01/16/%E3%80%8AC-Primer-Plus%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2023/01/16/《C-Primer-Plus》读书笔记/</id>
    <published>2023-01-16T02:17:05.000Z</published>
    <updated>2023-01-16T02:20:19.609Z</updated>
    
    <content type="html"><![CDATA[<p>从C开发转到C++的初学者(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>主题： C++入门相关书籍<br>类别：计算机-&gt;实用性+理论性论述书-&gt;nginx<br>概要：从模块开发了解nginx的使用以及nginx整体结构。从源码原理解析了解nginx底层设计和各种优化操作。</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>作者想通过文章帮助人们了解nginx的模块开发，和其内部实现原理。<br>而我也想进行nginx源码学习，了解其中的实现原理和架构，以及一些实现亮点。</p><h2 id="主旨"><a class="header-anchor" href="#主旨"></a>主旨</h2><h3 id="文章的核心内容"><a class="header-anchor" href="#文章的核心内容"></a>文章的核心内容</h3><h4 id="核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。"><a class="header-anchor" href="#核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。"></a>核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。</h4><h3 id="整本书的架构"><a class="header-anchor" href="#整本书的架构"></a>整本书的架构</h3><h4 id="作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。"><a class="header-anchor" href="#作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。"></a>作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。</h4><h3 id="问题处理"><a class="header-anchor" href="#问题处理"></a>问题处理</h3><h4 id="作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。"><a class="header-anchor" href="#作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。"></a>作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。</h4><h2 id="章节"><a class="header-anchor" href="#章节"></a>章节</h2><h3 id="nginx模块开发"><a class="header-anchor" href="#nginx模块开发"></a>nginx模块开发</h3><p>该模块主要进行nginx整体架构的初步介绍，并指导进行相关的实践操作，进行相关模块开发。</p><h4 id><a class="header-anchor" href="#"></a></h4><h3 id="nginx原理"><a class="header-anchor" href="#nginx原理"></a>nginx原理</h3><p>从架构深入到内部实现，讲解nginx源码的各个模块的关键设计。需要配合源码来进行阅读。</p><h4 id="-v2"><a class="header-anchor" href="#-v2"></a></h4><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><h3 id="所得"><a class="header-anchor" href="#所得"></a>所得</h3><h4 id="作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？"><a class="header-anchor" href="#作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？"></a>作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？</h4><h3 id="所想"><a class="header-anchor" href="#所想"></a>所想</h3><h4 id="看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。"><a class="header-anchor" href="#看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。"></a>看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。</h4><h3 id="相关"><a class="header-anchor" href="#相关"></a>相关</h3><h4 id="可以列出相关的看过的书籍，或者问题参考链接网页一类的。"><a class="header-anchor" href="#可以列出相关的看过的书籍，或者问题参考链接网页一类的。"></a>可以列出相关的看过的书籍，或者问题参考链接网页一类的。</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从C开发转到C++的初学者(•̀⌄•́)&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;主题： C++入门相关书籍&lt;br&gt;
类别：计算机-&amp;gt;实用性+理论性论述书-&amp;gt;nginx&lt;br&gt;
概要：从模块开发了解nginx的使用以及nginx整体结构。从源码原理解析了解nginx底层设计和各种优化操作。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C/C++" scheme="http://yoursite.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>CS144 计算机网络笔记</title>
    <link href="http://yoursite.com/2022/11/12/CS144-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/11/12/CS144-计算机网络笔记/</id>
    <published>2022-11-12T10:49:39.000Z</published>
    <updated>2023-07-14T07:48:53.907Z</updated>
    
    <content type="html"><![CDATA[<p>补足一下计算机网络知识(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>主题：计算机网络<br>类别：计算机-&gt;原理性+实用性-&gt;计算机网络<br>概要：更加系统的学习计算机网络，并完成相应的实验</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>计算机网络知识一直比较欠缺，并且没有系统学习过。工作后发现很多地方都是一知半解，故重新学习。<br><code>CS144</code>也是比较知名的计算机网络公开课，主要是搭配了对应的lab，从学习到实践深度理解。<br><a href="https://cs144.github.io/" target="_blank" rel="noopener">CS144课程主页</a><br><a href="https://www.bilibili.com/video/BV1e5411c7aY/" target="_blank" rel="noopener">bilibili课程视频</a></p><p><em>课程lab是基于C++和linux平台的，这些都是前置的基础知识</em></p><h2 id="课程学习"><a class="header-anchor" href="#课程学习"></a>课程学习</h2><p>如果只看视频课程，估计没有几分钟就睡着了。建议看几节课程后开始进行对应的lab，如果有对应的网络基础，可以直接进行lab。</p><h3 id="基础课程-lab0"><a class="header-anchor" href="#基础课程-lab0"></a>基础课程+lab0</h3><h4 id="基础课程"><a class="header-anchor" href="#基础课程"></a>基础课程</h4><p>课程基础，以上面bilibili的视频为例，学完P0-Pxx基本就可以开始lab0了</p><h4 id="lab0"><a class="header-anchor" href="#lab0"></a>lab0</h4><p><a href="https://cs144.github.io/assignments/lab0.pdf" target="_blank" rel="noopener">lab0 指导手册</a><br>英文不好的(比如我)，有点耐心慢慢看就好。<br>lab0中主要使用c<ins>作为主要开发语言，而且采用了比较严格的c</ins>的语法，还是需要一定的基础的。</p><h4 id="lab1"><a class="header-anchor" href="#lab1"></a>lab1</h4><p><a href="https://cs144.github.io/assignments/lab1.pdf" target="_blank" rel="noopener">lab1 指导手册</a></p><h3 id="观点2"><a class="header-anchor" href="#观点2"></a>观点2</h3><h3 id="观点3"><a class="header-anchor" href="#观点3"></a>观点3</h3><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><h3 id="延展"><a class="header-anchor" href="#延展"></a>延展</h3><h4 id="作者所提出的问题，是否就是你真正想问的问题？是否有必要进行分析阅读？理由？"><a class="header-anchor" href="#作者所提出的问题，是否就是你真正想问的问题？是否有必要进行分析阅读？理由？"></a>作者所提出的问题，是否就是你真正想问的问题？是否有必要进行分析阅读？理由？</h4><h3 id="相关"><a class="header-anchor" href="#相关"></a>相关</h3><h4 id="可以列出相关的看过的书籍，或者问题参考链接网页一类的。"><a class="header-anchor" href="#可以列出相关的看过的书籍，或者问题参考链接网页一类的。"></a>可以列出相关的看过的书籍，或者问题参考链接网页一类的。</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;补足一下计算机网络知识(•̀⌄•́)&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;主题：计算机网络&lt;br&gt;
类别：计算机-&amp;gt;原理性+实用性-&amp;gt;计算机网络&lt;br&gt;
概要：更加系统的学习计算机网络，并完成相应的实验&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>linux进程通信及示例</title>
    <link href="http://yoursite.com/2022/08/03/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8F%8A%E7%A4%BA%E4%BE%8B/"/>
    <id>http://yoursite.com/2022/08/03/linux进程通信及示例/</id>
    <published>2022-08-03T03:09:06.000Z</published>
    <updated>2022-08-19T07:51:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍linux进程通信的几种方式，以及每一种方式的适用场景。并给出了相应示例。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>需要一定linux的使用背景以及C语言基础。<br><strong>什么是进程通信：</strong><br>进程间通信(InterProcess Communication, IPC)是指在不同进程之间传播或交换信息。<br>IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享内存、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。本文只针对经典的IPC，即：管道、消息队列、信号量及共享内存。</p><h2 id="进程通信"><a class="header-anchor" href="#进程通信"></a>进程通信</h2><h3 id="管道"><a class="header-anchor" href="#管道"></a>管道</h3><p>我们常说的管道，都指匿名管道，FIFO通常会用命名管道一词<br>管道的使用会存以下两个限制：</p><ol><li>管道的通信都是半双工的(即数据只能在一个方向流动)</li><li>管道只能在具有公共祖先的两个进程之间通信。通常一个管道进程<code>fork</code>出子进程后，管道就能在父子进程之间通信了。</li></ol><p>管道创建函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p><code>fd[0]</code>为读打开，即输出，<code>fd[1]</code>为写打开，即为输入。一个典型的工作场景：<br>即进程先调用<code>pipe</code>，再进行<code>fork</code><br><img src="/2022/08/03/linux进程通信及示例/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E7%A4%BA%E4%BE%8B.jpg" alt><br>然后我们根据需要各自关闭父子进程的读/写通道。<br><img src="/2022/08/03/linux进程通信及示例/%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%88%B0%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%A1%E9%81%93.jpg" alt></p><h5 id="示例"><a class="header-anchor" href="#示例"></a>示例</h5><p>我们在程序中需要执行一个命令，并且获得命令输出的结果。比如我们要执行<code>date</code>命令:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUN_CMD <span class="meta-string">"/usr/bin/date"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">char</span> output[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123; <span class="comment">//parent</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (read(fd[<span class="number">0</span>], output, <span class="keyword">sizeof</span>(output)<span class="number">-1</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read error"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parent:\n%s"</span>, output);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//child</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        execv(RUN_CMD, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./main </span><br><span class="line">Parent:</span><br><span class="line">Wed Aug  3 16:10:57 CST 2022</span><br></pre></td></tr></table></figure><p><code>execv</code>函数<a href="https://linux.die.net/man/3/execv" target="_blank" rel="noopener">参考</a><br>当然上述功能也可以用<a href="https://www.man7.org/linux/man-pages/man3/popen.3.html" target="_blank" rel="noopener">popen</a>函数实现。更加简单。</p><h5 id="适用场景"><a class="header-anchor" href="#适用场景"></a>适用场景</h5><p>由于管道的限制，常常用于父进程和子进程之间的通信。<br>最为常见的应用就是<code>shell</code>中使用的<code>|</code>管道符了。</p><h3 id="命名管道"><a class="header-anchor" href="#命名管道"></a>命名管道</h3><p>命名管道(FIFO)，相比于管道来说，他的限制只有一个：</p><ol><li>通信都是半双工的(即数据只能在一个方向流动)</li></ol><p>这就意味着它能用于不相干的进行之间进行数据通信。<br>FIFO本质上就是一种文件类型，可通过查看文件的<code>stat</code>结构中的<code>st_mode</code>编码得知。比如FIFO文件，我们执行<code>stat file.name</code>会看到<code>fifo</code>字样。<br>FIFO创建函数(有点类似文件创建):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__path, <span class="keyword">__mode_t</span> __mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span> <span class="params">(<span class="keyword">int</span> __fd, <span class="keyword">const</span> <span class="keyword">char</span> *__path, <span class="keyword">__mode_t</span> __mode)</span></span>;</span><br><span class="line"><span class="comment">//函数返回值成功为0，错误为-1</span></span><br></pre></td></tr></table></figure><p><code>mkfifo</code>函数与<code>open</code>函数类似。<br><code>mkfifoat</code>函数则用来在<code>fd</code>文件描述符表示的目录相关的位置创建一个FIFO<br><em>函数具体参数可参考<a href="https://man7.org/linux/man-pages/man3/mkfifo.3.html" target="_blank" rel="noopener">man手册</a></em></p><p>我们也可以可以通过<code>mkfifo</code>命令来创建FIFO文件<br>同样，对FIFO的读写操作，类似于对文件的读写。<br>当<code>open</code>一个FIFO文件时，可指定是否阻塞：<code>O_NONBLOCK</code>标记。</p><ul><li>不指定：读/写都会阻塞，直到有对应的写/读到来</li><li>指定：如果读/写时没有对应的写/读，会返回相应的错误码</li></ul><p>如果是多个进程进行写操作，为了防止写入数据交叉，需要设置操作原子性，<code>PIPE_BUF</code>就是对应原子性数据的大小。<br>我们常常遇到的一种情况：<br><img src="/2022/08/03/linux进程通信及示例/FIFO%E7%A4%BA%E4%BE%8B.jpg" alt></p><h5 id="示例-v2"><a class="header-anchor" href="#示例-v2"></a>示例</h5><p>我们创建两个子进程写入数据，父进程读出数据(当然不一定要父子进程)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> fifo_file[] = <span class="string">"/tmp/fifo_file"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pid1=<span class="number">0</span>, pid2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    mkfifo(fifo_file,O_CREAT |O_RDWR);</span><br><span class="line">    pid1 = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid1  &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        pid2 = fork();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid1 &gt; <span class="number">0</span> &amp;&amp; pid2 &gt; <span class="number">0</span> )&#123; <span class="comment">//parent</span></span><br><span class="line">        <span class="comment">// 读写方式打开，read函数则会阻塞，一直等待数据来临</span></span><br><span class="line">        <span class="comment">// 只读方式打开，则子进程写完(也可能没写完)，read函数返回0值，退出</span></span><br><span class="line">        <span class="comment">//fd = open(fifo_file, O_RDWR);</span></span><br><span class="line">        fd = open(fifo_file, O_RDONLY);</span><br><span class="line">        <span class="comment">//确保2个进程都写完</span></span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        waitpid(pid1,&amp;status,<span class="number">0</span>);</span><br><span class="line">        waitpid(pid2,&amp;status,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (read(fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"read:%s"</span>, buf);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid1 &lt; <span class="number">0</span> || pid2 &lt; <span class="number">0</span>) &#123; <span class="comment">//error</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//children</span></span><br><span class="line">        fd = open(fifo_file, O_WRONLY);</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">"hello: %d, %d\n"</span>,pid1, pid2);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./main </span><br><span class="line">read:hello: 0, 0</span><br><span class="line">hello: 17967, 0</span><br></pre></td></tr></table></figure><p>也可以用命令行达到上面的效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello1"</span> &gt;&gt; fifo &amp;</span></span><br><span class="line">[1] 30040</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello2"</span> &gt;&gt; fifo &amp;</span></span><br><span class="line">[2] 30041</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat fifo </span></span><br><span class="line">hello1</span><br><span class="line">hello2</span><br><span class="line">[1]-  Done                    echo "hello1" &gt;&gt; fifo</span><br><span class="line">[2]+  Done                    echo "hello2" &gt;&gt; fifo</span><br></pre></td></tr></table></figure><p>注意，使用命令的时候，都是阻塞的，读写不需同时存在，否则会阻塞。</p><h5 id="适用场景-v2"><a class="header-anchor" href="#适用场景-v2"></a>适用场景</h5><ol><li>数据缓冲，缓存来不及处理的数据。</li><li>时钟域隔离。</li><li>用于不同宽度的数据接口。</li></ol><p><em>后两种可参考网上解释</em></p><h3 id="消息队列"><a class="header-anchor" href="#消息队列"></a>消息队列</h3><p>消息队列是消息的链接表，存储在内核中，有消息队列表示符标识。<br>意味着内核里有现成的消息队列，让你可直接使用。<br><code>msgget</code>则是创建或者打开一个现有队列。<a href="https://man7.org/linux/man-pages/man2/msgget.2.html" target="_blank" rel="noopener">msgget详解</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span> <span class="params">(<span class="keyword">key_t</span> __key, <span class="keyword">int</span> __msgflg)</span></span>;</span><br></pre></td></tr></table></figure><p>每个队列都包含一个<code>msqid_ds</code>的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span><span class="comment">/* structure describing operation permission */</span></span><br><span class="line">  <span class="keyword">__time_t</span> msg_stime;<span class="comment">/* time of last msgsnd command */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __x86_64__</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __unused1;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">__time_t</span> msg_rtime;<span class="comment">/* time of last msgrcv command */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __x86_64__</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __unused2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">__time_t</span> msg_ctime;<span class="comment">/* time of last change */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __x86_64__</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __unused3;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">__syscall_ulong_t</span> __msg_cbytes; <span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">  <span class="keyword">msgqnum_t</span> msg_qnum;<span class="comment">/* number of messages currently on queue */</span></span><br><span class="line">  <span class="keyword">msglen_t</span> msg_qbytes;<span class="comment">/* max number of bytes allowed on queue */</span></span><br><span class="line">  <span class="keyword">__pid_t</span> msg_lspid;<span class="comment">/* pid of last msgsnd() */</span></span><br><span class="line">  <span class="keyword">__pid_t</span> msg_lrpid;<span class="comment">/* pid of last msgrcv() */</span></span><br><span class="line">  <span class="keyword">__syscall_ulong_t</span> __unused4;</span><br><span class="line">  <span class="keyword">__syscall_ulong_t</span> __unused5;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以通过<code>msgctl</code>函数获取或设置<code>msqid_ds</code>操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span> <span class="params">(<span class="keyword">int</span> __msqid, <span class="keyword">int</span> __cmd, struct msqid_ds *__buf)</span></span>;</span><br></pre></td></tr></table></figure><p>可以使用<code>msgsnd</code>来添加消息到队列尾，使用<code>msgrcv</code>获取消息，当然不一定要先入先出，也可以按照消息类型来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span> <span class="params">(<span class="keyword">int</span> __msqid, <span class="keyword">const</span> <span class="keyword">void</span> *__msgp, <span class="keyword">size_t</span> __msgsz,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> __msgflg)</span></span>;<span class="comment">//成功:0，失败:-1</span></span><br><span class="line"><span class="keyword">ssize_t</span> msgrcv (<span class="keyword">int</span> __msqid, <span class="keyword">void</span> *__msgp, <span class="keyword">size_t</span> __msgsz,</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> __msgtyp, <span class="keyword">int</span> __msgflg);<span class="comment">//成功:接收字符长度，失败:-1</span></span><br></pre></td></tr></table></figure><p>同样可以通过设置<code>__msgflg</code>来确定是阻塞还是非阻塞IO操作。<br><code>msgsnd</code>中的<code>__msgp</code>可以是如下结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mymesg</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> msgtyp;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">512</span>]; <span class="comment">//对应着__msgsz的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中队列的最大消息数是根据最大队列数和最大数据量来决定的。可以通过<code>msqid_ds</code>中的<code>msg_qbytes</code>得知</p><h5 id="示例-v3"><a class="header-anchor" href="#示例-v3"></a>示例</h5><p>还是常见示例，做一个父子进程的消峰值处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> msg_bytes 512</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> type;</span><br><span class="line">    <span class="keyword">char</span> text[msg_bytes];</span><br><span class="line">&#125; msg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid, pid1=<span class="number">0</span>, pid2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret,msgid;</span><br><span class="line"></span><br><span class="line">    msgid = msgget(IPC_PRIVATE,<span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"msgget error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pid1 = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid1  &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        pid2 = fork();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid1 &gt; <span class="number">0</span> &amp;&amp; pid2 &gt; <span class="number">0</span> )&#123; <span class="comment">//parent</span></span><br><span class="line">        pid = getpid();</span><br><span class="line">        msg tmp;</span><br><span class="line">        <span class="comment">//阻塞方式</span></span><br><span class="line">        <span class="comment">//while ((ret = msgrcv(msgid, (void *)&amp;tmp, msg_bytes, 1, 0)) &gt; 0)&#123;</span></span><br><span class="line">        <span class="comment">//非阻塞方式</span></span><br><span class="line">        <span class="keyword">while</span> ((ret = msgrcv(msgid, (<span class="keyword">void</span> *)&amp;tmp, msg_bytes, <span class="number">1</span>, IPC_NOWAIT)))&#123;</span><br><span class="line">            <span class="keyword">if</span> ((ret &lt; <span class="number">0</span>) &amp;&amp; (errno != ENOMSG)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d, %d read:%s\n"</span>, pid, ret, tmp.text);</span><br><span class="line">            <span class="built_in">memset</span>(&amp;tmp.text, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp.text));</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"msg receive over. %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        waitpid(pid1,&amp;status,<span class="number">0</span>);</span><br><span class="line">        waitpid(pid2,&amp;status,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent process[%d] exit\n"</span>, pid);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid1 &lt; <span class="number">0</span> || pid2 &lt; <span class="number">0</span>) &#123; <span class="comment">//error</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//children</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        pid = getpid();</span><br><span class="line">        msg tmp = &#123;.type = <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">            tmp.type = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">sprintf</span>(tmp.text, <span class="string">"hello: %d, N:%d\n"</span>, pid, i);</span><br><span class="line">            <span class="keyword">if</span> ((ret = msgsnd(msgid, &amp;tmp, msg_bytes, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"msg send error:%s\n"</span>,strerror(errno));</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;tmp.text, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp.text));</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process[%d] exit\n"</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="适用场景-v3"><a class="header-anchor" href="#适用场景-v3"></a>适用场景</h5><p>从速度上来说，<code>消息队列</code>和<code>unix sock</code>并没有太大差别，消息队列的主要用途：</p><ol><li>应用解耦</li><li>异步消息</li><li>流量削锋</li></ol><h3 id="信号量"><a class="header-anchor" href="#信号量"></a>信号量</h3><p>和之前的<code>IPC</code>不同，信号量是一个计数器，用于为多个进程提供共享数据对象的访问。</p><h5 id="示例-v4"><a class="header-anchor" href="#示例-v4"></a>示例</h5><h5 id="适用场景-v4"><a class="header-anchor" href="#适用场景-v4"></a>适用场景</h5><h3 id="共享内存"><a class="header-anchor" href="#共享内存"></a>共享内存</h3><h5 id="简介"><a class="header-anchor" href="#简介"></a>简介</h5><h5 id="示例-v5"><a class="header-anchor" href="#示例-v5"></a>示例</h5><h5 id="适用场景-v5"><a class="header-anchor" href="#适用场景-v5"></a>适用场景</h5><h2 id="各个进程通信比较"><a class="header-anchor" href="#各个进程通信比较"></a>各个进程通信比较</h2><h3 id="进程对于共享资源的访问互斥方式"><a class="header-anchor" href="#进程对于共享资源的访问互斥方式"></a>进程对于共享资源的访问互斥方式</h3><ol><li>信号量，就是标记共享资源还有多少可使用，使用了就-1。本质上就是存在于内核的一个计数器，可以通过<code>semget</code>系列函数来获取信号量。</li><li>使用记录锁，即创建一个空文件，并用改文件的第一个字节(不一定存在)作为锁字节。获取和释放资源时会进行写锁和释放锁。进程终止时，内核会自动释放该锁。</li><li>互斥量，需要将共享资源加载到内存，互斥量在文件的相同偏移出初始化互斥量。</li></ol><h4 id="区别和比较"><a class="header-anchor" href="#区别和比较"></a>区别和比较</h4><p>性能：信号量和记录锁的性能差别不大，互斥量则有量级的性能提升。<br>这里通常使用的还是记录锁，信号量相比记录锁操作更为繁琐，而互斥量的稳定性和适配则不如记录锁。除非异常追求性能，不然通常都选择记录锁。</p><h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/qq_44443986/article/details/115065540" target="_blank" rel="noopener">Linux 进程间通信(IPC)—大总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍linux进程通信的几种方式，以及每一种方式的适用场景。并给出了相应示例。&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SSL体系理解</title>
    <link href="http://yoursite.com/2022/07/27/SSL%E4%BD%93%E7%B3%BB%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2022/07/27/SSL体系理解/</id>
    <published>2022-07-27T07:07:48.000Z</published>
    <updated>2022-08-03T03:14:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>从整体上理解ssl干了什么事情，证书又起什么作用。只关注功能流程，不关注细节实现(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><a id="more"></a><h3 id="背景"><a class="header-anchor" href="#背景"></a>背景</h3><h4 id="本文目的"><a class="header-anchor" href="#本文目的"></a>本文目的</h4><p>主要从整体流程上介绍<code>ssl</code>的作用，<code>证书</code>作用，从大体上对<code>证书和ssl</code>有一定理解</p><h4 id="背景知识"><a class="header-anchor" href="#背景知识"></a>背景知识</h4><ol><li>基础网络知识，类似TCP/IP</li><li>常见加密算法类型，了解<a href="https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/2152944" target="_blank" rel="noopener">对称加密</a>和<a href="https://blog.csdn.net/u014294681/article/details/86705999" target="_blank" rel="noopener">非对称加密</a></li></ol><h4 id="主要涉及"><a class="header-anchor" href="#主要涉及"></a>主要涉及</h4><ul><li><strong>SSL</strong>： 主要用于<strong>加密</strong>和<strong>鉴别</strong></li><li><strong>使用场景</strong>： 常见基于<code>TCP</code>协议上，使用<code>TCP+SSL</code>协议构成<code>TLS</code>协议。基于<code>TLS</code>上传输<code>HTTP</code>报文行程了<code>HTTPS</code></li><li><strong>RSA</strong>： 非对称加密的一种算法，主要用于SSL中报文私钥的生成。</li><li><strong>证书</strong>： 主要用于SSL握手中对对方身份的鉴别</li></ul><h3 id="HTTPS的握手流程"><a class="header-anchor" href="#HTTPS的握手流程"></a>HTTPS的握手流程</h3><p>HTTPS本质是在TLS上传输数据，那么从通信开始，到正式传输数据要经历三个阶段：</p><pre class="mermaid">graph TDA(TCP 3次握手)B(RSA秘钥交换)C(用秘钥加密数据)A --> BB -- 生成对称秘钥 --> CclassDef orange fill:#f96,stroke:#333,stroke-width:4px;class B orange</pre><p><strong>TIPS：</strong><br>问： 为何要用RSA秘钥交换<br>答：非对称加密算法的保密性好，不需要交换秘钥</p><p>问：为何用对称秘钥加密数据通信<br>答：因为快</p><p>其中关键的一步就是<strong>RSA秘钥交换</strong><br><img src="/2022/07/27/SSL体系理解/ssl%E9%80%9A%E4%BF%A1.png" alt="HTTPS流程"><br><em>图片源于网络(具体引用路径忘了)</em></p><p><strong>TIPS：</strong></p><ol><li>服务器中的公钥和私钥，主要用于协商生成随机秘钥(后续数据通信的对称秘钥)</li><li>此流程中，客户端会验证服务端发送的公钥，通常这个公钥就包含在我们常见的证书中。</li><li>此流程是常见的简单流程，涉及到双向校验等更复杂的流程，可自行研究。</li></ol><p>那么这里的公钥，即证书是怎么颁发的呢？证书结构如何呢？<br>这就涉及到我们第二个内容</p><h3 id="证书"><a class="header-anchor" href="#证书"></a>证书</h3><h4 id="证书作用"><a class="header-anchor" href="#证书作用"></a>证书作用</h4><ol><li>保证你网络上访问的地址，是真实的服务器，而不是伪造的。比如你访问<code>www.baidu.com</code>时，是真正访问的百度，而不是其他的伪造网站。</li><li>这里有一个<code>PY</code>交易，即你的浏览器或电脑上有很多内置的权威根CA证书，只要你访问的网站，返回证书是这个根证书下颁发的，则是可信的。如果不在这个列表里，则需要你导入证书。比如你可以在<code>windows</code>上看到(<code>win+R</code>执行<code>certmgr.msc</code>)：<br><img src="/2022/07/27/SSL体系理解/%E4%BF%A1%E4%BB%BB%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84%E7%A4%BA%E4%BE%8B.jpg" alt></li></ol><h4 id="证书颁发"><a class="header-anchor" href="#证书颁发"></a>证书颁发</h4><ul><li><strong>证书颁发机构</strong>：是一家知名且受信任的组织，它对网站进行验证以确保互联网更安全。</li><li><strong>CA证书</strong>：CA机构颁发的证明，是一种数字证书。它包含了公钥、公钥拥有者名称、CA的数字签名、有效期、授权中心名称、证书序列号等信息。我们可以通俗的理解为数字证书是个人或企业在网络上的身份证。</li><li><strong>申请CA证书</strong>：为保障申请CA证书的是真实合法的机构。申请时需要一系列的文件，比如：营业执照、身份证、公司法人身份证、诚信承诺书、公司公章及法人章印模等。</li><li><strong>数字证书签名原理</strong>：同样使用的是非对称加密算法，每个数字证书都包含证书信息和公私钥对<br><img src="/2022/07/27/SSL体系理解/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86.png" alt><br><em><a href="https://blog.csdn.net/u014294681/article/details/86705999" target="_blank" rel="noopener">图片来源</a></em></li><li><strong>证书链及域名证书</strong>：CA证书下可以签发一系列的子证书及域名证书，形成证书链。本质上，你申请的CA证书也是子证书。<br><img src="/2022/07/27/SSL体系理解/%E8%AF%81%E4%B9%A6%E9%93%BE.png" alt="证书链"><br><em><a href="https://en.wikipedia.org/wiki/Chain_of_trust" target="_blank" rel="noopener">图片来源</a></em></li></ul><h4 id="证书结构"><a class="header-anchor" href="#证书结构"></a>证书结构</h4><p>一个证书中包含：</p><ol><li>基本字段<ul><li>版本：目前主流的证书版本是V3</li><li>序列号：证书颁发机构CA分配给证书的唯一标识</li><li>签名算法：用于签名的哈希算法和数字签名算法</li><li>签名哈希算法：用于签名的哈希算法</li><li>颁发者：证书颁发机构CA的详细信息</li><li>有效期：证书生效日期和失效日期</li><li>使用者：证书使用者的详细信息</li><li>公钥：公钥密码算法、密钥长度和使用者公钥内容</li></ul></li><li>扩展字段</li><li>证书签名<br><img src="/2022/07/27/SSL体系理解/%E8%AF%81%E4%B9%A6%E7%BB%93%E6%9E%84.jpg" alt><br><em><a href="https://flylib.com/books/en/1.2.1.137/1/" target="_blank" rel="noopener">图片来源</a></em></li></ol><h4 id="证书校验"><a class="header-anchor" href="#证书校验"></a>证书校验</h4><ol><li>只要你上级证书可信，你就可信。不然一直向上追溯，直到浏览器或系统的证书列表，可参考<a href="https://blog.csdn.net/justinzengTM/article/details/104154100" target="_blank" rel="noopener">证书链-证书校验</a></li><li>当前证书校验：将证书信息计算hash，是否等于指纹通过公钥计算得到的hash值。<br><img src="/2022/07/27/SSL体系理解/%E8%AF%81%E4%B9%A6%E6%A0%A1%E9%AA%8C.jpg" alt><br><em><a href="https://zhuanlan.zhihu.com/p/403704980" target="_blank" rel="noopener">图片来源</a></em></li></ol><p>至此，基本明确了ssl+证书是如何工作了。对其中细节想有更深入了解，可自行研究。</p><h3 id="参考链接"><a class="header-anchor" href="#参考链接"></a>参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/133375078" target="_blank" rel="noopener">一篇文章让你彻底弄懂SSL/TLS协议</a><br><a href="https://blog.csdn.net/u014294681/article/details/86705999" target="_blank" rel="noopener">加解密篇 - 非对称加密算法 (RSA、DSA、ECC、DH)</a><br><a href="https://blog.csdn.net/justinzengTM/article/details/104154100" target="_blank" rel="noopener">证书链-证书校验</a><br><a href="https://zhuanlan.zhihu.com/p/30655259" target="_blank" rel="noopener">HTTPS 精读之 TLS 证书校验</a><br><a href="https://zhuanlan.zhihu.com/p/403704980" target="_blank" rel="noopener">数字签名和数字证书的原理解读</a><br><a href="https://flylib.com/books/en/1.2.1.137/1/" target="_blank" rel="noopener">Digital Certificates</a><br><a href="https://en.wikipedia.org/wiki/Chain_of_trust" target="_blank" rel="noopener">Chain of trust</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从整体上理解ssl干了什么事情，证书又起什么作用。只关注功能流程，不关注细节实现(•̀⌄•́)&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="技术杂谈" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="ssl" scheme="http://yoursite.com/tags/ssl/"/>
    
      <category term="openssl" scheme="http://yoursite.com/tags/openssl/"/>
    
  </entry>
  
  <entry>
    <title>投资理财学习</title>
    <link href="http://yoursite.com/2022/06/13/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2022/06/13/投资理财学习/</id>
    <published>2022-06-13T13:22:32.000Z</published>
    <updated>2023-02-08T12:45:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="专题研究"><a class="header-anchor" href="#专题研究"></a>专题研究</h3><ol><li>通货膨胀产生的原因：</li><li>基金是什么</li><li>基金如何保障安全</li><li>疫情是怎么影响全国GDP大波动的，为何有这样类型的波动。<a href="http://www.gov.cn/shuju/hgjjyxqk/detail.html?q=0" target="_blank" rel="noopener">GDP数据统计</a></li><li>人口增长曲线以及对经济和社会的影响</li></ol><h3 id="基金投资"><a class="header-anchor" href="#基金投资"></a>基金投资</h3><p>通货膨胀产生的原因：</p><p>基金是什么：</p><p>基金安全如何保障：</p><p>基金的分类：</p><p>货币基金筛选：</p><ol><li>七日年化</li><li>规模：20亿-2000亿</li><li>成立时间三年以上</li><li>费用成本越低越好(管理费，申购费，赎回费) &lt; 0.7%</li></ol><p>债券基金：</p><ol><li>规模：5亿-100亿</li><li>成立时间三年以上</li><li>基金评级五星，上证，招商。</li><li>三年以上的收益情况，越优越好</li><li>费用成本越低越好 &lt; 0.7%</li></ol><p>混合基金：</p><ol><li>规模：5亿-100亿</li><li>成立时间三年以上</li><li>基金评级五星，上证，招商。</li><li>三年以上的收益情况，越优越好</li><li>费用成本越低越好</li><li>基金经理<ol><li>从业时间</li><li>从业收益，至少跑赢大盘</li><li>基金经理更好频率(换人了就要考虑是不是卖了)</li></ol></li><li>资产配置，股票买的越多，风险越高</li></ol><p>股票基金：</p><ol><li>规模：5亿-100亿</li><li>成立时间三年以上</li><li>基金评级五星，上证，招商。</li><li>三年以上的收益情况，越优越好</li><li>费用成本越低越好</li><li>基金经理<ol><li>从业时间</li><li>从业收益，至少跑赢大盘</li><li>基金经理更好频率(换人了就要考虑是不是卖了)</li></ol></li></ol><p>被动型基金(指数基金):<br>优势：<br>1. 管理费用低<br>2. 不依赖基金经理<br>3. 指数=国运（指数都是包含的股市中规模最大的，最优的部分股票）</p><p>越靠前的企业组成的指数基金，收益越稳定，起伏越小，当然收益峰值不如中小型的多<br>指数指标：</p><ol><li>市盈率(PE)=股票价格/每股净利率<ol><li>举例：一个奶茶店每年赚5w，有人看中了这个奶茶店，出100w买，则需要20年回本。PE=20年。PE越小越容易赚钱</li><li>优点：简单有效</li><li>缺点：无法估计公司潜力</li></ol></li><li>市净率(PB)=总市值/净资产<ol><li>举例：奶茶店家具店面值20w，你花了80w买，PB=80/20=4，PB也是越低越好</li><li>净资产=总资产-负债</li><li>对于有较多实体的经济估值较准</li></ol></li><li>指数温度计:(PE+PB)/2</li></ol><p>指数基金分类：<br>宽指数基金<br>窄指数基金<br>被动型基金(完全复制)<br>增强指数型(部分复制)</p><p>指数基金选取：</p><ol><li>跟踪误差率(跟踪了多少，以及收益是否高于完全被动型)，产生了多少超额收益</li><li>基金规模：10-以上，越大越好</li><li>购买费率</li><li>成立时间：3年以上</li><li>购买时机，根据指数指标和行业，基金类型及经理人等判断。</li></ol><p>定投策略：</p><ol><li>长期坚持</li><li>不要受主观情绪影响</li><li>红利再投资</li></ol><p>定投额度：<br>普通定投：固定金额<br>AI定投方式：价格越低投入越多<br>个人感觉的定投方式：1000*温度指数(低于整个时期的%)。这样越低投资越多，越高投资越少，避免追涨杀跌。买入时机：温度指数&lt;40%，卖出时机&gt;60%</p><p>风险承受能力计算：(100-当前年龄)/100<br>每月投入金额：(每月存量+每月增量)*风险承受能力<br>每月存量（可用于投资的积蓄）：(总积蓄-应急-保险-日常)/定投时间<br>每月增量：(每月收入-支出)/定投时间<br>按照风险大小，分为风险投资和目标投资</p><p>不需要等到温度很高的时候再卖出，50%以及是小牛市了。<br>可以把高温的基金卖出，买温度低的基金</p><p>资产配置：<br>货币基金：日常资金<br>债券基金：低风险<br>股票基金：高风险<br>比例动态平衡：一年调整一下投入资金，原则就是平衡风险。涨得厉害的卖点买不景气有前景的<br>个人觉得的配置(除去保险和日常)：3(应急):4(低风险):3(高风险)<br>后面熟悉了，可以调整到3:3:4</p><p>投资基金误区：</p><ol><li>图便宜，买便宜的基金，买新基金</li><li>频繁买卖</li><li>只买不卖(根据计划和目标买卖基金)</li><li>盲目追热点(关注长期业绩)</li><li>投资过于分散(一般最多10个,一般1个货币基金，2-3个债券，2-3个股票/混合，2-3个指数)</li><li>热衷打新基金<ol><li>打新基金时，了解费用</li><li>不能保证打中新股票</li><li>申购时间短，要及时购买</li><li>也要长期持有，至少1年以上</li></ol></li></ol><p>基金选择：</p><ol><li>优质基金公司<ol><li>基金公司规模超过2000亿的公司</li><li>经理数量越多越好，40以上</li><li>天天基金上可以进行基金排名</li></ol></li><li>优质基金经理(增强型基金)<ol><li>从业年限，建议5-10年</li><li>管理当前基金超过3年</li><li>擅长领域和当前领域符合</li></ol></li><li>找准投资方向<ol><li>没啥好方法。。。</li></ol></li></ol><h3 id="股票投资"><a class="header-anchor" href="#股票投资"></a>股票投资</h3><p>股票赚钱方式：</p><ol><li>股票分红(看公司是否愿意分红)</li><li>低买高卖</li></ol><p>股票分类：</p><ol><li>蓝概股：市值规模大的公司</li><li>白马股：市值规模中等，但是蒸蒸日上的公司</li><li>黑马股：默默无闻，但是有个时机突然崛起</li><li>妖股：没有实业支撑的暴涨暴跌</li></ol><p>股票涨跌停：</p><ol><li>主板上市第一天：±44%，后续±10%</li><li>创业板：上市前五天无限制，后续±20%</li></ol><p>股票术语：</p><ol><li>抱团股：买一个系列的股票</li><li>踏空：没有抓到股价低的买入时机</li><li>建仓：第一次买入行为</li><li>仓位：现阶段买入多少/计划多少钱买入股票</li><li>割肉：止损</li><li>利好/利空：促使股票上涨/下跌消息</li></ol><p>股票投资：</p><ol><li>选择好行业</li><li>找出好公司</li><li>等待好价格</li></ol><p>公司分类(主要营业额&gt;50%)：</p><ol><li>金融类</li><li>消费类</li><li>成长类<ol><li>和经济周期关联不大，主要受技术发展的新兴类行业</li></ol></li><li>周期类<ol><li>和经济周期关联度大</li></ol></li></ol><p>行业优质赛道：</p><ol><li>第一梯队<ol><li>金融：<ol><li>银行</li><li>保险2</li></ol></li><li>消费：<ol><li>食品饮料</li><li>医疗生物</li><li>家用电器</li><li>轻工制造</li><li>汽车</li><li>农林牧渔</li><li>美容护理</li></ol></li><li>成长：<ol><li>电子</li><li>传媒</li><li>计算机</li><li>国防军工</li></ol></li><li>周期：<ol><li>电力设备</li><li>基础化工</li><li>交通运输</li></ol></li></ol></li><li>第二梯队<ol><li>金融：<ol><li>证券2</li><li>多元金融</li></ol></li><li>消费：<ol><li>社会服务</li><li>纺织服饰</li><li>商贸零售</li></ol></li><li>成长：<ol><li>通信</li></ol></li><li>周期(剩下的都是，太多不写了)：</li></ol></li></ol><p>好公司选择标准：</p><ol><li>ROE<ol><li>ROE(净资产收益率)：净利润/净资产*100%</li><li>ROE看长期稳定，市场决定了ROE不可能一直很高</li><li>3年以上：0-10%(差)，10-15%(中)，15-20%(良)，20-35%(优)</li></ol></li><li>净现比(金融类不适合)<ol><li>定义：(经营现金流入-经营现金流出)/净利润*100%，查看时选择三年以上</li><li>公司净现比长期小于10%谨慎投资，证明长期入不敷出</li><li>净现比在10-70%，证明是很普通的公司</li><li>净现比在70-100%，证明比较健康的公司</li><li>净现比&gt;100%,证明很优秀</li></ol></li><li>资产负债率<ol><li>定义：负债总额/资产总额*100%</li><li>资产总额=自己的钱+借的钱</li><li>分类：有息负债和无息负债</li><li>负债率正常水平：<ol><li>金融类：80%</li><li>其他类型：有息负债率在0-32%</li></ol></li></ol></li><li>总市值<ol><li>定义：股价*股票数量</li><li>总市值=流通股市值+限售股市值</li><li>解禁：限售股票开放售卖。大规模股票解禁一般为利空消息</li><li>股票大小：0-100亿(小盘股)，100-500亿(中盘股)，500亿以上(大盘股)</li><li>小盘股容易被操控，出现异常涨跌，甚至暴跌。大盘股不容易被操控</li><li>建议选择300亿以上的盘进行投资</li></ol></li></ol><p>股票估值：</p><ol><li>内在价值：和公司经营嘻嘻相关，是公司自身价值体现</li><li>市场价格：是人们对公司的期望的价格，即人们觉得他值多少</li><li>市场价格&lt;内在价值，可买入，反之卖出</li><li>估值方法： 相对估值法(就是按照百分比进行计算，而不是绝对值)，估值公司一般超过十年，至少上市三年</li><li>PE估值法：<ol><li>市盈率(PE)：公司股价/每股收益=公司总市值/总净利润</li><li>静态市盈率/动态市盈率/滚动市盈率：区别在于分母的利润的取值不同：最新年报总净利润/对下一年预测的总利润值/最近四个季度的总利润值。滚动市盈率是最佳选择</li><li>PE-TTM扣非：TTM扣非(扣非滚动净利润)，去除非常规获取的利润或者亏损：比如政府补贴，变卖房产等。此方法只适合消费类行业</li><li>估值分位点(十年期，或者上市至今超过三年以上)：当前股票价格处于历史阶段的什么位置。40%以下可以认为被低估，60%以上认为被高估</li></ol></li><li>PS估值法：<ol><li>市销率(PS)=公司股价/每股销售额=公司总市值/主营业务收入， 营业收入=主营业务收入+其他业务收入+营业外收入，市销率越低越好(收入越高，值越小)</li><li>静态/动态/滚动市销率。</li><li>在PE-TTM扣非为负的情况下，或者非消费行业，可以使用PS估值法</li></ol></li><li>如何使用指标：<ol><li>可以纵向查看一个公司的各个指标是否值得投资，进行估值</li><li>查看估值分位点等指标看当下时机是否合适</li><li>横向对比其他公司(主营业务相同)，是否有更好的公司。横向对比时消费类可以用PE-TTM，成长类可以用PS-TTM</li></ol></li></ol><p>买卖黄金法则：</p><ol><li>对公司进行估值，并且计算估值分位点，分位点在40%以下时可以购买，计算出一个合理的股票价格</li><li>进行分仓购买，多次购买一只股票，分位点越低，可以购入越多<ol><li>可以设置建仓价(假设5块)，加仓价(5*(1-10%)=4.5, 又跌了10%)，重仓价(5*(1-20%)=4)</li><li>设计不同阶段的数量，建议使用每阶段总投资等的方式，比如每个阶段都投入2000元，自然股价越低，购买股票数量越多</li></ol></li><li>卖股票的时机：<ol><li>公司基本面恶化</li><li>股票到了目标价格</li><li>有更好的投资机会</li></ol></li><li>买入卖出时都要用最新的估值</li><li>股票配比：<ol><li>分散资金，买入多个公司股票，一般4个以上就足以分散风险，但也别太过分散(4-6只)</li><li>公司的行业要分散，才能避免行业波动带来的风险</li></ol></li></ol><p>股票打新：</p><ol><li>股票打新<ol><li>推荐A股打新</li><li>新股上市95%都是上涨</li><li>代价低，中签后才交钱</li><li>新股申购没有佣金，过户费税费等费用</li><li>打新需要资格，而且深沪不通用，具体资格打新时了解</li></ol></li><li>可转债打新<ol><li>可转债就是日后会转换为该公司股票的债券</li><li>没有门槛(2022.6.18日后新规有限制)</li><li>顶格申购，也就是有多少资格申购多少，一般概率不会全部都中，就算没有中，也可以放弃，只要一个月内放弃不超过3次，就不会拉黑</li><li>上市当天卖出，后面大概率会跌破申购价，卖出价可以等于申购价，因为开盘价格大于卖出价格，会以开盘价卖出。当然也可以持有，或者转换成股票</li></ol></li><li>港股票打新<ol><li>中签率高。A股中签率0.02%，港股：20%-40%</li><li>不需要持仓资格</li><li>收益高，风险低</li><li>避开坑的行业。有可能上市就跌</li></ol></li></ol><p>股票投资的风险和误区：</p><ol><li>风险：<ol><li>风险是导致下跌的因素</li><li>系统性风险(整体社会状况导致的风险)，影响整个市场：<ol><li>政策风险</li><li>周期风险</li><li>利率风险</li><li>购买力风险</li><li>汇率风险</li></ol></li><li>非系统性风险(指企业自身经营等发生的风险)<ol><li>个股风险</li><li>行业风险</li></ol></li><li>规避风险方式<ol><li>系统性风险，可通过资产配置来规避，减少股票资金配比</li><li>非系统性风险，选择优质行业，合理的评估企业健康状态，以及分散投资</li></ol></li></ol></li><li>误区：<ol><li>损失厌恶，亏了想赚回来，因此迟迟不卖掉手里的股票。赚了还想赚，因此不舍得卖。解决方式：集中注意力在系统分析上。</li><li>羊群效应，盲目从众。解决方式：提高自己的分析能力</li><li>偏听偏信，对自己持有的股票有乐观态度。解决方式：客观的从数据上分析，不要管自己是否购买该股票</li></ol></li><li>投资计划：<ol><li>初步选股，通过自己的学习方式选取自己觉得优秀的股票名单，每月筛选一次</li><li>根据行业对所选的股票进行分类，找出2-3只估值更低的股票进行更细致的研究</li><li>细致研究后，选择出不同行业的几只股票</li><li>列出买入原因</li><li>通过资产配置进行有节奏的建仓</li><li>跟踪自己买入股票的相关信息，和对股票基本面的影响，是否还支持自己继续持有或买入。</li></ol></li></ol><p>股票高阶：</p><ol><li>什么时候进场</li><li>选择什么行业</li><li>选择哪只股票</li><li>什么时候卖出</li></ol><p>分清熊市牛市：</p><ol><li>M0=流动现金，M1=M0+存在银行的活期，M2=M1+存在银行的定期</li><li>M1增速-M2增速&gt;0代表居民取存款消费(大概率牛市将来)， &lt;0刚好相反(大概率熊市将来)。</li><li>A股的一个特色：牛市短，熊市长</li><li>M1增速-M2增速差在±6%差距，是熊牛市的分割点</li></ol><p>行业选择：</p><ol><li>优先选择国家十四五提倡的行业</li><li>从行业中细分每个行业的产业链条，选择比较赚钱的一环进行投资</li></ol><p>指数基金投资：<br><a href="https://zhuanlan.zhihu.com/p/138162032" target="_blank" rel="noopener">博格公式</a>：投资收益率=投资初期股息率+市盈率平均年变化率+利润平均年变化率<br>适用范围：绝大多数宽基指数，比如上证50、沪深300、中证100、上证红利、中证红利等。因为这些指数股息率稳定、市盈率波动较小、利润增长预测性比较强。行业宽基指数也可参考，但行业指数受政策影响较大。小盘指数则不适用<br>博格公式预测：未来最好情况：市盈率达到80%，中等：市盈率50%，差：市盈率的20%。如果最差的情况你的收益率是负数，则不建议投资</p><p>主动型基金投资方法：<br>沪深300都跑不过的垃圾就不要选了。<br>北斗七星：<br>收益率：历史收益率越高越好(也要看风险承受能力)<br>基金规模：5-100亿<br>成立时间：3年以上<br>重仓股：看看重仓股是否有问题<br>基金经理：从业时间&gt;3年，历史业绩较好，专业对口<br>评级：较为权威的机构对基金评级，评级一般选5星<br>基金排名：选择排名前25%的基金，重点关注<br>夏普比率(越大越好)：(预期收益率-无风险收益率)/投资组合标准差<br>基金风险：最大回撤(基金最高值-最低值)</p><p>基金规模：<br>小盘：&lt;5亿<br>中盘：5-20亿<br>大盘：&gt;20亿</p><p>工具：<br>理杏仁：各种基金股票数据</p><p>REIT:不动产债券化</p><p>第三课<br>高级基金进阶：</p><ol><li>债券基金： 5-8%<ol><li>分纯债券和股票债券</li><li>买入时机：十年国债收益率&gt; 3.5%，卖出时机：十年国债收益率&lt;2.5%</li></ol></li><li>红利指数基金(能赚钱，爱分红的公司集结) 10%<ol><li>可以通过指数温度来进行基金购买</li></ol></li><li>行业指数(只包含某个行业的指数) 20%<ol><li>看行业历史收益率选择好的行业(消费和医药)，只选择&gt;10%</li><li>看行业后续是否有很大需求，可以考虑直接剔除周期性行业</li><li>行业指数最好使用博格公式来进行估值，指数温度不太适合窄基金</li></ol></li><li>投资风险(主动投资基金)<ol><li>投资风格箱<ol><li>按照盘的大小来判断，盘越大，投资风险越小</li><li>按照类型来判断，风险：成长型&gt;平衡型&gt;价值型</li><li>按照大中小盘，和基金类型形成九宫格的投资风格箱，</li></ol></li><li>按照投资风格箱，进行投资份额分配</li><li>夏普比率评价主动基金的收益</li><li>最大回撤评估基金风险</li></ol></li><li>RETIs投资(不动产基金投资)<ol><li>将不动产证券化(去除商用建筑和民用住宅)</li><li>风险基本处于中高风险</li><li>基金有强制分红，分红在90%以上</li><li>购买基金的选择方式<ol><li>现金分派比例越高越好</li><li>战略投资者占比越高越好</li><li>需要开通债券交易账号</li></ol></li></ol></li><li>QDII基金(海外基金)<ol><li>购买方式和选股方式本质和国内相似</li><li>纳斯达克和国内创业板相似，主要是高科技新兴公司</li><li>风险点：<ol><li>汇率变动</li><li>管理费用较高</li><li>买入和赎回周期更长</li></ol></li></ol></li><li>震荡市场<ol><li>网格交易法，下跌买入(买入阶梯：(第一手买入-&gt;预估的最低买入价)/阶梯数)，上涨卖出(卖出阶梯相同)<ol><li>失效的情况<ol><li>长时间上涨，自己基金都卖完了还在涨</li><li>下跌时间长，全买入还在跌</li><li>震荡过小</li></ol></li><li>适合震荡市场短期赚钱</li><li>选择波动比较大的基金</li><li>适合场内基金，手续费低</li><li>每次买入和卖出都记录表格</li></ol></li></ol></li><li>熊市投资<ol><li>金字塔买入策略(市场下跌X%，买入增加Y%)</li><li>股市温度表，可以初步预测未来的基金走向</li><li>如果买入后就上涨了，就没有必要继续买入，守着等赚钱合适，就卖了。</li><li>股市温度表代表上涨可能性大，下跌X可以设置小一些，反之则大</li></ol></li><li>基金风险配置<ol><li>适合各种市场环境</li><li>按照不同的风险进行债券基金和股票基金</li><li>债券基金和股票基金很少同涨同跌</li><li>适合买股票基金：A股市场平均市盈率-10年国债收益率倒数 &lt; 0</li><li>适合买债券基金：与第四点相反&gt;0</li><li>可以参考股债平衡温度计</li><li>示例：<ol><li>留好应急资金</li><li>查看温度，分配资金购买基金</li><li>留心温度，调整比例</li></ol></li></ol></li><li>投资心态<ol><li>降低投资预期，不要想着赚快钱，不要用赌博心态投资<ol><li>不要用短期使用的资金投资</li><li>不要借钱投资</li><li>不要有明确用途的钱投资</li></ol></li><li>风险控制<ol><li>系统风险无可避免，合理按照股债平衡合理分配</li><li>局部风险，可以通过分散投资消除</li></ol></li><li>人性弱点<ol><li>贪婪和恐惧，避免追涨杀跌</li><li>定期调整基金比例，但也要避免频繁交易</li></ol></li></ol></li></ol><p>从0开始投资：</p><ol><li>分配自己的资金：<ol><li>日常使用(至少3个月)</li><li>应急保险资金(包含购买保险，应急资金)</li><li>目的资金(旅游，买车等)</li><li>投资资金(这部分用于风险投资)</li></ol></li><li>将不同类型的资金进行分类投资：<ol><li>日常使用可以放到货币基金中(类似余额宝一类)</li><li>应急保险资金(应急资金，可以购买国债，黄金或银行定期等)</li><li>目的资金(可能需要平时积攒，看情况放货币基金中，或者定投风险较低的基金(债券占比较高))</li><li>投资资金(可进行风险投资)</li></ol></li><li>对投资资金进行评估<ol><li>投资资金总量明确</li><li>自己能承受风险明确(即可以损失多少钱)</li><li>期望收益明确，通常等同于承受风险值</li><li>根据风险承受能力，划分资金，通常资金比例为4:3:3(低风险，中风险，高风险)</li></ol></li><li>为不同风险资金选择基金<ol><li>每个风险选择2-3个基金即可，可选择指数基金，根据风险承受能力选择指数基金的风险，个人通常认为5%-10%, 20%-30%, 30-50%左右为低，中，高风险</li><li>设定投资目标，比如在盈利多少的情况下退场。</li><li>比较选出优秀基金，比如北斗七星，博格公式等</li><li>选择投资方式，比如定投，还是金字塔等，</li><li>选择入场时机，比如低温或好的时机开始入场</li></ol></li><li>保持投资态度<ol><li>避免追涨杀跌，避免频繁交易</li><li>时常关注，注意股市温度表，及时进行风险比例调整(股债平衡)</li><li>避免赌博心态，有耐心等待出手机会。</li><li>合理止损，如果有更好的投资机会，及时卖出</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;专题研究&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#专题研究&quot;&gt;&lt;/a&gt;专题研究&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通货膨胀产生的原因：&lt;/li&gt;
&lt;li&gt;基金是什么&lt;/li&gt;
&lt;li&gt;基金如何保障安全&lt;/li&gt;
&lt;li&gt;疫情是怎么影响全国GDP
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GoF设计模式</title>
    <link href="http://yoursite.com/2022/05/27/GoF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2022/05/27/GoF设计模式/</id>
    <published>2022-05-27T09:14:54.000Z</published>
    <updated>2022-06-07T03:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>GoF的《设计模式》阅读以及基于golang的实现(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em>意指都在快速全面的解决问题，寻找和实现一个最为合适的模式</em></p><a id="more"></a><p>设计模式是做什么的？它的基本原理和意图是什么？它解决的是什么样的特定设计问题？</p><h1>基础</h1><p>四个基本要素：</p><ol><li>模式名称 （pattern name）<br>一个助记名，它用一两个词来描述模式的问题、解决方案和效果。命名一个新的模式增加了我们的设计词汇。设计模式允许我们在较高的抽象层次上进行设计。基于一个模式词汇表，我们自己以及同事之间就可以讨论模式并在编写文档时使用它们。模式名可以帮助我们思考，便于我们与其他人交流设计思想及设计结果。找到恰当的模式名也是我们设计模式编目工作的难点之一。</li><li>问题(problem)<br>描述了应该在何时使用模式。它解释了设计问题和问题存在的前因后果，它可能描述了特定的设计问题，如怎样用对象表示算法等。也可能描述了导致不灵活设计的类或对象结构。有时候，问题部分会包括使用模式必须满足的一系列先决条件。</li><li>解决方案 (solution)<br>描述了设计的组成成分，它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。</li><li>效果(consequences)<br>描述了模式应用的效果及使用模式应权衡的问题。尽管我们描述设计决策时，并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。</li></ol><p>设计模式怎样解决设计问题？<br>寻找合适的对象<br>决定对象的粒度<br>指定对象接口<br>描述对象的实现：确定你的系统时针对接口编程，而不是针对实现。<br>运用复用机制，尽量避免重复代码。<br>关联运行时刻和编译时刻的结构<br>设计应支持变化，拓展和解耦<br>怎样选择设计模式<br>1. 设计模式解决什么样的问题<br>2. 浏览已知模式的设计意图<br>3. 研究模式怎么相互关联<br>4. 检查哪些是需要拓展，需要解耦<br>怎样使用模式<br>1. 大致浏览模式，选择合适你问题的部分<br>2. 选择模式，并放在合适的位置，明确主要部分和协助部分<br>3. 参看示例代码，并明确其上下文意义<br>4. 将模式尝试嵌入到你的实际问题中</p><p>2.3</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GoF的《设计模式》阅读以及基于golang的实现(•̀⌄•́)&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;意指都在快速全面的解决问题，寻找和实现一个最为合适的模式&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Go101》读书笔记</title>
    <link href="http://yoursite.com/2022/01/07/%E3%80%8AGo101%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/01/07/《Go101》读书笔记/</id>
    <published>2022-01-07T09:16:17.000Z</published>
    <updated>2022-03-24T02:29:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>姜大佬推荐的一本较为深入理解go细节的书，作为golang学习进阶。(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em>以下内容都是根据书中的章节目录，并且根据自己的缺陷进行记录的。</em><br><em>如果有兴趣，推荐先阅读原著，再看笔记。</em></p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>go语言的查漏补缺。<a href="https://gfw.go101.org/article/101.html" target="_blank" rel="noopener">在线阅读</a></p><h2 id="Go编程入门"><a class="header-anchor" href="#Go编程入门"></a>Go编程入门</h2><h3 id="Go工具链"><a class="header-anchor" href="#Go工具链"></a>Go工具链</h3><p>问题1： 书中说: <em>比如，目前Go不支持任意类型的不变量。这导致很多标准库中一些希望永不被更改的值目前被声明为变量。这是Go程序中的一个潜在安全隐患</em> const 不算常量？</p><h4 id="go-vet"><a class="header-anchor" href="#go-vet"></a>go vet</h4><p><code>go vet</code>可以用来检测可能出现的逻辑错误，使用方法也很简单：</p><ol><li>检测单个文件：<br><code>go vet a.go</code></li><li>检测文件夹：<br><code>go vet ./test/</code>或者可以增加tag<code>go vet -tags=&quot;a&quot; ./test/</code><br><code>go vet</code>检测文件夹的时候，会自动根据文件夹下的go文件去查找对应的依赖关系，并给出相应的检测结果。</li></ol><h3 id="关键字和标识符"><a class="header-anchor" href="#关键字和标识符"></a>关键字和标识符</h3><p>有趣的是，golang中标识符可以是<em>一个以Unicode字母或者_开头并且完全由Unicode字母和Unicode数字组成的单词</em> 这就意味着下面的定义也是合法的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> _status <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> memStat <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> π <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> 一个类型 <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> 변수 <span class="keyword">int</span> </span><br><span class="line"><span class="keyword">var</span> エラー <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>而且一个由大写字符开头的标识符，为导出字符。而大写的定义是<a href="https://www.fileformat.info/info/unicode/category/Lu/list.htm" target="_blank" rel="noopener">Unicode中的大写</a></p><h3 id="常量和变量"><a class="header-anchor" href="#常量和变量"></a>常量和变量</h3><p>常量定义中，<code>=</code>号并不代表赋值，而有点像绑定，类似于c中的<code>#define</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以理解为#define的方式，实际使用的时候，替换为1</span></span><br><span class="line"><span class="keyword">const</span> one = <span class="number">1</span></span><br><span class="line"><span class="comment">//同上，实际使用的时候，替换为int(1)</span></span><br><span class="line"><span class="keyword">const</span> one <span class="keyword">int</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>若干包级变量在声明时刻的依赖关系将影响它们的初始化顺序<br>下面这个例子中的声明的变量的初始化顺序为<code>y = 5、c = y、b = c+1、a = b+1、x = a+1</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y = a+<span class="number">1</span>, <span class="number">5</span>         <span class="comment">// 8 5</span></span><br><span class="line"><span class="keyword">var</span> a, b, c = b+<span class="number">1</span>, c+<span class="number">1</span>, y <span class="comment">// 7 6 5</span></span><br></pre></td></tr></table></figure><p>包级变量在初始化的时候不能相互依赖。比如，下面这个变量声明语句编译不通过。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y = y, x</span><br></pre></td></tr></table></figure><p>变量可被寻址，常量不行。<br>常量的类型转换，不允许溢出，而变量则允许。</p><p>常量和变量的类型推断方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> n = <span class="keyword">uint</span>(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">uint</span>(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//推断为：var a = byte(int(1) &lt;&lt; n / 128)</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">byte</span> = <span class="number">1</span> &lt;&lt; n / <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//推断为：var b = byte(1) &lt;&lt; m / 128</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">byte</span> = <span class="number">1</span> &lt;&lt; m / <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(a, b) <span class="comment">// 2 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a class="header-anchor" href="#函数"></a>函数</h3><p><a href="https://books.studygolang.com/the-way-to-go_ZH_CN/06.5.html" target="_blank" rel="noopener">内置函数</a></p><p><code>switch</code>中，执行时是依次比较每个<code>case</code></p><h3 id="defer"><a class="header-anchor" href="#defer"></a>defer</h3><p>当一个函数调用被延迟后，它不会立即被执行。它将被推入由当前协程维护的一个延迟调用堆栈。 当一个函数调用（可能是也可能不是一个延迟调用）返回并进入它的退出阶段后，所有在此函数调用中已经被推入的延迟调用将被按照它们被推入堆栈的顺序逆序执行。<br>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"The third line."</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"The second line."</span>)</span><br><span class="line">fmt.Println(<span class="string">"The first line."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The first line.</span><br><span class="line">The second line.</span><br><span class="line">The third line.</span><br></pre></td></tr></table></figure><p>defer传参问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"a:"</span>, i) <span class="comment">//执行for的时候，就传入i的参数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//执行函数调用时再传入i的参数</span></span><br><span class="line">fmt.Println(<span class="string">"b:"</span>, i)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a: 2</span><br><span class="line">a: 1</span><br><span class="line">a: 0</span><br><span class="line"></span><br><span class="line">b: 3</span><br><span class="line">b: 3</span><br><span class="line">b: 3</span><br></pre></td></tr></table></figure><p>下面这个例子，则会输出<code>false</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f()</span><br><span class="line">f = <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个延迟调用的实参也是在此调用被推入延迟调用堆栈之前估值的</p><h3 id="panic和recover"><a class="header-anchor" href="#panic和recover"></a>panic和recover</h3><p>一旦一个函数调用产生一个<code>panic</code>，此函数调用将立即进入它的退出阶段，执行<code>defer</code>所定义的延迟函数，这里所有定义的延迟函数都将被执行(逆序)。<br>通过在<code>defer</code>中调用内置函数<code>recover</code>，当前协程中的一个<code>panic</code>可以被消除，从而使得当前协程重新进入正常状况。<br>在一个处于<code>panic</code>状况的协程退出之前，其中的<code>panic</code>不会蔓延到其它协程。 如果一个协程在<code>panic</code>状况下退出，它将使整个程序崩溃。<br>一个协程调用或者延迟调用的实参是在此调用发生时被估值的。更具体地说：</p><ul><li>对于一个延迟函数调用，它的实参是在此调用被推入延迟调用堆栈的时候被估值的。</li><li>对于一个协程调用，它的实参是在此协程被创建的时候估值的。</li></ul><p><strong>一些致命性错误不属于<code>panic</code></strong><br>对于官方标准编译器来说，很多致命性错误（比如堆栈溢出和内存不足）不能被恢复。它们一旦产生，程序将崩溃。</p><h3 id="类型"><a class="header-anchor" href="#类型"></a>类型</h3><p>类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type (</span><br><span class="line">MyInt int</span><br><span class="line">Age   int</span><br><span class="line">Text  string</span><br><span class="line">)</span><br><span class="line">type IntPtr *intgo</span><br></pre></td></tr></table></figure><p>类型定义的一些特点：</p><ol><li>一个新定义的类型和它的源类型为两个不同的类型。</li><li>在两个不同的类型定义中的定义的两个类型肯定为两个不同的类型。</li><li>一个新定义的类型和它的源类型的底层类型（将在下面介绍）一致并且它们的值可以相互显式转换。</li><li>类型定义可以出现在函数体内。</li></ol><p>类型别名声明:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">Name = <span class="keyword">string</span></span><br><span class="line">Age  = <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> table = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> Table = <span class="keyword">map</span>[Name]Age</span><br></pre></td></tr></table></figure><p>类型别名，顾名思义，就是某个类型的另外一个名字。</p><h2 id="Go类型系统"><a class="header-anchor" href="#Go类型系统"></a>Go类型系统</h2><h3 id="指针"><a class="header-anchor" href="#指针"></a>指针</h3><ul><li>一个指针类型的值不能被随意转换为另一个指针类型</li><li>一个指针值不能和其它任一指针类型的值进行比较</li><li>指针值不能进行数值计算，比如有指针<code>p</code>，进行<code>p++</code></li><li><code>unsafe.Pointer</code>可以打破Go对指针的限制<br><strong>在赋值中，底层间接值部将不会被复制</strong><br>意味着所有的间接引用值类型，都共用一个内存值，包括string。由于string的内存是只读状态，因此上面的描述也是正确的。</li></ul><table><thead><tr><th>直接存值</th><th>间接存值</th></tr></thead><tbody><tr><td>布尔类型</td><td>切片类型</td></tr><tr><td>各种数值类型</td><td>映射类型</td></tr><tr><td>指针类型</td><td>通道类型</td></tr><tr><td>非类型安全指针类型</td><td>函数类型</td></tr><tr><td>结构体类型</td><td>接口类型</td></tr><tr><td>数组类型</td><td>字符串类型</td></tr></tbody></table><p>使用内置<code>copy</code>函数来复制切片元素，复制的两个切片类型可以不同，但是底层数据结构必须相同。</p><h3 id="map"><a class="header-anchor" href="#map"></a>map</h3><p>在map的遍历中，单协程是可以对map进行增删改查的，但是注意：</p><ol><li>map遍历是随机的</li><li>在遍历过程中，没有遍历到的目录被删除，则后续也不会被遍历出来</li><li>在遍历过程中，增加新条目，则后续不保证会被遍历出来</li><li>遍历时，会对直接值进行一次拷贝，用于赋值循环变量。比如数组遍历过程中修改原始数组值，是不会在遍历的变量中体现修改。但是切片就会体现。</li><li>遍历中，循环变量也是一个元素备份，对循环变量的修改，也不会体现到原始值中。</li><li>所有被遍历的键值对将被赋值给<strong>同一对</strong>循环变量实例</li></ol><p>类型<code>struct{}</code>的尺寸为零</p><h3 id="string"><a class="header-anchor" href="#string"></a>string:</h3><p>字符串赋值，在底层享用的是同一份数据<br>字符串和切片(字节切片或者码点切片)之间的转换，是需要进行深复制的，原因在于切片是可以被修改的，字符串则不行。<br>用<code>for range</code>遍历字符串的时候，取出的值是一个<code>rune</code>类型的值，但是<code>len(s)</code>得到的却是字符串的字节数</p><p>函数也可以认为是一个值，但是函数是不可比较类型<br>函数值赋值时，内置函数和init不可被用作函数值</p><h3 id="接口"><a class="header-anchor" href="#接口"></a>接口</h3><p>因为任何方法集都是一个空方法集的超集，所以任何类型都实现了任何空接口类型(<code>interface{}</code>)。<br>在Go中，如果类型<code>T</code>实现了一个接口类型<code>I</code>，则类型<code>T</code>的值都可以隐式转换到类型<code>I</code>。 换句话说，类型<code>T</code>的值可以赋给类型<code>I</code>的可修改值。 当一个<code>T</code>值被转换到类型<code>I</code>（或者赋给一个<code>I</code>值）的时候:</p><ul><li>如果类型<code>T</code>是一个非接口类型，则此<code>T</code>值的一个复制将被包裹在结果（或者目标）<code>I</code>值中。 此操作的时间复杂度为<code>O(n)</code>，其中n为<code>T</code>值的尺寸。</li><li>如果类型<code>T</code>也为一个接口类型，则此<code>T</code>值中当前包裹的（非接口）值将被复制一份到结果（或者目标）<code>I</code>值中。 官方标准编译器为此操作做了优化，使得此操作的时间复杂度为<code>O(1)</code>，而不是<code>O(n)</code>。<br>非接口类型和接口类型会在go运行时构建一个全局关系列表，一个非接口值内部只会存储一个指向该列表的一个条目。<br>非接口类型和接口类型对，存在两个部分：</li><li>动态类型（即此非接口类型）的信息。(反射的关键)</li><li>一个方法表（切片类型），其中存储了所有此接口类型指定的并且为此非接口类型（动态类型）声明的方法。(多态的关键)<br>当非接口类型<code>T</code>的一个值<code>t</code>被包裹在接口类型<code>I</code>的一个接口值<code>i</code>中：当方法<code>i.m</code>被调用时，<code>i</code>存储的实现关系信息的方法表中的方法<code>t.m</code>将被找到并被调用</li></ul><h4 id="接口值的比较"><a class="header-anchor" href="#接口值的比较"></a>接口值的比较:</h4><ul><li>比较一个非接口值和接口值。（非接口值会被隐式转化为接口值，进而变为接口值比较）</li><li>比较两个接口值。</li></ul><p>两个接口值的比较结果只有在下面两种任一情况下才为true：</p><ol><li>这两个接口值都为nil接口值。</li><li>这两个接口值的动态类型相同、动态类型为可比较类型、并且动态值相等。</li></ol><p>一个<code>[]T</code>类型的值不能直接被转换为类型<code>[]I</code>，即使类型<code>T</code>实现了接口类型<code>I</code>。只能通过循环来进行转换。</p><h2 id="并发编程"><a class="header-anchor" href="#并发编程"></a>并发编程</h2><h3 id="协程"><a class="header-anchor" href="#协程"></a>协程</h3><p>协程生命周期：<br><img src="/2022/01/07/《Go101》读书笔记/%E5%8D%8F%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt><br>进一步的：<br><img src="/2022/01/07/《Go101》读书笔记/%E5%8D%8F%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E7%BB%86.png" alt></p><p>我们可以调用runtime.GOMAXPROCS函数来获取和设置逻辑处理器的数量。自从Go 1.5之后，默认初始逻辑处理器的数量和逻辑CPU的数量一致。 此新的默认设置在大多数情况下是最佳选择。但是对于某些文件操作十分频繁的程序，设置一个大于<code>runtime.NumCPU()</code>的<code>GOMAXPROCS</code>值可能是有好处的。</p><h3 id="通道"><a class="header-anchor" href="#通道"></a>通道</h3><p>通道类型是可比较类型。<code>len(ch)</code>查询通道长度，返回的是通道内还存在多少个未被接收的元素。同样也存在<code>cap(ch)</code><br>对通道的操作都是并发安全的：</p><ol><li><code>close(ch)</code></li><li><code>len(ch)</code></li><li><code>cap(ch)</code></li><li><code>ch &lt;- v</code></li><li><code>&lt;- ch</code></li></ol><table><thead><tr><th>操作</th><th>一个零值nil通道</th><th>一个非零值但已关闭的双向通道</th><th>一个非零值且尚未关闭的双向通道</th></tr></thead><tbody><tr><td>关闭</td><td>产生恐慌</td><td>产生恐慌</td><td>成功关闭©</td></tr><tr><td>发送数据</td><td>永久阻塞</td><td>产生恐慌</td><td>阻塞或者成功发送(B)</td></tr><tr><td>接收数据</td><td>永久阻塞</td><td>永不阻塞(D)</td><td>阻塞或者成功接收(A)</td></tr></tbody></table><p>关闭一个双向通道时，关闭前的接收协程依旧可以获取缓冲区的值(如果缓冲区没有值则是零值)，如果关闭时存在发送协程则会产生<code>panic</code>。关闭后的接收协程则会永久阻塞。可以通过通道接收的第二个返回值<code>true/false</code>判断接收协程是否正常接收数据，还是关闭后返回的零值</p><p>通道可以看做是一个由数据缓冲区，接收协程队列，发送协程队列组成。<br>我们可以得出如下的关于一个通道的内部的三个队列的各种事实：</p><ul><li>如果一个通道已经关闭了，则它的发送数据协程队列和接收数据协程队列肯定都为空，但是它的缓冲队列可能不为空。</li><li>在任何时刻，如果缓冲队列不为空，则接收数据协程队列必为空。</li><li>在任何时刻，如果缓冲队列未满，则发送数据协程队列必为空。</li><li>如果一个通道是缓冲的，则在任何时刻，它的发送数据协程队列和接收数据协程队列之一必为空。</li><li>如果一个通道是非缓冲的，则在任何时刻，一般说来，它的发送数据协程队列和接收数据协程队列之一必为空， 但是有一个例外：一个协程可能在一个select流程控制中同时被推入到此通道的发送数据协程队列和接收数据协程队列中。</li></ul><p>官方编译器，通道元素最大尺寸为<code>65535</code></p><p><code>for-range</code>循环控制流程也适用于通道。 此循环将不断地尝试从一个通道接收数据，直到此通道关闭并且它的缓冲队列为空为止。 和应用于数组/切片/映射的<code>for-range</code>语法不同，应用于通道的<code>for-range</code>语法中最多只能出现一个循环变量，此循环变量用来存储接收到的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> aChannel &#123;</span><br><span class="line"><span class="comment">// 使用v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的通道aChannel一定不能为一个单向发送通道。 如果它是一个nil零值，则此<code>for-range</code>循环将使当前协程永久阻塞。</p><h3 id="select-case"><a class="header-anchor" href="#select-case"></a>select-case</h3><p>一些特性：</p><ul><li><code>select</code>关键字和<code>{</code>之间不允许存在任何表达式和语句。</li><li><code>fallthrough</code>语句不能被使用.</li><li>每个<code>case</code>关键字后必须跟随一个通道接收数据操作或者一个通道发送数据操作。 通道接收数据操作可以做为源值出现在一条简单赋值语句中。 以后，一个<code>case</code>关键字后跟随的通道操作将被称为一个<code>case</code>操作。</li><li>所有的非阻塞<code>case</code>操作中将有一个被随机选择执行（而不是按照从上到下的顺序），然后执行此操作对应的<code>case</code>分支代码块。</li><li>在所有的<code>case</code>操作均为阻塞的情况下，如果<code>default</code>分支存在，则<code>default</code>分支代码块将得到执行； 否则，当前协程将被推入所有阻塞操作中相关的通道的发送数据协程队列或者接收数据协程队列中，并进入阻塞状态。</li></ul><p>一个非阻塞的发送和接收：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line">trySend := <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- v:</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// 如果c的缓冲已满，则执行默认分支。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tryReceive := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v := &lt;-c: <span class="keyword">return</span> v</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">return</span> <span class="string">"-"</span> <span class="comment">// 如果c的缓冲为空，则执行默认分支。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">trySend(<span class="string">"Hello!"</span>) <span class="comment">// 发送成功</span></span><br><span class="line">trySend(<span class="string">"Hi!"</span>)    <span class="comment">// 发送成功</span></span><br><span class="line">trySend(<span class="string">"Bye!"</span>)   <span class="comment">// 发送失败，但不会阻塞。</span></span><br><span class="line"><span class="comment">// 下面这两行将接收成功。</span></span><br><span class="line">fmt.Println(tryReceive()) <span class="comment">// Hello!</span></span><br><span class="line">fmt.Println(tryReceive()) <span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// 下面这行将接收失败。</span></span><br><span class="line">fmt.Println(tryReceive()) <span class="comment">// -</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现机制：</strong></p><ol><li>将所有case操作中涉及到的通道表达式和发送值表达式按照从上到下，从左到右的顺序一一估值。 在赋值语句中做为源值的数据接收操作对应的目标值在此时刻不需要被估值。</li><li>将所有分支随机排序。default分支总是排在最后。 所有case操作中相关的通道可能会有重复的。</li><li>为了防止在下一步中造成（和其它协程互相）死锁，对所有case操作中相关的通道进行排序。 排序依据并不重要，官方Go标准编译器使用通道的地址顺序进行排序。 排序结果中前N个通道不存在重复的情况。 N为所有case操作中涉及到的不重复的通道的数量。 下面，通道锁顺序是针对此排序结果中的前N个通道来说的，通道锁逆序是指此顺序的逆序。</li><li>按照上一步中的生成通道锁顺序获取所有相关的通道的锁。</li><li>按照第2步中生成的分支顺序检查相应分支：<ol><li>如果这是一个case分支并且相应的通道操作是一个向关闭了的通道发送数据操作，则按照通道锁逆序解锁所有的通道并在当前协程中产生一个恐慌。 跳到第12步。</li><li>如果这是一个case分支并且相应的通道操作是非阻塞的，则按照通道锁逆序解锁所有的通道并执行相应的case分支代码块。 （此相应的通道操作可能会唤醒另一个处于阻塞状态的协程。） 跳到第12步。</li><li>如果这是default分支，则按照通道锁逆序解锁所有的通道并执行此default分支代码块。 跳到第12步。<br>（到这里，default分支肯定是不存在的，并且所有的case操作均为阻塞的。）</li></ol></li><li>将当前协程（和对应case分支信息）推入到每个case操作中对应的通道的发送数据协程队列或接收数据协程队列中。 当前协程可能会被多次推入到同一个通道的这两个队列中，因为多个case操作中对应的通道可能为同一个。</li><li>使当前协程进入阻塞状态并且按照通道锁逆序解锁所有的通道。</li><li>…，当前协程处于阻塞状态，等待其它协程通过通道操作唤醒当前协程，…</li><li>当前协程被另一个协程中的一个通道操作唤醒。 此唤醒通道操作可能是一个通道关闭操作，也可能是一个数据发送/接收操作。 如果它是一个数据发送/接收操作，则（当前正被解释的select-case流程中）肯定有一个相应case操作与之配合传递数据。 在此配合过程中，当前协程将从相应case操作相关的通道的接收/发送数据协程队列中弹出。</li><li>按照第3步中的生成的通道锁顺序获取所有相关的通道的锁。</li><li>将当前协程从各个case操作中对应的通道的发送数据协程队列或接收数据协程队列中（可能以非弹出的方式）移除。<ol><li>如果当前协程是被一个通道关闭操作所唤醒，则跳到第5步。</li><li>如果当前协程是被一个数据发送/接收操作所唤醒，则相应的case分支已经在第9步中知晓。 按照通道锁逆序解锁所有的通道并执行此case分支代码块。</li></ol></li><li>完毕。</li></ol><h3 id="常见的并发编程错误"><a class="header-anchor" href="#常见的并发编程错误"></a>常见的并发编程错误</h3><p><strong>该加同步的没有加</strong><br>源文件中的代码，在运行时并非总是按照它们出现的顺序被执行。<br>下面这个示例程序犯了两个错误：</p><ul><li>首先，主协程中对变量b的读取和匿名协程中的对变量b的写入可能会产生数据竞争；</li><li>其次，在主协程中，条件b == true成立并不能确保条件a != nil也成立。 编译器和CPU可能会对调整此程序中匿名协程中的某些指令的顺序已获取更快的执行速度。 所以，站在主协程的视角看，对变量b的赋值可能会发生在对变量a的赋值之前，这将造成在修改a的元素时a依然为一个nil切片。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span> <span class="comment">// nil</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span>  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个匿名协程。</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">a = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">b = <span class="literal">true</span> <span class="comment">// 写入b</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> !b &#123; <span class="comment">// 读取b</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 在大多数设备上运行良好，但是某些设备上可能会发生恐慌</span></span><br><span class="line">a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>] = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的行为应当使用管道或者锁来保证顺序正确性</p><p><strong>错误复制<code>sync</code>标准库包中的类型的值</strong><br>在实践中，sync标准库包中的类型（除了Locker接口类型）的值不应该被复制。 我们只应该复制它们的指针值。</p><p><strong>确保每个<code>sync.WaitGroup.Add</code>的调用在<code>sync.WaitGroup.Wait</code>之前</strong><br>下面这个示例会返回<code>0~100</code>的任何一个值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int32</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">atomic.AddInt32(&amp;x, <span class="number">1</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"等待片刻..."</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(atomic.LoadInt32(&amp;x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>没留意过多的<code>time.After</code>函数调用消耗了大量资源</strong><br>如果一分钟内，<code>longRunning</code>被调用且有一百万条消息，则<code>time.After</code>会创建一百万个<code>time.Timer</code>值，则有很大的垃圾回收压力</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果某两个连续的消息的间隔大于一分钟，此函数将返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longRunning</span><span class="params">(messages &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Minute):</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更好的做法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longRunning</span><span class="params">(messages &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">timer := time.NewTimer(time.Minute)</span><br><span class="line"><span class="keyword">defer</span> timer.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-timer.C: <span class="comment">// 过期了</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> msg := &lt;-messages:</span><br><span class="line">fmt.Println(msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此if代码块很重要。</span></span><br><span class="line"><span class="keyword">if</span> !timer.Stop() &#123;</span><br><span class="line">&lt;-timer.C</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须重置以复用。</span></span><br><span class="line">timer.Reset(time.Minute)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个典型的<code>time.Timer</code>的使用已经在上例中展示了。一些解释：</p><ul><li>如果一个<code>Timer</code>值已经过期或者已经被终止（<code>stopped</code>），则相应的<code>Stop</code>方法调用返回<code>false</code>。 在此Timer值尚未终止的时候，<code>Stop</code>方法调用返回f<code>alse</code>只能意味着此<code>Timer</code>值已经过期。</li><li>一个<code>Timer</code>值被终止之后，它的通道字段<code>C</code>最多只能含有一个过期的通知。</li><li>在一个<code>Timer</code>终止（<code>stopped</code>）之后并且在重置和重用此<code>Timer</code>值之前，我们应该确保此<code>Timer</code>值中肯定不存在过期的通知。 这就是上一节中的例子中的if代码块的意义所在。</li></ul><p>一个<code>*Timer</code>值的<code>Reset</code>方法必须在对应<code>Timer</code>值过期或者终止之后才能被调用； 否则，此<code>Reset</code>方法调用和一个可能的向此<code>Timer</code>值的<code>C</code>通道字段的发送通知操作产生数据竞争。<br>在多个协程中使用同一个<code>time.Timer</code>值比较容易写出不当的并发代码，所以尽量不要跨协程使用一个<code>Timer</code>值。</p><h2 id="一些专题"><a class="header-anchor" href="#一些专题"></a>一些专题</h2><h3 id="类型隐式转换"><a class="header-anchor" href="#类型隐式转换"></a>类型隐式转换</h3><p><code>T</code>或<code>*T</code>实现的函数，本质上也是<code>T</code>或<code>*T</code>的成员，存在于其结构中。也就是成员函数。因此即使是特定类型的空指针调用方法，也不会出现<code>panic</code>：<code>_ = ((*Age)(nil)).IsNil()</code><br>本质上，成员函数声明都会进行隐式转换，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Book)</span> <span class="title">Pages</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> b.pages</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Book)</span> <span class="title">SetPages</span><span class="params">(pages <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">b.pages = pages</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会隐式转换成下面的结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Book</span>.<span class="title">Pages</span><span class="params">(b Book)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> b.pages <span class="comment">// 此函数体和Book类型的Pages方法体一样</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Book)</span>.<span class="title">SetPages</span><span class="params">(b *Book, pages <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">b.pages = pages <span class="comment">// 此函数体和*Book类型的SetPages方法体一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当你调用<code>b.Pages()</code>，本质上<code>b</code>也会作为一个参数进行拷贝赋值。<br>对于方法调用，如果声明了<code>(T).F</code>，那么<code>(*T).F</code>和<code>(T).F</code>都可以编译通过，并进行转换成正规的结构<code>(T).F</code>。同理：如果声明了<code>(*T).F</code>，那么<code>(*T).F</code>和<code>(T).F</code>也都可以编译通过，并进行转换成正规的结构<code>(*T).F</code>。<br>对于值类型属主还是指针类型属主都可以接受的方法声明，下面列出了一些考虑因素：</p><ul><li>太多的指针可能会增加垃圾回收器的负担。</li><li>如果一个值类型的尺寸太大，那么属主参数在传参的时候的复制成本将不可忽略。 指针类型都是小尺寸类型。 关于各种不同类型的尺寸，请阅读值复制代价一文。</li><li>在并发场合下，同时调用值类型属主和指针类型属主方法比较易于产生数据竞争。</li><li>sync标准库包中的类型的值不应该被复制，所以如果一个结构体类型内嵌了这些类型，则不应该为这个结构体类型声明值类型属主的方法。</li></ul><p>Go中有四种接口相关的类型转换情形：</p><ol><li>将一个非接口值转换为一个接口类型。在这样的转换中，此非接口值的类型必须实现了此接口类型。</li><li>将一个接口值转换为另一个接口类型（前者接口值的类型实现了后者目标接口类型）。</li><li>将一个接口值转换为一个非接口类型（此非接口类型必须实现了此接口值的接口类型）。</li><li>将一个接口值转换为另一个接口类型（前者接口值的类型未实现后者目标接口类型，但是前者的动态类型有可能实现了目标接口类型）。</li></ol><h3 id="断言"><a class="header-anchor" href="#断言"></a>断言</h3><p>断言<code>i.(T)</code>，其中<code>i</code>为一个接口值,<code>T</code>可以为：</p><ul><li>任意一个非接口类型。</li><li>或者一个任意接口类型。<br><code>type-switch</code>:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> aSimpleStatement; v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> TypeA:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> TypeB, TypeC:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>aSimpleStatement;</code>部分是可选的简单语句，<code>v</code>可要可不要(如果要，必须是个短变量声明)，视实际情况而定。不能使用<code>fallthrough</code></p><p>接口直接定义和嵌套效果是一样的，它们只在形式上有差别，实际方法集完全一致。比如下述<code>Ic,Id</code>接口就是一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ia <span class="keyword">interface</span> &#123;</span><br><span class="line">fa()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Ib = <span class="keyword">interface</span> &#123;</span><br><span class="line">fb()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Ic <span class="keyword">interface</span> &#123;</span><br><span class="line">fa()</span><br><span class="line">fb()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Id = <span class="keyword">interface</span> &#123;</span><br><span class="line">Ia <span class="comment">// 内嵌Ia</span></span><br><span class="line">Ib <span class="comment">// 内嵌Ib</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内嵌"><a class="header-anchor" href="#内嵌"></a>内嵌</h3><p>即在结构体声明中，不声明变量名，只有变量类型。<br>编译器对于内嵌变量，会隐式声明一个和变量类型相同的变量。<br>内嵌的限制：</p><ul><li><code>T</code>不能是一个定义的指针类型和基类型是指针接口类型的类型。</li><li><code>*T</code>中的<code>T</code>也同样不能是一个定义的指针类型和基类型是指针接口类型的类型。</li><li>不能内嵌自己</li><li>不能包含两个相同的基类型相同的内嵌</li></ul><p>在调用过程中，内嵌的字段可以省略。比如<code>A.B.func1</code>，其中<code>B</code>是内嵌变量，那么可以写为<code>A.func1</code>。类似其他语言的继承方式(<a href="https://en.wikipedia.org/wiki/Composition_over_inheritance" target="_blank" rel="noopener">两种方式的优劣</a>)。但是要注意：</p><ul><li>如果<code>A</code>也实现了<code>func1</code>，那么<code>A.func1</code>调用只会调用最浅的一层，即<code>A</code>类型的<code>func1</code>。（遮挡）</li><li>如果<code>A</code>类型中同时有<code>B</code>和<code>C</code>同时实现了<code>func2</code>，那么就不能进行省略缩写。（碰撞）</li></ul><p>来自不同库的相同函数名，是不会发生碰撞和遮挡的。<br>内嵌方法获取：</p><ul><li>类型<code>struct{T}</code>和<code>*struct{T}</code>均将获取类型<code>T</code>的所有方法。</li><li>类型<code>*struct{T}</code>、<code>struct{*T}</code>和<code>*struct{*T}</code>都将获取类型<code>*T</code>的所有方法。<br>简化就是有<code>T</code>的就能获取<code>T</code>的方法，有<code>*</code>的，就能获取到<code>*T</code>的方法</li></ul><h3 id="提升方法值的正规化和估值"><a class="header-anchor" href="#提升方法值的正规化和估值"></a>提升方法值的正规化和估值</h3><p>以下面的代码为例：</p><ul><li>提升方法表达式s.M1的完整形式为s.T.X.M1。 将此完整形式中的隐式取地址和解引用操作转换为显式操作之后的结果为(*s.T).X.M1。 在运行时刻，属主实参(*s.T).X被估值并且估值结果的一个副本被存储下来以供后用。 此估值结果为1，这就是为什么调用f()总是打印出1。</li><li>提升方法表达式s.M2的完整形式为s.T.X.M2。 将此完整形式中的隐式取地址和解引用操作转换为显式操作之后的结果为(&amp;(*s.T).X).M2。 在运行时刻，属主实参&amp;(*s.T).X被估值并且估值结果的一个副本被存储下来以供后用。 此估值结果为提升字段s.X（也就是(*s.T).X）的地址。 任何对s.X的修改都可以通过解引用此地址而反映出来，但是对s.T的修改是不会通过此地址反映出来的。 这就是为什么两个g()调用都打印出了2。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> X <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x X)</span> <span class="title">M1</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *X)</span> <span class="title">M2</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(*x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123; X &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123; *T &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t = &amp;T&#123;X: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s = S&#123;T: t&#125;</span><br><span class="line"><span class="keyword">var</span> f = s.M1 <span class="comment">// &lt;=&gt; (*s.T).X.M1</span></span><br><span class="line"><span class="keyword">var</span> g = s.M2 <span class="comment">// &lt;=&gt; (&amp;(*s.T).X).M2</span></span><br><span class="line">s.X = <span class="number">2</span></span><br><span class="line">f() <span class="comment">// 1</span></span><br><span class="line">g() <span class="comment">// 2</span></span><br><span class="line">s.T = &amp;T&#123;X: <span class="number">3</span>&#125;</span><br><span class="line">f() <span class="comment">// 1</span></span><br><span class="line">g() <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非类型安全指针"><a class="header-anchor" href="#非类型安全指针"></a>非类型安全指针</h3><ul><li>非类型安全指针值<code>unsafe.Pointer</code>是指针但<code>uintptr</code>值是整数，虽然<code>uintptr</code>常常用来存放指针值。</li><li>不再被使用的内存块的回收时间点是不确定的，指针值存放在<code>uintptr</code>中，垃圾回收是检测不到的。</li><li>一个值的地址在程序运行中可能改变，比如切片扩容<br><a href="https://golang.google.cn/pkg/unsafe/#Pointer" target="_blank" rel="noopener">正确使用非安全指针的六种模式</a></li></ul><ol><li><p>将类型<code>*T1</code>的一个值转换为非类型安全指针值，然后将此非类型安全指针值转换为类型<code>*T2</code>。比如下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> MyString <span class="keyword">string</span></span><br><span class="line">ms := []MyString&#123;<span class="string">"C"</span>, <span class="string">"C++"</span>, <span class="string">"Go"</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, ms)  <span class="comment">// [C C++ Go]</span></span><br><span class="line"><span class="comment">// ss := ([]string)(ms) // 编译错误</span></span><br><span class="line">ss := *(*[]<span class="keyword">string</span>)(unsafe.Pointer(&amp;ms))</span><br><span class="line">ss[<span class="number">1</span>] = <span class="string">"Rust"</span></span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, ms) <span class="comment">// [C Rust Go]</span></span><br><span class="line"><span class="comment">// ms = []MyString(ss) // 编译错误</span></span><br><span class="line">ms = *(*[]MyString)(unsafe.Pointer(&amp;ss))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种类型转换共享底层数据结构，在1.17开始也可以用<code>unsafe.Slice((*string)(&amp;ms[0]), len(ms))</code></p></li><li><p>将一个非类型安全指针值转换为一个uintptr值，然后使用此uintptr值。</p></li><li><p>将一个非类型安全指针转换为一个uintptr值，然后此uintptr值参与各种算术运算，再将算术运算的结果uintptr值转回非类型安全指针。注：<code>Pointer</code>-&gt;<code>uintptr</code>-&gt;<code>Pointer</code>这个过程的转换，应该一行就写完，避免中途变为<code>uintptr</code>时，对应的地址解引用，被垃圾回收；以及一些操作可能导致协程堆栈大小改变，使引用的地址失效。</p></li><li><p>将非类型安全指针值转换为<code>uintptr</code>值并传递给<code>syscall.Syscall</code>函数调用。这个是<code>syscall.Syscall</code>函数特权，它能保证进入这个函数后，改指针对应的地址不被垃圾回收或者被移动。注意从<code>1.15</code>后，调用的参数形式必须是<code>uintptr(anUnsafePointer)</code>，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syscall.Syscall(syscall.SYS_READ, <span class="keyword">uintptr</span>(fd),</span><br><span class="line"><span class="keyword">uintptr</span>(unsafe.Pointer(p)), <span class="keyword">uintptr</span>(n))</span><br></pre></td></tr></table></figure></li><li><p>将<code>reflect.Value.Pointer</code>或者<code>reflect.Value.UnsafeAddr</code>方法的<code>uintptr</code>返回值<strong>立即</strong>转换为非类型安全指针。</p></li><li><p>将一个<code>reflect.SliceHeader</code>或者<code>reflect.StringHeader</code>值的<code>Data</code>字段转换为非类型安全指针，以及其逆转换。这种方式可以直接操作<code>slice</code>和<code>string</code>的底层数据。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"unsafe"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"reflect"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [...]<span class="keyword">byte</span>&#123;<span class="string">'G'</span>, <span class="string">'o'</span>, <span class="string">'l'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'g'</span>&#125;</span><br><span class="line">s := <span class="string">"Java"</span></span><br><span class="line">hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">hdr.Data = <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;a))</span><br><span class="line">hdr.Len = <span class="built_in">len</span>(a)</span><br><span class="line">fmt.Println(s) <span class="comment">// Golang</span></span><br><span class="line"><span class="comment">// 现在，字符串s和切片a共享着底层的byte字节序列，</span></span><br><span class="line"><span class="comment">// 从而使得此字符串中的字节变得可以修改。</span></span><br><span class="line">a[<span class="number">2</span>], a[<span class="number">3</span>], a[<span class="number">4</span>], a[<span class="number">5</span>] = <span class="string">'o'</span>, <span class="string">'g'</span>, <span class="string">'l'</span>, <span class="string">'e'</span></span><br><span class="line">fmt.Println(s) <span class="comment">// Google</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>-gcflags=all=-d=checkptr</code>编译器动态分析选项可以检测很多非类型安全指针的错误使用。<br>关于<code>(*reflect.SliceHeader).Data</code>可能导致指针解引用，导致数据丢失问题，可参考：<a href="https://stackoverflow.com/questions/51187973/how-to-create-an-array-or-a-slice-from-an-array-unsafe-pointer-in-golang" target="_blank" rel="noopener">How to create an array or a slice from an array unsafe.Pointer</a></p><h3 id="泛型"><a class="header-anchor" href="#泛型"></a>泛型</h3><p><strong>定义</strong>：是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，而这种参数类型可以用在<code>类</code>、<code>方法</code>和<code>接口</code>中，分别被称为<code>泛型类</code>、<code>泛型方法</code>、<code>泛型接口</code>。<br><em>注意:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型</em><br><a href="https://zhuanlan.zhihu.com/p/382239048" target="_blank" rel="noopener">可参考</a></p><h3 id="反射"><a class="header-anchor" href="#反射"></a>反射</h3><p>Go反射机制设计的目标之一是任何非反射操作都可以通过反射机制来完成。<br>我们可以通过反射列出一个类型的<strong>所有方法和一个结构体类型的所有（导出和非导出）字段的类型</strong><br>虽然<code>reflect.Type.NumField</code>方法返回一个结构体类型的所有字段（包括非导出字段）的数目，但是<a href="https://pkg.go.dev/reflect#pkg-note-BUG" target="_blank" rel="noopener">不推荐</a>使用方法<code>reflect.Type.FieldByName</code>来获取非导出字段。<br>我们可以通过反射来检视结构体字段的标签信息,可以使用对应的<code>Get</code>和<code>Lookup</code>方法获取检视和获取相应的值。<br><code>reflect</code>代码包也提供了一些其它函数来动态地创建出来一些非定义组合类型。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"reflect"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ta := reflect.ArrayOf(<span class="number">5</span>, reflect.TypeOf(<span class="number">123</span>))</span><br><span class="line">fmt.Println(ta) <span class="comment">// [5]int</span></span><br><span class="line">tc := reflect.ChanOf(reflect.SendDir, ta)</span><br><span class="line">fmt.Println(tc) <span class="comment">// chan&lt;- [5]int</span></span><br><span class="line">tp := reflect.PtrTo(ta)</span><br><span class="line">fmt.Println(tp) <span class="comment">// *[5]int</span></span><br><span class="line">ts := reflect.SliceOf(tp)</span><br><span class="line">fmt.Println(ts) <span class="comment">// []*[5]int</span></span><br><span class="line">tm := reflect.MapOf(ta, tc)</span><br><span class="line">fmt.Println(tm) <span class="comment">// map[[5]int]chan&lt;- [5]int</span></span><br><span class="line">tf := reflect.FuncOf([]reflect.Type&#123;ta&#125;,</span><br><span class="line">[]reflect.Type&#123;tp, tc&#125;, <span class="literal">false</span>)</span><br><span class="line">fmt.Println(tf) <span class="comment">// func([5]int) (*[5]int, chan&lt;- [5]int)</span></span><br><span class="line">tt := reflect.StructOf([]reflect.StructField&#123;</span><br><span class="line">&#123;Name: <span class="string">"Age"</span>, Type: reflect.TypeOf(<span class="string">"abc"</span>)&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(tt)            <span class="comment">// struct &#123; Age string &#125;</span></span><br><span class="line">fmt.Println(tt.NumField()) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射使用的三个限制（截止Go 1.17）：</p><ol><li>我们无法通过反射动态创建一个接口类型。</li><li>使用反射动态创建结构体类型的时候可能会有各种不完美的情况出现。</li><li>我们无法通过反射来声明一个新的类型。</li></ol><p>一个<code>reflect.Value</code>值的<code>CanSet</code>方法将返回此<code>reflect.Value</code>值代表的Go值是否可以被修改（可以被赋值）。 如果一个Go值可以被修改，则我们可以调用对应的<code>reflect.Value</code>值的<code>Set</code>方法来修改此Go值。<br><em>注意：<code>reflect.ValueOf</code>函数直接返回的<code>reflect.Value</code>值都是不可修改的。</em></p><p><code>reflect</code>标准库包中也提供了一些对应着内置函数或者各种非反射功能的函数。 下面这个例子展示了如何利用这些函数将一个自定义泛型函数绑定到不同的类型的函数值上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"reflect"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InvertSlice</span><span class="params">(args []reflect.Value)</span> []<span class="title">reflect</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">inSlice, n := args[<span class="number">0</span>], args[<span class="number">0</span>].Len()</span><br><span class="line">outSlice := reflect.MakeSlice(inSlice.Type(), <span class="number">0</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">element := inSlice.Index(i)</span><br><span class="line">outSlice = reflect.Append(outSlice, element)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []reflect.Value&#123;outSlice&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bind</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;, </span></span></span><br><span class="line"><span class="function"><span class="params">f <span class="keyword">func</span> ([]reflect.Value)</span> []<span class="title">reflect</span>.<span class="title">Value</span>)</span> &#123;</span><br><span class="line"><span class="comment">// invert代表着一个函数值。</span></span><br><span class="line">invert := reflect.ValueOf(p).Elem()</span><br><span class="line">invert.Set(reflect.MakeFunc(invert.Type(), f))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> invertInts <span class="function"><span class="keyword">func</span><span class="params">([]<span class="keyword">int</span>)</span> []<span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">Bind</span><span class="params">(&amp;invertInts, InvertSlice)</span></span></span><br><span class="line"><span class="function"><span class="title">fmt</span>.<span class="title">Println</span><span class="params">(invertInts([]<span class="keyword">int</span>&#123;2, 3, 5&#125;)</span>) // [5 3 2]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">invertStrs</span> <span class="title">func</span><span class="params">([]<span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">Bind</span><span class="params">(&amp;invertStrs, InvertSlice)</span></span></span><br><span class="line">fmt.Println(invertStrs([]string&#123;"Go", "C"&#125;)) // [C Go]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：非导出结构体字段值不能用做反射函数调用中的实参</em><br><code>reflect.Value</code>类型的<code>TrySend</code>和<code>TryRecv</code>方法对应着只有一个<code>case</code>分支和一个<code>default</code>分支的<code>select</code>流程控制代码块。也就是非阻塞发送和接收。<br>我们可以使用<code>reflect.Select</code>函数在运行时刻来模拟具有不定<code>case</code>分支数量的<code>select</code>流程控制代码块。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"reflect"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">vc := reflect.ValueOf(c)</span><br><span class="line">succeeded := vc.TrySend(reflect.ValueOf(<span class="number">123</span>))</span><br><span class="line">fmt.Println(succeeded, vc.Len(), vc.Cap()) <span class="comment">// true 1 1</span></span><br><span class="line"></span><br><span class="line">vSend, vZero := reflect.ValueOf(<span class="number">789</span>), reflect.Value&#123;&#125;</span><br><span class="line">branches := []reflect.SelectCase&#123;</span><br><span class="line">&#123;Dir: reflect.SelectDefault, Chan: vZero, Send: vZero&#125;,</span><br><span class="line">&#123;Dir: reflect.SelectRecv, Chan: vc, Send: vZero&#125;,</span><br><span class="line">&#123;Dir: reflect.SelectSend, Chan: vc, Send: vSend&#125;,</span><br><span class="line">&#125;</span><br><span class="line">selIndex, vRecv, sentBeforeClosed := reflect.Select(branches)</span><br><span class="line">fmt.Println(selIndex)         <span class="comment">// 1</span></span><br><span class="line">fmt.Println(sentBeforeClosed) <span class="comment">// true</span></span><br><span class="line">fmt.Println(vRecv.Int())      <span class="comment">// 123</span></span><br><span class="line">vc.Close()</span><br><span class="line"><span class="comment">// 再模拟一次select流程控制代码块。因为vc已经关闭了，</span></span><br><span class="line"><span class="comment">// 所以需将最后一个case分支去除，否则它可能会造成一个恐慌。</span></span><br><span class="line">selIndex, _, sentBeforeClosed = reflect.Select(branches[:<span class="number">2</span>])</span><br><span class="line">fmt.Println(selIndex, sentBeforeClosed) <span class="comment">// 1 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Go 1.17开始，一个切片可以被转化为一个相同元素类型的数组的指针类型:<code>Value.ConvertibleTo(T Type)</code>。 同时引入了一个<code>Value.CanConvert(T Type)</code>方法，用来检查一个转换是否会成功（即不会产生恐慌）</p><h3 id="函数退出方式"><a class="header-anchor" href="#函数退出方式"></a>函数退出方式</h3><ol><li>正常返回，<code>return</code></li><li><code>panic</code>，能被<code>recover</code>捕获，阻止传播。</li><li>调用<code>runtime.Goexit</code>，退出函数，并传播到父函数，直到整个进程退出。</li></ol><p>当函数调用中产生多次<code>panic</code>(比如<code>defer</code>里又产生了<code>panic</code>，或者子协程<code>panic</code>，主协程又<code>panic</code>)则新的<code>panic</code>将覆盖旧的<code>panic</code></p><p>在下面的情况下，recover函数调用的返回值为nil(即空操作)：</p><ul><li>传递给相应panic函数调用的实参为nil；</li><li>当前协程并没有处于恐慌状态；</li><li>recover函数并未直接在一个延迟函数调用中调用。</li></ul><p>一些recover调用相当于空操作（No-Op）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>() <span class="comment">// 空操作</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>() <span class="comment">// 空操作</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>() <span class="comment">// 空操作</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">recover</span>() <span class="comment">// 空操作</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>() <span class="comment">// 空操作</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">recover</span>()       <span class="comment">// 空操作</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">recover</span>() <span class="comment">// 空操作</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"bye"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">recover</span>() <span class="comment">// 将恢复恐慌"byte"</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"bye"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在任何时刻，一个协程中只有最新产生的恐慌才能够被恢复。</p><p>代码块：<br><img src="/2022/01/07/《Go101》读书笔记/%E4%BB%A3%E7%A0%81%E5%9D%97.png" alt></p><h3 id="表达式估值顺序规则"><a class="header-anchor" href="#表达式估值顺序规则"></a>表达式估值顺序规则</h3><p>一个表达式将在其所依赖的其它表达式估值之后进行估值<br>比如下面的代码将打印<code>yzxw</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">_ = f(<span class="string">"w"</span>, x)</span><br><span class="line">x = f(<span class="string">"x"</span>, z)</span><br><span class="line">y = f(<span class="string">"y"</span>)</span><br><span class="line">z = f(<span class="string">"z"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(s <span class="keyword">string</span>, deps ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f(<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>白皮书中关于估值的描述：<br><em>当估值一个表达式、赋值语句或者函数返回语句中的操作数时，所有的函数调用、方法调用和通道操作将按照它们在代码中的出现顺序进行估值。</em><br>其中有个示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y[z.f()], ok = g(h(a, b), i()+x[j()], &lt;-c), k()</span><br></pre></td></tr></table></figure><p>在此赋值语句中，</p><ul><li><code>c</code>是一个通道表达式，它将被估值为一个通道值；</li><li><code>g</code>、<code>h</code>、<code>i</code>、<code>j</code>和<code>k</code>是一些函数表达式，它们将被估值为一些函数值；</li><li><code>f</code>是表达式<code>z</code>值的一个方法。<br>综合考虑上一节和本节上面已经提到的规则，编译器应该保证下列在运行时刻的估值顺序：</li><li>此赋值中涉及到的函数调用、方法调用和通道操作必须按照这样的顺序执行：<code>z.f()→h()→i()→j()→&lt;-c→g()→k()</code>；</li><li>调用<code>h()</code>在表达式<code>h</code>、<code>a</code>和<code>b</code>估值之后调用；</li><li><code>y[]</code>在方法调用<code>z.f()</code>执行之后被估值；</li><li>方法调用<code>z.f()</code>在表达式<code>z</code>估值之后执行；</li><li><code>x[]</code>在调用<code>j()</code>执行之后被估值。<br>然而，下列次序在Go白皮书中未指定，它们依赖于具体编译器实现：</li><li>表达式<code>y</code>、<code>z</code>、<code>g</code>、<code>h</code>、<code>a</code>、<code>b</code>、<code>x</code>、<code>i</code>、<code>j</code>、<code>c</code>和<code>k</code>之间的相对估值顺序；</li><li>表达式<code>y[]</code>、<code>x[]</code>和<code>&lt;-c</code>之间的相对估值顺序。</li></ul><p>变量赋值阶段描述：<br><em>一条赋值语句的执行分为两个阶段。 首先，做为目标值的元素索引表达式中的容器值表达式和索引值表达式、做为目标值的指针解引用表达式中的指针值表达式、以及此赋值语句中的其它非目标值表达式将按照上述通常估值顺序估值。 然后，各个单值赋值将按照从左到右的顺序执行。</em><br>可以看一个示例：<code>a, b = b, a</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 估值阶段</span></span><br><span class="line">P0 := &amp;a; P1 := &amp;b</span><br><span class="line">R0 := a; R1 := b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最基本形式：*P0, *P1 = R0, R1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实施阶段</span></span><br><span class="line">*P0 = R0</span><br><span class="line">*P1 = R1</span><br></pre></td></tr></table></figure><p>但是一些同优先级的估值顺序却没有明确，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := <span class="function"><span class="keyword">func</span> <span class="params">(p *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">*p = <span class="number">99</span></span><br><span class="line"><span class="keyword">return</span> *p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x := <span class="number">0</span></span><br><span class="line">y, z := x+<span class="number">1</span>, f(&amp;x)</span><br><span class="line">fmt.Println(y, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码，输出<code>100 99</code>和<code>1 99</code>都是合理的，不同编译器实现方式不同。</p><p><code>switch-case</code>估值顺序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"f(%v) is called.\n"</span>, n)</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> x := f(<span class="number">3</span>); x + f(<span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">case</span> f(<span class="number">5</span>):</span><br><span class="line"><span class="keyword">case</span> f(<span class="number">6</span>), f(<span class="number">7</span>), f(<span class="number">8</span>):</span><br><span class="line"><span class="keyword">case</span> f(<span class="number">9</span>), f(<span class="number">10</span>):</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(3) is called.</span><br><span class="line">f(4) is called.</span><br><span class="line">f(5) is called.</span><br><span class="line">f(6) is called.</span><br><span class="line">f(7) is called.</span><br></pre></td></tr></table></figure><p><code>select-case</code>估值顺序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">c &lt;- <span class="number">0</span></span><br><span class="line">fchan := <span class="function"><span class="keyword">func</span><span class="params">(info <span class="keyword">string</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(info)</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line">fptr := <span class="function"><span class="keyword">func</span><span class="params">(info <span class="keyword">string</span>)</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(info)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> *fptr(<span class="string">"aaa"</span>) = &lt;-fchan(<span class="string">"bbb"</span>, <span class="literal">nil</span>): <span class="comment">// blocking</span></span><br><span class="line"><span class="keyword">case</span> *fptr(<span class="string">"ccc"</span>) = &lt;-fchan(<span class="string">"ddd"</span>, c):   <span class="comment">// non-blocking</span></span><br><span class="line"><span class="keyword">case</span> fchan(<span class="string">"eee"</span>, <span class="literal">nil</span>) &lt;- *fptr(<span class="string">"fff"</span>):  <span class="comment">// blocking</span></span><br><span class="line"><span class="keyword">case</span> fchan(<span class="string">"ggg"</span>, <span class="literal">nil</span>) &lt;- *fptr(<span class="string">"hhh"</span>):  <span class="comment">// blocking</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bbb</span><br><span class="line">ddd</span><br><span class="line">eee</span><br><span class="line">fff</span><br><span class="line">ggg</span><br><span class="line">hhh</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure><p>注意：以通道接收操作做为源值的赋值语句中的目标值表达式只有在此通道接收操作被选中之后才会被估值。</p><h3 id="值复制成本"><a class="header-anchor" href="#值复制成本"></a>值复制成本</h3><p><code>值尺寸（value size）</code><br>一个值的尺寸表示此值的直接部分在内存中占用多少个字节，它的间接部分（如果存在的话）对它的尺寸没有贡献。意味着：任何一个特定类型的所有值的尺寸都是相同的。所以我们也常说一个值的尺寸为此值的类型的尺寸。(至少1.17的官方编译器是如此)<br>一般来说，不超过4个原生字(计算机位数*4)，都是小尺寸赋值，代价较小。对于标准编译器来说，除了大尺寸的结构体和数组类型，其它类型均为小尺寸类型。</p><h3 id="通道关闭原则"><a class="header-anchor" href="#通道关闭原则"></a>通道关闭原则</h3><p>不要在数据接收方或者在有多个发送者的情况下关闭通道</p><p>多个接收者和发送者进行通道关闭：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> Max = <span class="number">100000</span></span><br><span class="line"><span class="keyword">const</span> NumReceivers = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">wgReceivers.Add(NumReceivers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// stopCh是一个额外的信号通道。它的发送</span></span><br><span class="line"><span class="comment">// 者为中间调解者。它的接收者为dataCh</span></span><br><span class="line"><span class="comment">// 数据通道的所有的发送者和接收者。</span></span><br><span class="line">toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// toStop是一个用来通知中间调解者让其</span></span><br><span class="line"><span class="comment">// 关闭信号通道stopCh的第二个信号通道。</span></span><br><span class="line"><span class="comment">// 此第二个信号通道的发送者为dataCh数据</span></span><br><span class="line"><span class="comment">// 通道的所有的发送者和接收者，它的接收者</span></span><br><span class="line"><span class="comment">// 为中间调解者。它必须为一个缓冲通道。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stoppedBy <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间调解者</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">stoppedBy = &lt;-toStop</span><br><span class="line"><span class="built_in">close</span>(stopCh)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送者</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">value := rand.Intn(Max)</span><br><span class="line"><span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 为了防止阻塞，这里使用了一个尝试</span></span><br><span class="line"><span class="comment">// 发送操作来向中间调解者发送信号。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> toStop &lt;- <span class="string">"发送者#"</span> + id:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处的尝试接收操作是为了让此发送协程尽早</span></span><br><span class="line"><span class="comment">// 退出。标准编译器对尝试接收和尝试发送做了</span></span><br><span class="line"><span class="comment">// 特殊的优化，因而它们的速度很快。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使stopCh已关闭，如果这个select代码块</span></span><br><span class="line"><span class="comment">// 中第二个分支的发送操作是非阻塞的，则第一个</span></span><br><span class="line"><span class="comment">// 分支仍很有可能在若干个循环步内依然不会被选</span></span><br><span class="line"><span class="comment">// 中。如果这是不可接受的，则上面的第一个尝试</span></span><br><span class="line"><span class="comment">// 接收操作代码块是必需的。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(strconv.Itoa(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收者</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 和发送者协程一样，此处的尝试接收操作是为了</span></span><br><span class="line"><span class="comment">// 让此接收协程尽早退出。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使stopCh已关闭，如果这个select代码块</span></span><br><span class="line"><span class="comment">// 中第二个分支的接收操作是非阻塞的，则第一个</span></span><br><span class="line"><span class="comment">// 分支仍很有可能在若干个循环步内依然不会被选</span></span><br><span class="line"><span class="comment">// 中。如果这是不可接受的，则上面尝试接收操作</span></span><br><span class="line"><span class="comment">// 代码块是必需的。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> value := &lt;-dataCh:</span><br><span class="line"><span class="keyword">if</span> value == Max<span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// 为了防止阻塞，这里使用了一个尝试</span></span><br><span class="line"><span class="comment">// 发送操作来向中间调解者发送信号。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> toStop &lt;- <span class="string">"接收者#"</span> + id:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(strconv.Itoa(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">wgReceivers.Wait()</span><br><span class="line">log.Println(<span class="string">"被"</span> + stoppedBy + <span class="string">"终止了"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：信号通道toStop的容量必须至少为1。 如果它的容量为0，则在中间调解者还未准备好的情况下就已经有某个协程向toStop发送信号时，此信号将被抛弃。</p><h2 id="内存相关"><a class="header-anchor" href="#内存相关"></a>内存相关</h2><h3 id="内存空间分配："><a class="header-anchor" href="#内存空间分配："></a>内存空间分配：</h3><p><a href="https://www.cnblogs.com/mayanan/p/16012426.html" target="_blank" rel="noopener">变量逃逸分析</a><br>分析逃逸的编译参数：<code>go run -gcflags &quot;-m -l&quot; main.go</code><br><code>开辟在堆的好处</code>：</p><ul><li>从栈上开辟内存块比在堆上快得多，并且不会产生内存碎片。</li><li>开辟在栈上的内存块不需要被垃圾回收；</li><li>开辟在栈上的内存块对CPU缓存更加友好。</li></ul><p>使用内置<code>new</code>函数开辟的内存可能开辟在堆上，也可能开辟在栈上。<br>当一个协程的栈的大小改变时，一个新的内存段将申请给此栈使用。原先已经开辟在老的内存段上的内存块将很有可能被转移到新的内存段上，或者说这些内存块的地址将改变。 相应地，引用着这些开辟在此栈上的内存块的指针（它们同样开辟在此栈上）中存储的地址也将得到刷新。示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">int</span> <span class="comment">// 防止f被内联</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">1</span>&lt;&lt;<span class="number">20</span>]<span class="keyword">byte</span> <span class="comment">// 使栈增长</span></span><br><span class="line"><span class="keyword">return</span> a[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line"><span class="built_in">println</span>(&amp;x)</span><br><span class="line">f(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">println</span>(&amp;x)<span class="comment">//该地址和上面的地址不一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存块儿回收时机"><a class="header-anchor" href="#内存块儿回收时机"></a>内存块儿回收时机</h3><ul><li>为包级变量的直接部分开辟的内存块永远不会被回收。</li><li>每个协程的栈将在此协程退出之时被整体回收。</li><li>开辟在堆上的不再被使用的内存块将在以后某个时刻被垃圾回收器回收掉。</li></ul><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><p>如果你已经初步学习过golang，这本书也可以作为进阶的一本书阅读。但是个人不推荐这本书。整体来说一些知识点的表达不是很清醒，也不够明朗。但是其中一些知识点，倒是可以学习学习。</p><h3 id="相关"><a class="header-anchor" href="#相关"></a>相关</h3><p><a href="https://draveness.me/golang/" target="_blank" rel="noopener">go语言设计与实现</a> 和这本书定位一样，属于golang进阶的书，但是这本书感觉更好(虽然我还没有怎么看)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;姜大佬推荐的一本较为深入理解go细节的书，作为golang学习进阶。(•̀⌄•́)&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;以下内容都是根据书中的章节目录，并且根据自己的缺陷进行记录的。&lt;/em&gt;&lt;br&gt;
&lt;em&gt;如果有兴趣，推荐先阅读原著，再看笔记。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>《原则》读书笔记</title>
    <link href="http://yoursite.com/2021/10/28/%E3%80%8A%E5%8E%9F%E5%88%99%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/10/28/《原则》读书笔记/</id>
    <published>2021-10-28T14:09:18.000Z</published>
    <updated>2022-01-07T07:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>教会你如何建立自己的原则，构建属于完美独特的自我(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>主题：教你做事<br>类别：人文社科-&gt;实用性<br>概要：俗话说的鸡汤书，如果是个能实用的鸡汤书，并且你能照着做，那么就很棒了。</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>人们所拥有的知识相比未知的知识是少的可怜的，知道自己的无知是难能可贵的事情。重要的是，当你遇到一个未知的事务、场景或者困惑时，如何进行处理，则是你原则存在的重要意义。而本书则是让你明确和构建你自己的原则，并加以实施。</p><h2 id="拥有你自己的原则"><a class="header-anchor" href="#拥有你自己的原则"></a>拥有你自己的原则</h2><ol><li>独立思考并决定：<ol><li>你想要什么；</li><li>事实是什么；</li><li>面对事实，你如何实现自己的愿望</li></ol></li><li>要保持谦逊和心胸开阔，以便你能动用自己的最佳思维</li><li>写下你的原则，保持你的原则做事</li><li>时间就像一条河流，载着我们顺流而下，遇到现实，需要决策，但我们无法停留，也无法回避，只能以最好的方式应对。</li><li>每日坚持做一些事情，总有你意想不到的收获。</li><li>“我是对的”到“我怎么知道我是对的”：<ol><li>找到与我观点不同的最聪明的人，以便自己能够努力理解他们的推理。</li><li>知道自己在什么时候不能有明确的意见，不急于下结论。</li><li>逐步归纳永恒和普适的原则，对其进行测试，将其系统化。</li><li>通过平衡风险来保持较大的回报，并降低下行波动</li></ol></li><li>有时生活会给你当头一棒，不要失去信念。重新站起来的你会更加强大。</li><li>我发现如果我拥有15—20个良好的、互不相关的回报流，我就能大大降低我的风险，同时又不减少我的预期收益。</li><li>任何组织成功的关键都是人和文化。</li><li>塑造者：在某一方面拥有宏达而独特的愿景，并能使其成为现实。</li><li>良好的原则是应对现实的方法。</li><li>每个人都需要花很多时间来思考和摸索适合自己的原则。</li><li>考察影响你的那些事物的规律，从而理解其背后的因果关系，并学习有效应对这些事物的原则。</li><li>我认为一切事情的发生都是由于反复出现、不断演进的因果关系。</li></ol><h2 id="生活原则"><a class="header-anchor" href="#生活原则"></a>生活原则</h2><ol><li>拥抱现实，应对现实<ol><li>做一个超级现实的人<ol><li>梦想+现实+决心=成功的生活</li></ol></li><li>真相（或者更精确地说，对现实的准确理解）是任何良好结果的根本依据</li><li>做到头脑极度开放、极度透明<ol><li>对于快速学习和有效改变而言，头脑极度开放、极度透明是价值无限的。</li><li>不要担心其他人的看法，使之成为你的障碍</li><li>拥抱极度求真和极度透明将带来更有意义的工作和更有意义的人际关系</li></ol></li><li>观察自然，学习现实规律<ol><li><strong>自上而下</strong>：努力找到这些东西背后的唯一驱动法则或规律。例如，在理解市场时，人可以研究影响所有经济和市场的普适法则，如供求关系；在理解物种时，人可以集中了解基因密码是如何对所有物种发生作用的。</li><li><strong>自下而上</strong>：研究每种具体情况及其背后的法则或规律，例如，小麦市场独特的法则或规律，或者使鸭子区别于其他物种的基因序列。</li><li>不要固守你对事物“应该”是什么样的看法，这将使你无法了解真实的情况</li><li>什么是好什么是坏？ 一个东西要“好”，就必须符合现实的规律，并促进整体的进化，这能带来最大的回报</li><li>进化是宇宙中最强大的力量，是唯一永恒的东西，是一切的驱动力</li><li>进化是生命最大的成就和最大的回报<ol><li>个体的激励机制必须符合群体的目标</li><li>现实为了整体趋向最优化，而不是为了个体</li><li>通过快速试错以适应现实是无价的</li><li>意识到你既是一切又什么都不是，并决定你想成为什么样子</li><li>你的未来取决于你的视角</li></ol></li><li>理解自然提供的现实教训<ol><li>把你的进化最大化</li><li>记住“没有痛苦就没有收获”</li><li>自然的一项根本法则是，为了赢得力量，人必须努力突破极限，而这是痛苦的。</li></ol></li><li>痛苦+反思=进步<ol><li>迎接而非躲避痛苦<ol><li>找到、接受，并学会如何应对你的弱点；</li><li>更喜欢周围的人对你坦诚，而不是隐瞒对你的负面看法；</li><li>展现真实的自我，而不是强行把弱点伪装成优势</li></ol></li><li>接受严厉的爱</li></ol></li><li>考虑后续与再后续的结果</li><li>接受结果</li><li>从更高的层次俯视机器<ol><li>把自己想象成一部在大机器里运转的小机器，并明白你有能力改变你的机器以实现更好的结果</li><li>通过比较你实现的结果和你的目标，你就能确定如何改进你的机器</li><li>区别作为机器设计者的你和作为机器中工作者的你</li><li>大多数人犯下的最大错误是不客观看待自己以及其他人，这导致他们一次次地栽在自己或其他人的弱点上</li><li>成功的人能超越自身，客观看待事物，并管理事物以塑造改变</li><li>在你不擅长的领域请教擅长的其他人，这是一个你无论如何都应该培养的出色技能，这将帮助你建立起安全护栏，避免自己做错事</li><li>因为客观看待自身很困难，所以你需要依赖其他人的意见，以及全部证据</li><li>如果你的头脑足够开放，足够有决心，你几乎可以实现任何愿望。找到一条适合自己的路。</li></ol></li><li>帮助你鼓起勇气克服自身弱点的方式：<ol><li>不要混淆你的愿望和事实。</li><li>不要为自身形象担心，只需关心能不能实现你的目标。</li><li>不要过于重视直接结果而忽视后续、再后续的结果。</li><li>不要让痛苦妨碍进步。</li><li>不要把不好的结果归咎于任何人，从自己身上找原因</li></ol></li></ol></li><li><strong>实现目标的五步法</strong>(你要成功就必须做好每一步，而且必须按顺序一步步来，不要交叉)：<ol><li>有明确的目标<ol><li>排列优先顺序，你不可能得到所有东西，你只能选择其中一部分。</li><li>不要混淆目标和欲望</li><li>调和你的目标和欲望，以明确你在生活中真正想要的东西</li><li>不要把成功的装饰误认为成功本身(以为自己买了名牌包包，就觉得自己很牛B)</li><li>永远不要因为你觉得某个目标无法实现就否决它</li><li>谨记伟大的期望创造伟大的能力(如果你定的目标能轻易实现，自我要求就太低了)</li><li>知道如何对待挫折(控制损失)和知道如何前进一样重要。</li></ol></li><li>找到阻碍你实现这些目标的问题，并且不容忍问题<ol><li>把令人痛苦的问题视为考验你的潜在进步机会</li><li>不要逃避问题，因为问题根植于看起来并不美好的残酷现实</li><li>要精准地找到问题所在</li><li>不要把问题的某个原因误认为问题本身</li><li>区分大问题和小问题</li><li>找出一个问题之后，不要容忍问题</li></ol></li><li>准确诊断问题，找到问题的根源<ol><li>先把问题是什么弄明白，再决定怎么做</li><li>区分直接原因和根本原因，消灭根本原因才是王道。</li><li>认识到了解人（包括你自己）的特性，有助于对其形成合理预期</li></ol></li><li>规划可以解决问题的方案<ol><li>前进之前先回顾</li><li>把你的问题看作一部机器产生的一系列结果</li><li>谨记实现你的目标通常有很多途径，你只需要找出有效的一条</li><li>把你的方案设想为一个电影剧本，然后循序渐进地思考由谁来做什么事</li><li>把你的方案写下来，让所有人都能看到，并对照方案执行</li><li>要明白，规划一个好方案不一定需要很多时间，避免浪费大量的时间也避免草草决定。</li></ol></li><li>做一切必要的事来践行这些方案，实现成果<ol><li>规划做得再好，不执行也无济于事。规划执行中，谨记与目标之间的联系。</li><li>良好工作习惯的重要性常被大大低估。</li><li>建立清晰的衡量标准来确保你在严格执行方案<br>注：谨记，这五步中的每一步都源自你的价值观。你的价值观决定了你想要什么，即你的目标。同时谨记，这五步是层层递进的。每完成一步，你都会获得一定的信息，很可能有助于你改进其他步骤。这五步都完成后，你可以设定一个新目标，再做一遍。如果这个流程行之有效，你的目标会比你的规划改变得慢，你的规划会比你的任务改变得慢<br><strong>如果你找到了解决方案，弱点是不重要的</strong></li></ol></li></ol></li><li>有些人擅长自己思考解决问题，有些人擅长学习请教他人而解决问题。通常你两个方面都需要。</li></ol></li><li>做到头脑极度开放<ol><li>认识你的两大障碍<ol><li>自我意识<ol><li>潜意识的自我防卫，比如恐惧，需要生存，怕孤独</li><li>总是存在两个我在进行斗争。理性的我和感谢的我</li></ol></li><li>思维盲点<ol><li>你只能看到事务的一面，而不能都看全，人总会有思维的盲点。</li></ol></li></ol></li><li>奉行头脑极度开放<ol><li>诚恳地相信你也许并不知道最好的解决办法是什么，并认识到，与你知道的东西相比，能不能妥善处理“不知道”才是更重要的。</li><li>认识到决策应当分成两步：先分析所有相关信息，然后决定</li><li>不要担心自己的形象，只关心如何实现目标</li><li>认识到你不能“只产出不吸纳”</li><li>认识到为了能够从他人的角度看待事物，你必须暂时悬置判断，只有设身处地，你才能合理评估另一种观点的价值</li><li>谨记，你是在寻找最好的答案，而不是你自己能得出的最好答案</li><li>水平相当的人才应当争论，而水平相差比较大的人，应当先学习。</li></ol></li><li>领会并感激：深思熟虑的意见分歧<ol><li>站着理性的基础上和值得探讨的人一起讨论，分析其中的分歧。</li><li>为最坏的情况做准备，以尽量使其不那么糟糕</li></ol></li><li>识别你应当注意的头脑封闭和头脑开放的不同迹象<ol><li>大脑封闭的人不喜欢自己的观点被挑战…</li><li>头脑开放的人更想了解为什么出现分歧…</li></ol></li><li>如何做到头脑极度开放<ol><li>利用痛苦来引导自己进行高质量的思考</li><li>将头脑开放作为一种习惯</li><li>认识自己的思维盲点</li><li>假如很多可信的人都说你正在做错事，只有你不这么看，你就要想想自己是不是看偏了</li><li>冥想，静下心来好好思考和整理一些事情，站在更高位维度看待一些东西。</li><li>重视证据，并鼓励其他人也这么做</li><li>尽力帮助其他人也保持头脑开放</li><li>使用以证据为基础的决策工具</li><li>知道什么时候应当停止为自己的观点辩护，信任自己的决策程序</li></ol></li><li>人一生最大的决策在于是否愿意去追逐真像。</li></ol></li><li>理解人与人的不同<ol><li>明白你与其他人的思维方式能带来的力量</li><li>我们拥有各种天生特征，既可能帮助自己也可能伤害自己，取决于如何应用</li><li>理解大脑里的主要斗争，以及如何控制这些斗争，以实现“你”的愿望<ol><li>要明白，意识与潜意识在不断斗争</li><li>要知道最常发生的斗争是情绪和思考的斗争</li><li>调和你的情绪和思考</li><li>善择你的习惯</li><li>坚持友善地训练“较低层次的你”，以养成好的习惯</li><li>理解右脑思维和左脑思维的差别，也就是线性思维和发散思维的区别。</li><li>理解大脑可以改变的程度</li></ol></li><li>认识自己和他人的特性<ol><li>创造者:提出新想法、新概念。他们喜欢非结构化、抽象的活动，喜欢创新和不走寻常路。</li><li>推进者:传递这些新想法并推进。他们喜欢感觉和人际关系，管理各种人的因素。他们非常善于激发工作热情。</li><li>改进者:挑战想法。他们分析计划以寻找缺陷，然后以很客观、符合逻辑的方式改进计划。他们喜欢事实和理论，以系统性的方式工作。</li><li>贯彻者:也可以叫作执行者。他们确保重要的工作得到执行，目标被实现。他们关注细节和结果。</li><li>变通者:是以上4种类型的结合。他们能根据特定需求调整自身，并能从各种各样的视角看待问题。</li></ol></li><li>大自然塑造万事万物皆有目的。你最需要的勇气不是驱使你战胜别人的勇气，而是不管其他人对你有何冀望，你始终坚持做最真实的自我的勇气。</li><li>无论你要实现什么目标，让合适的人各司其职以支持你的目标，是成功的关键<ol><li>一些决策你应该自己做，一些则应该让更可信的人代理。利用自知之明区分这两种情况，是成功的关键，不管你追求什么</li></ol></li></ol></li><li>学习如何有效决策<ol><li>影响好决策的最大威胁是有害的情绪；决策时先问问自己，我冷静么?</li><li>决策是一个两步流程（先了解后决定）,确定自己了解所有知识了么？</li><li>综合分析眼前的形式：<ol><li>你能做的最重要的决定之一是决定问谁</li><li>不要听到什么信什么</li><li>所有东西都是放在眼前看更大</li><li>不要过度分析细节</li></ol></li><li>综合分析变化中的形势<ol><li>始终记住改善事物的速度和水平，以及两者的关系，你不能在很长的时间里改善某个事情。</li><li>不必过于精确，有些时候不用过于精准，只需要大概估计</li><li>谨记“80/20法则”，并明白关键性的“20%”是什么</li><li>不要做完美主义者</li></ol></li><li>高效地综合考虑各个层次，举个栗子：<ol><li>高层次的全局：我想要能学到很多东西的有意义的工作。<ol><li>次一级的理念：我想成为一名医生。<ol><li>次一级的点：我需要上医学院。<ol><li>再次一级的点：我需要在科学课程上取得好成绩。<ol><li>再再次一级的点：我今晚需要在家学习。</li></ol></li></ol></li></ol></li></ol></li><li>明白你们在谈论细节还是谈论要点</li><li>谨记，决策需要在合理的层次做出，但也应在各层次之间保持一致</li></ol></li><li>综合分析现实、理解如何行动的最好工具是逻辑、理性和常识</li><li>根据预期价值计算做决策：(成功概率-失败概率)*本机<ol><li>不管你押对的概率已经有多大，提高你的押对概率始终有价值</li><li>知道什么时候不要去押注，和知道什么注值得押同样重要</li><li>最好的选择是好处多于坏处的选择，不是毫无坏处的选择</li></ol></li><li>比较更多信息带来的价值和不做决定造成的成本，决定优先顺序<ol><li>先把你的“必做之事”做完，再做你的“想做之事”</li><li>你很可能没有时间处理不重要的事，那最好将它留着，以免自己没有时间处理重要的事</li><li>不要把概率当作可能性</li></ol></li></ol></li><li>成为好决策者的捷径<ol><li>简化</li><li>很多事情都是相似的，你可以用相同的原则来处理。这个原则可以是你自己的，也可以是别人的，好使就行。</li><li>对你的决策进行可信度加权。把你的决策拉出去和可信的人讨论，增加你决策的可信度。</li><li>计算机或其他工具能够更好的帮助你决策。</li><li>任何工具都只是辅助，做决策的主要还是人。</li></ol></li><li>总结：<ol><li>要知道最好的决策时什么，并有勇气做出最好的决策。</li><li>拥抱现实并妥善应对现实。</li><li>你从哪里获得这些原则并不重要，拥有原则、持之以恒地运用原则、不断改进完善原则才最重要。</li><li>做了决策，不行动，和不做一样。</li></ol></li></ol><h2 id="工作原则"><a class="header-anchor" href="#工作原则"></a>工作原则</h2><ol><li>任何组织或机构若想正常运转，其工作原则必须与其成员的生活原则相契合。</li><li>一个机构就像一部机器，主要由两组部件构成：文化和人<ol><li>优秀的机构拥有优秀的人和优秀的文化</li><li>优秀的人具备高尚的品格和出色的能力</li><li>优秀的文化不掩盖问题和分歧，而是公开妥善解决，喜欢让想象力驰骋且愿意开创先河<ol><li>当结果与目标出现不一致时，管理者能否及时发现问题、及时调整工作方案并组织员工弥补缺陷，是其机构能否脱颖而出并在竞争中取胜的关键</li></ol></li><li>严厉之爱有助于成就优异的工作业绩和建立良好的人际关系<ol><li>为了成就伟大事业，对不应妥协的事情就必须坚持立场、寸步不让</li></ol></li><li>基于可信度加权的创意择优是实现有效决策的最佳模式</li><li>极度求真和极度透明</li><li>创意择优=极度求真+极度透明+可信度加权的决策</li><li>原则不能凌驾于常识之上，要知道原则也有不适用的时候。</li></ol></li><li>让热情与工作合二为一，并与志同道合者倾力推进<ol><li>如果人想学到应对不利局面的本领，就需要面对残酷和不确定的现实</li><li>不要惧怕了解事实</li><li>为人要正直，也要求他人保持正直<ol><li>若不想当面议论别人，背地里也不要说，要批评别人就当面指出来</li><li>不要因忠诚于个人而阻碍追求事实和整个机构的利益</li></ol></li><li>营造一种氛围，让每个人都有权了解合理之事，不可保持异议却缄默不语<ol><li>表达出来，并对你的观点负责，否则就走人</li><li>切记要绝对开诚布公</li><li>切莫轻信不诚实之人</li></ol></li><li>要保持极度透明<ol><li>在尽可能做到彻底透明的同时，也要保持必要的谨慎</li><li>要向善于管理信息的人透明，对那些不善管理信息的人，要么不透明，要么将其清除出公司队伍</li></ol></li></ol></li><li>做有意义的工作，发展有意义的人际关系<ol><li>忠于共同的使命，而非对此三心二意之人</li><li>要认识到机构规模过大会对建立有意义的人际关系构成威胁</li><li>要记住很多人只是假装为你工作，而实际上是在追求一己私利</li><li>珍视诚实、能力强、表里如一的员工</li></ol></li><li>打造允许犯错，但不容忍罔顾教训、一错再错的文化<ol><li>意识到错误是事物演变过程中的自然连带部分<ol><li>把失败变成好事</li><li>不要为你自己或他人的错误而懊恼，要珍爱它</li></ol></li><li>不要纠结于一时的成败，要放眼于达成目标</li><li>观察错误模式，判断是否因缺点引起</li><li>记住在经历痛苦后要反思<ol><li>痛苦+反思=进步</li><li>要知道，没有人能客观地看待自己</li><li>教导并强化“吃一堑、长一智”的道理</li><li>知道哪些错误可以接受，哪些错误无法容忍，不要让你的员工犯不可接受的错误</li></ol></li></ol></li><li>求取共识并坚持<ol><li>持开放心态，同时也要坚定果断</li><li>确保工作负责人以开放的心态对待问题和他人的意见</li><li>认识到求取共识是双向的责任<ol><li>有一些很简单的技巧会很有用，比如重复一遍你刚听到的别人的观点，确保你理解正确</li></ol></li><li>自己要通情达理，也期待别人通情达理</li><li>如果由你主持会议，应把握好对话<ol><li>明确会议的主持人和会议的服务对象</li><li>表述要清晰准确，以免造成困惑</li><li>根据目标和优先次序来确定采用什么样的沟通方式，以及相应的人选。</li><li>主持讨论时要果断、开明</li><li>在不同层面的讨论对话中穿梭对照</li><li>谨防“跑题”</li><li>坚持对话的逻辑性，避免情绪化</li><li>注意不要因集体决策而丧失个人责任</li><li>运用两分钟法则避免持续被别人打断</li><li>让对话善始善终，总结会议和对话。</li></ol></li><li>伟大的合作如同爵士乐演奏</li><li>珍惜志同道合者</li><li>如果你发现自己无法调和相互间的主要分歧——尤其是价值观层面的——要考虑是否值得维持这种关系</li></ol></li><li>做决策时要从观点的可信度出发<ol><li>加权投票策略，在大众投票上，为投票加上权重。更有经验的人，解决更多这种类型问题的人，权重越高。</li><li>采用创意择优，需要你了解每个人观点的长处<ol><li>如果你自己无法成功完成某件事，就不要想着指导别人该如何完成</li><li>要知道每个人都有自己的观点，但通常不是什么好点子。(只要集大成的点子才是好点子)</li></ol></li><li>关注可信度最高、与你观点不一致的人，尽量理解其推理过程<ol><li>要分析人们的可信度，以评价其观点正确的可能性</li><li>较可信的观点很可能出自以下两种人：（1）至少曾经三次成功解决过相关问题；（2）对所得结论的因果关系分析很有道理</li><li>若某人并无经验，但其所讲道理似乎符合逻辑且可经受压力测试，则一定要试一试</li><li>要更关注发言人的推理过程，而非其结论</li><li>没经验的人也不乏好点子，有时远远胜过有经验的人</li><li>每个人都应在表达观点时信心满满</li></ol></li><li>考虑好你要扮演老师、学生、同事中的哪个角色…你应该去说教、提问还是辩论<ol><li>学生理解老师比老师理解学生更重要，尽管二者都重要</li><li>每个人都有权利和责任尽力了解重要的事情，还必须保持谦逊和非常开放的心态</li></ol></li><li>要了解人们提出意见的过程和逻辑<ol><li>无论你向谁提问，对方一般都会提供“答案”，所以要仔细考虑要向谁提问</li><li>让每个人都可肆意评论其他人的观点，此举低效且浪费时间</li><li>提防以“我以为…”为开头的发言</li><li>系统梳理员工的工作记录，评估其发言的可信度</li></ol></li><li>处理分歧务必高效<ol><li>知道适时终结辩论，推动就下一步措施形成共识</li><li>可信度加权可以作为工具，但不能取代责任人的决策。但决策者推翻了加权决策结果，那么就要负责任。</li><li>如果你自己没有时间全面检视每个人的想法，则要明智选取具有可信度的观点</li><li>若由你负责做决策，要把可信度加权后得出的结论和你自己的想法做比较</li></ol></li><li>每个人都有权利和义务去设法了解重要的事情<ol><li>沟通是为了获得最佳回应，故应与最相关的人沟通</li><li>以教育或促成共识为目的的沟通，不仅仅是为了获得最佳答案，故应让更多的人参与</li><li>要认识到你没有必要凡事都做出判断。自己不知道的事情，就不要表态。</li></ol></li><li>要更关注决策机制是否公允，而非是否如你自己所愿</li></ol></li><li>知道如何超越分歧<ol><li>要牢记：相互达成协议时不能忽视原则<ol><li>每个人都要遵守相同的行为原则</li></ol></li><li>不要让大家把发牢骚、提建议、公开辩论的权利与决策权相混淆<ol><li>对决策本身以及决策者提不同意见时，要有大局意识</li></ol></li><li>不要对重大分歧不闻不问<ol><li>专心协商大事时，别被琐事烦扰</li><li>不要被分歧束缚住   ——要么提交上级裁定，要么投票表决</li></ol></li><li>一旦做出决定，任何人都必须服从，即便个人可能有不同意见<ol><li>着眼大局</li><li>不要让创意择优变成无法无天</li><li>不要容忍暴民手段</li></ol></li><li>如果创意择优与机构的利益相冲突，就难免会造成危害<ol><li>创意优先是为了能让机构运转的更好。</li><li>当心可能有人会提出为了“机构的利益”而临时放弃创意择优</li><li>要知道一旦有权做决定的人不想依原则行事，规矩就会被破坏</li></ol></li></ol></li><li>关于用人<ol><li>人和公司文化是相容共生的。</li><li>给他们配备能使他们在岗位上施展才华的工具和信息，而不是事无巨细地对他们进行微观管理。如果他们在受训后仍无法胜任，那就辞掉；如果能胜任，就提拔</li><li>比做什么事更重要的是找对做事的人<ol><li>记住目标是什么</li><li>把目标布置给能胜任它的人</li><li>让他们尽职尽责</li><li>如果在你培训他们并给其时间学习之后，他们还无法胜任工作，就辞掉他们</li></ol></li><li>你最重要的决策是选好工作的责任人<ol><li>最重要的责任人是在最高层负责订立目标、规划成果和组织实施的人</li><li>负最终责任的人应是对行为后果承担责任的人</li><li>确保每个人都有上级领导,即每个人都可以被问责。</li></ol></li><li>要记住事情背后是人的力量</li><li>要用对人，因为用人不当的代价高昂<ol><li>让合适的人做合适的事，是有事情，才需要找人，不要因人设职</li><li>要考虑你寻找的人应具备什么样的价值观、能力和技艺（按此顺序）</li><li>要用系统性思维和科学方法招聘人才</li><li>注意：人与职责要相匹配，把合适的人放到合适的位置。</li><li>要找出色的人，而不是“此类即可”</li><li>不要凭借你的影响力帮别人找工作</li></ol></li><li>要记住人与人存在差异，认识不同、思维不同使不同的人适合不同工作<ol><li>明白如何进行个性评估，并清楚结果含义。岗位上选择适合个性的人，能发挥更大的作用。</li><li>人容易选择与自己相似的人，因此安排面试官要确保其能发现你想招的人。想什么样的人，就安排什么样的面试官</li><li>选用那些能客观认识自己的人</li><li>要记住人一般不会随岁月有太大变化</li></ol></li><li>对待你的团队要像体育界管理者那样：没人能靠一己之力单独取胜，但每个人都必须战胜对手</li><li>关注人的过往经历<ol><li>核查情况，不能光听应聘者的一家之言。</li><li>学习成绩不能充分证明这个人是否具备你想要的价值观和能力</li><li>概念思维能力强固然最佳，但经验丰富、业绩出众也很重要</li><li>警惕不切实际的理想主义者</li><li>不要假定在别处获得成功的人也同样能胜任你所要求的工作</li><li>确保你选用的人要品格好、能力强</li></ol></li><li>找人不仅是干份具体工作，你还要愿意与其分享你的生活<ol><li>选那些会问很多好问题的人</li><li>让求职者知道这份工作的阴暗面</li><li>合作者必是意趣相投之人，但也须是诤友</li></ol></li><li>考虑薪酬时，要提供稳定性也要让人看到机会<ol><li>依人发薪，而非依工作岗位发薪</li><li>薪酬至少要大体上与业绩测评结果挂钩</li><li>薪酬要高于一般水平</li><li>要更多想着如何把蛋糕做大，而非怎样切蛋糕才能使自己获得最大的一块</li></ol></li><li>要记住维系伟大的合作关系，比金钱更重要的是体贴和宽厚</li><li>出色的人不容易找，所以要想着怎样留住人</li></ol></li><li>当你了解一个人时，就会知道可从他那里得到什么<ol><li>持续培训、测试、评估和调配员工<ol><li>要懂得你和你的下属将经历个人成长<ol><li>认清优缺点后，个人会飞速成长</li><li>培训引导个人发展</li><li>授人以渔，而不是授人以鱼，即便这意味着会使他们犯些错</li><li>经验会形成内化的学习，这是书本学习无法替代的</li></ol></li><li>不断提供反馈</li><li>准确评价人，不做“好好先生”<ol><li>到最后，准确和善意是一回事</li><li>正确运用褒贬</li><li>考虑准确度，而非后果。重视批评的准确度，而不是被批评后的后果</li><li>做出准确评价</li><li>要像从成功中学习一样从失败中学习</li><li>多数人做过的事和他们正在做的事，并不像他们认为的那么重要</li></ol></li><li>严厉的爱既是最难给的，也是最重要的爱（因为它很不受欢迎）<ol><li>虽然多数人爱听好话，但准确的批评更加难得</li></ol></li><li>对人的观察不要讳莫如深<ol><li>从具体细节中综合判断，依据事实和数据</li><li>从点数中发掘有用信息</li><li>对某个点数挖掘别太过度</li><li>采取业绩调查、绩效指标和正式考核等评价工具来记录一个人的所有表现</li></ol></li><li>让学习过程变得开放、有成长性和不断重复<ol><li>绩效指标要清晰公正</li><li>鼓励员工客观反思自己的业绩</li><li>要有全局观</li><li>对业绩考核要从具体案例开始，找出规律，与被考核人一起探究证据以求取共识</li><li>评估人时，你可能犯的两个最大错误是：对自己的评估过度自信，无法取得共识</li><li>达成评估共识不能以等级论</li><li>通过针对错误及其根源的坦诚对话来了解你的员工，也让员工了解你</li><li>确保员工做好工作，不必事无巨细进行监督</li><li>改变是很难的</li><li>通过发现人的缺点来帮人渡过难关</li></ol></li><li>了解人们怎样处事和判断这种处事方式能否取得好结果，这比了解他们做了什么更重要<ol><li>如果一个人工作干得不怎么样，要考虑这是由于学习不够，还是能力不足</li><li>培训和测试一个业绩不佳的员工时，常见的错误在于，只看其是否掌握所需技能，而不是评估他们的能力</li></ol></li><li>如果你跟某人真的就他们的缺点取得共识，这些缺点可能真的存在<ol><li>评判员工时，不必达到“没有一丝疑点”的境界</li><li>用不了一年时间，你就能了解一个人是什么样的人，他们是否适合其岗位</li><li>在员工任职期间持续评估</li><li>要像评估应聘者一样严格评估员工</li></ol></li><li>培训、保护或辞退员工，不要修复(价值观不和或能力不足 )<ol><li>不要让员工尸位素餐。辞退人或重新委派任务不是大事，把一个人留在不适合的岗位上才更糟糕</li><li>准备好“朝你爱的人开枪”(辞退)</li><li>某个人“不适合某个岗位”时，要考虑是否有更适合他的空缺，还是你需要让他们离开公司</li><li>要慎重对待把不称职的员工换到新岗位</li></ol></li><li>换岗是为了人尽其才，有利于整个团队</li><li>不要降低标准</li></ol></li></ol></li><li>严厉的爱最难给，也最重要<ol><li>改进机器的5个原则：<ol><li>树立目标</li><li>发现问题</li><li>诊断并发现问题根源</li><li>设计改进方案并解决问题</li><li>完成任务</li></ol></li><li>像操作一部机器那样进行管理以实现目标<ol><li>从高层面俯视你的机器和你自己</li><li>不断把结果和你的目标进行对照</li><li>出色的管理者就是一家机构的工程师</li><li>制定量化评价工具</li><li>要注意别把精力过多用于应付各种事务，而忽视你的机器</li><li>别被突发事件分散注意力</li></ol></li><li>应对每个问题的手段都要服务于两种目的.<ol><li>让你与目标更为接近</li><li>能够对机器（人和设计）进行培训和测试</li><li>经历的每件事都是一个案例，进行抽象总结归类。</li><li>如果出现问题，要在两个层面进行讨论<ol><li>机器层面（该结果怎样产生）</li><li>案例层面（如何应对）</li></ol></li><li>制定规则时，要解释清楚背后的原则</li><li>你的政策应当是你的原则的自然延伸，以原则为中心。</li><li>尽管好的原则、政策几乎都会提供良好的指南，但要记住每条规则都会有例外</li></ol></li><li>了解管理、微观管理和不管理的区别<ol><li>管理者必须确保自己负责的领域运转有效</li><li>管理你的下属就好比是在“一起滑雪”</li><li>优秀的滑雪者当滑雪教练要比新手当教练强</li><li>你应当把具体工作授权给员工做你应当把具体工作授权给员工做</li></ol></li><li>了解员工及其工作的动力，因为人是你最重要的资源<ol><li>经常了解那些对你和公司重要的人</li><li>对员工的信心应通过了解而来，而不是随意猜测</li><li>根据你的信心大小进行不同程度的调查了解</li></ol></li><li>明确职责<ol><li>记住谁负什么责任</li><li>防止“角色错位”</li></ol></li><li>深入探究你的机器以了解你能从它那里期待些什么<ol><li>获取足够程度的理解,对你所管理的领域和员工了解足够多</li><li>不要保持太远的距离</li><li>利用“每日报告”来了解团队成员的行为和思想</li><li>持续关注以了解问题会不会突然发生</li><li>问责过程要触及你直接下属的下一级</li><li>允许你下属的下属随时越级向你汇报</li><li>别想当然地认为员工的答案都是正确的</li><li>要学会明察秋毫</li><li>让问责过程透明，而非私下问责</li><li>欢迎被问责</li><li>对事物的看法和思维方式截然不同的人，相互间的沟通通常不畅</li><li>不放过一个可疑线索</li><li>解决问题有很多办法</li></ol></li><li>像公司的拥有者那样思考，要求你的同事也这样做<ol><li>休假也不应忘记责任</li><li>强迫自己和员工做困难的事，客服困难，使你和员工都会取得进步。</li></ol></li><li>承认并应对好关键人物风险，防止关键人物离职导致业务运转不顺。</li><li>不要对所有人等同视之，要合理对待、有所区别<ol><li>别轻易被迫让步</li><li>关心员工</li></ol></li><li>优秀的领导一般不是表面上看起来那么简单<ol><li>最有效的领导者的工作目的在于：<ol><li>开明地寻找最佳答案；</li><li>带领他人一道进行寻找</li></ol></li><li>既要弱，又要强</li><li>不要担心你的员工是不是喜欢你，不要让他们告诉你要如何做事, 追寻最好的决策，并有勇气做出决定。</li><li>不要发号施令让别人服从你，要努力为人所理解并理解他人，以达成共识</li></ol></li><li>确保你和你的员工承担相应的责任，也欢迎别人监督你负起责任<ol><li>如果你已经与别人就某事的做法达成一致，要确保其按此操作，除非你们就改变做法已形成共识</li><li>区分两种不同的失败情况，一种是没有遵守约定，第二种是根本没立约定</li><li>避免下沉现象。这是指管理者被迫去做下属的工作，而没有意识到这是一个问题</li><li>当心那些混淆目标和任务的人，因为如果他们分不清楚，你就不能信任他们并给他们委派职责。一种测试方法是：问一个高层次的问题：“目标XYZ的进展如何？”</li><li>当心缺乏重点、徒劳无益的“理论上应当”。并且明确责任人。</li><li>清楚地传达计划，用明确的量化指标对进展予以评估</li></ol></li><li>在无法充分完成职责时，将问题提交给上级解决…让你的下属也积极主动这样做</li></ol></li><li>发现问题，不容忍问题<ol><li>如果你不担心，你就要担心了；如果你担心，你就不必担心</li><li>对机器进行设计和监督，确保能发现哪些事情做得好、哪些不够好，否则就自己动手做<ol><li>指定员工负责发现问题，给他们时间进行审查，确保他们有独立的报告路线能够反映问题，而不必担心揭丑的后果</li><li>当心“温水煮青蛙综合征”</li><li>当心从众心理。即便没有人担心，也不表明没有问题存在</li><li>发现问题时，要把结果与目标相对照，如果结果没有达到目标，很有可能你会一直原地踏步。</li><li>“尝尝汤的味道”，产品给别人用时，首先自己用用。</li><li>尽量让更多双眼睛来寻找问题</li><li>最熟悉工作的人最有发言权</li></ol></li><li>在分析问题时要非常具体，不要泛泛而谈<ol><li>不要用“我们”“他们”这种不指名道姓的说法，以掩盖个人责任</li><li>不要害怕解决难题</li><li>必须理解，那些有良好解决方案的问题不同于没有解决方案的问题</li><li>以机器的方式来发现问题<ol><li>发现问题</li><li>确定谁是解决问题的责任人</li><li>决定什么时间适合进行讨论</li><li>贯彻执行</li></ol></li></ol></li></ol></li><li>诊断问题，探究根源<ol><li>无法准确诊断问题的原因:<ol><li>把遇到的问题当成一时的差错</li><li>不把问题和责任人挂钩</li><li>未能把此次问题和之前的教训联系起来</li></ol></li><li>为了做好诊断，要先问以下问题<ol><li>结果是好是坏？谁对结果负责？</li><li>如果结果不好，是因为责任人能力不够还是机器设计有问题</li><li>机器应该如何运转？(蓝图形式呈现，避免纠结细节)</li><li>机器是在以理想状态运转吗？是或否。如果答案为否，究竟是哪些地方运转不正常？出了什么故障？排查方式也很简单：<ol><li>某人完成任务了么？</li><li>未完成及时向上级反馈了么？</li></ol></li><li>为什么事情没有朝预想的方向发展</li><li>问题的根源是否带有规律性</li><li>在此情况下，员工或机器如何改进？<ol><li>是否有些职责需要分配或进一步澄清？</li><li>是否需要重新对机器进行设计？</li><li>是否要对某些员工的岗位匹配度进行重新评估</li></ol></li><li>进行问题诊断的一些注意事项：<ol><li>问自己：“还有人能以别的方式完成这个工作吗？”</li><li>找出流程中的哪一步出了问题</li><li>找出哪些原则被违反了</li><li>避免“事后诸葛亮”</li><li>不要把某人所处环境的优劣与其应对方法的优劣混为一谈</li><li>要认识到这样的事实，别人不知道怎么做，并不意味着你就能知道怎么做。在检测某个人是否善于解决问题时，要看：（1）他能够逻辑清晰地表达出如何处理相关问题；（2）他曾经在过去成功解决过类似问题。</li><li>问题的根源不是一次行动而是一个原因</li><li>为了分清楚哪些是人手不足的问题，哪些是能力不够的问题，要考虑如果在特定岗位上人手充足会把工作做得如何</li><li>要记住管理者通常出于以下5个原因之一（或更多）而失败或未能达成目标。<ol><li>他们离问题太远。</li><li>他们在辨别低素质、低质量方面能力欠缺。</li><li>他们已经感受不到问题的严重性，因为他们对问题已经习惯了。</li><li>他们对工作太自负（或自我意识过强），不愿意承认解决不了自己的问题。</li><li>他们对承认失败的不利后果感到害怕</li></ol></li></ol></li></ol></li><li>通过持续诊断来保持综合判断的与时俱进，并且诊断应当有成果</li><li>使用如下的“深挖”技巧，对出现问题的部门或下级部门形成一个基于80/20法则的印象<ol><li>列举问题，具体到事情和人</li><li>找出问题的根源，大多数问题都有可能是一下两种原因导致：<ol><li>不清楚谁是责任人</li><li>责任人没有很好地履行职责</li></ol></li><li>制订计划。具体任务，成功，责任人，跟踪考核指标，时间表</li><li>执行计划。定时检查报告。</li></ol></li><li>诊断是实现进步和建立良好人际关系的基础</li></ol></li><li>改进机器，解决问题<ol><li>设计你的机器并使之系统化<ol><li>建造你的机器</li><li>把原则和落实原则的方法系统化<ol><li>认真思考你做决策所依据的标准，据此建造优秀的决策机器</li></ol></li><li>好的计划应该像一部电影脚本<ol><li>让自己一段时间置身于“痛苦的位置”，更深入地理解你为了什么而设计。要亲身经历</li><li>设想其他可能的备选机器及其运行的结果，然后做出选择</li><li>不仅要考虑第一轮的后果，更要考虑第二、第三轮的后果</li><li>定期召开会议，保重要的交流互动和未来规划不被忽略，以及提高效率。</li><li>一部好的机器要考虑人可能并不完美这一因素</li></ol></li><li>设计是一个循环往复的过程，在不满意的“现在”与美好的“未来”之间有一个“不断努力”的阶段</li><li>在设计组织结构时，要围绕目标而不是围绕任务<ol><li>自上而下地建设组织</li><li>每个人都必须由一位具有可信度的、奉行高标准的人来监督</li><li>在设计组织时，运用五步流程是通往成功的捷径，不同员工能在不同步骤发挥良好作用</li><li>不要让一个机构去适应员工</li><li>要考虑机构的规模多大为宜</li><li>按照“万有引力”定律(拥有共同目标)，以最合乎逻辑的办法来划分业务部门及其下属部门</li><li>让各部门尽可能自给自足，以便控制所需的资源</li><li>为保证联络和沟通顺利，高级管理人员与基层管理人员的比例、基层管理人员与其直接下属的比例应当控制在一定范围，一般在1:10-1:5之间</li><li>在设计中要考虑继任计划和培训安排</li><li>不要仅盯着你自己的工作，还要关注如果你不在场，工作会如何开展</li><li>为确保正确完成关键任务，宁要“做两遍“(两个人独立完成同一个任务)而不要“二次确认”(第二个人什么都只是确认，不干活)</li><li>使用顾问要明智，防止过度依赖顾问。聘用顾问时需要考虑的因素：<ol><li>质量控制</li><li>经济上是否划算(招人还是外包)</li><li>知识的体制化</li><li>安全</li></ol></li></ol></li><li>描绘一幅金字塔形的组织架构图，任何两条由塔顶向下连接塔底的线不应产生交叉<ol><li>当遇到跨部门或跨附属部门的问题时，让金字塔交汇点上的人来处理</li><li>不要替别的部门的人完成工作，也不要从其他部门抽人来为你工作，除非你征得该部门管理者的同意</li><li>防止“部门错位”。部门目标和他干的事情偏离</li><li>必要时可建立“护栏”，但最好不要有“护栏”。“护栏”本质上就是帮助员工完成他的本职工作。</li><li>不要指望人们能意识到并消除自己的盲点</li><li>考虑“三叶草”式的设计。类似三个臭皮匠定个诸葛亮</li></ol></li><li>保持战略规划不变，在环境允许的情况下可以进行适当的战术微调<ol><li>不要让权宜之计超越战略目标</li><li>同时考虑大局和细节，理解二者之间的联系</li></ol></li><li>保持适当的监控，让谎言没有可乘之机<ol><li>进行调查并让员工知道你将开展调查</li><li>要知道如果没有警察（审计人员），法律就毫无意义</li><li>当心橡皮图章，意味着你需要对你的审计人员进行审计</li><li>按你的要求花钱的人在花钱上可能会大手大脚</li><li>通过“杀鸡儆猴”阻止不良行为</li></ol></li><li>报告路线和职责描述要尽可能清晰<ol><li>不要根据头衔，而要根据工作流程设计和人员的能力分配职责</li><li>要不断思考如何产生以小博大的杠杆效应，可以参考50:1的效果，即1小时讨论工作，下属要50小时完成。怎么样做的杠杆效果越高，就越成功。</li><li>雇用少数聪明人才并赋予他们最好的技术手段，要远胜于雇用大量普通人并配给一般的技术</li><li>使用助手来提高效率</li></ol></li><li>要知道几乎做每件事所花费的时间和资金都比你预期的要多</li></ol></li></ol></li><li>按既定计划行事<ol><li>朝着令你和你的机构振奋的目标去奋斗<ol><li>要考虑怎样把任务与那些目标挂钩</li><li>协调一致激励大家前行</li><li>别冲动，磨刀不误砍柴工</li><li>寻找有创意、聪颖的解决方案，有时有意想不到的效果</li></ol></li><li>要意识到每个人都忙得不可开交，除了更长时间工作，还可以：<ol><li>通过优先排序或直接拒绝来减少工作量</li><li>授权给合适的人去做</li><li>提高工作效率</li></ol></li><li>不要灰心丧气</li><li>使用检查清单</li><li>要留出时间休整</li><li>鸣钟庆祝；当你和你的团队达成目标，就开始庆祝吧！</li></ol></li><li>运用工具和行为准则指导工作。<ol><li>把系统化的原则嵌入工具对践行创意择优具有特别重要的价值<ol><li>为了促进真正的行为改变，必须内化学习或养成习惯</li><li>利用工具搜集数据，经过处理形成结论和行动</li><li>把原则阐述清楚，运用各种工具和行为准则来推进实施，形成信任、公平的氛围，使任何结论都可以通过跟踪其背后的逻辑和数据来加以评估</li></ol></li></ol></li><li>千万别忽视了公司治理<ol><li>为了取得成功，所有机构都必须建立制衡机制</li><li>即使在创意择优下，靠观点胜出也不是分派责任和权力的唯一决定因素</li><li>要确保公司里没有任何人比体系更强大，也没有任何人重要到不可替代</li><li>当心出现诸侯割据</li><li>设计一个机构的组织架构和规则时，要确保制衡机制能发挥作用</li><li>确保报告路线清晰</li><li>决策权归属要清晰</li><li>要确保从事履职评估的人<ol><li>有时间掌握被评估对象工作情况的全面信息</li><li>有能力实施评估</li><li>有利害冲突阻碍其有效行使监督权</li></ol></li><li>决策者能够接触做决策所需的信息，但必须守信用、妥善安全保管信息</li><li>在创意择优下，CEO单人决策没有集体决策好</li><li>原则、规矩、制衡等组成的治理体系不能取代出色的伙伴关系</li></ol></li><li>与他人合作可得三大益处<ol><li>共同努力比单打独斗能更强、更好地完成既定使命；</li><li>出色的人际关系会造就优秀的团队；</li><li>积累财富以实现和满足我们及他人生活所需</li></ol></li><li>让创意择优发挥作用，需要人们做三件事：<ol><li>坦陈自己最诚实的想法，让大家公开讨论；</li><li>理性地表达分歧，以便大家进行高质量的辩论，拓展思路，尽量形成最优的集体决策；</li><li>用创意择优来处理所有不同意见（例如可信度加权决策）</li></ol></li><li>对工作有益的建议<ol><li>你能将工作和激情有机结合在一起；</li><li>你能与同事为了共同的使命而奋斗，收获成果；</li><li>你能尽情享受奋斗和成果带来的欢乐；</li><li>你将迅速改善和进化，成就斐然</li></ol></li><li>由你自己决定希望从生活中得到什么和给予什么<ol><li>人们在带有情绪(高兴或沮丧)都会导致做出不是最佳的决定。</li></ol></li><li>当形成一定的原则过后，需要一定的工具来帮助自己完成目标。</li></ol><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><p>原则一书，可以说很清晰的阐述了作者在工作和生活中奉行的行为和思考方式。阅读完后，可以看到一套清晰的为人处世的原则框架，公司结构管理框架，对于我而言也是收获颇丰。但是最为关键的是，无论你在个人生活中，还是工作管理中，如果不在实践中思考这些原则，并加以实现，那么本书依旧相当于没有看。反之，如果你在寻找自己的原则，或在实践原则的过程中遇到了疑问，那么本书能够给予你很好的参考。–献给懒惰的我</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;教会你如何建立自己的原则，构建属于完美独特的自我(•̀⌄•́)&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;主题：教你做事&lt;br&gt;
类别：人文社科-&amp;gt;实用性&lt;br&gt;
概要：俗话说的鸡汤书，如果是个能实用的鸡汤书，并且你能照着做，那么就很棒了。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>《贫穷的本质》读书笔记</title>
    <link href="http://yoursite.com/2021/09/21/%E3%80%8A%E8%B4%AB%E7%A9%B7%E7%9A%84%E6%9C%AC%E8%B4%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/09/21/《贫穷的本质》读书笔记/</id>
    <published>2021-09-21T13:31:04.000Z</published>
    <updated>2022-01-07T07:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>看看我为啥这么穷(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>主题： 如题，探究贫穷的本质<br>类别：经济学-&gt;实用性+理论性论述书-&gt;贫穷经济学<br>概要：尝试阐述是什么因素导致的贫穷，穷人的生活究竟如何，怎样的援助才能使穷人脱贫。</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>作者想通过一些例子和实验数据，来表明是什么导致了贫穷，贫穷是否应该援助，怎样的援助或者引导能更加有效。</p><h2 id="主要观点"><a class="header-anchor" href="#主要观点"></a>主要观点</h2><h3 id="贫穷陷阱"><a class="header-anchor" href="#贫穷陷阱"></a>贫穷陷阱</h3><p>如果没有大量的原始投资助其解决这些地方性问题，这些国家很难提高自己的生产力。然而，这些国家却因为贫穷，无法支付投资回报——这就是经济学家们所谓的“贫穷陷阱”</p><ol><li>一个人需要一定的助力才能脱困，但本身贫穷无法产生助力。陷入贫穷循环的“贫穷陷阱”</li><li>人们总能比昨天有更好的收入，因此日子会越过越好，不存“贫穷陷阱”<br><img src="/2021/09/21/《贫穷的本质》读书笔记/%E6%9C%89%E8%B4%AB%E7%A9%B7%E9%99%B7%E9%98%B1%E6%9B%B2%E7%BA%BF.png" alt="拥有贫穷陷阱的收入曲线"><br><img src="/2021/09/21/《贫穷的本质》读书笔记/%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%B4%AB%E7%A9%B7%E9%99%B7%E9%98%B1%E6%9B%B2%E7%BA%BF.png" alt="没有贫穷陷阱的收入曲线"><br>有些地方有些领域存在贫穷陷阱，而有些缺不存在，需要进行合理分析。</li></ol><p>人在摄入不能满足消耗的时候，会陷入“贫穷陷阱”。因为没有吃饱，所以没有力气干活，因为没有力气干活，所以吃不饱。</p><h3 id="为何穷人会穷"><a class="header-anchor" href="#为何穷人会穷"></a>为何穷人会穷</h3><ol><li>穷人们饭都快吃不饱，为何还要买奢侈的食物。每年微量支出的加碘盐都不会买，而是去做其他消费？<ol><li>穷人更注重眼前的利益和享受。（没有向前看的思想）</li><li>穷人教育受限，接收消息受限，很难发现哪些对他们更有益。（没有向前看的机会）</li><li>教育受限，通信受限，限制穷人对有益事务的判断而导致贫穷，而贫穷又会导致教育和通信受限。贫穷陷阱</li></ol></li><li>很多时候，穷人不是不想富有，而是不知道怎么做，或者样儿不想那么费力。</li><li>固化的信念很难得到改变，受教育的程度使得他们很难理解一些有益的事务。</li><li>想改变穷人的观念，要不进行利益上的补足，要不进行思想上的劝导。</li><li>助推和默认选项可以增加某个选项的选择比例。</li><li>穷人和普通人遇到的困扰都相似：缺乏信念，信念不坚定，拖延。</li><li>教育投资<ol><li>父母对子女教育的投资量，有一部分是源于教育的回报量</li><li>教育也需要供给政策和需求政策，或者强制政策</li><li>对于人群种类的划分和固有印象，会导致教育期望偏差，教育资源倾斜。</li><li>要想建立一个能够向每个孩子提供机会的学校体系，首要的一步或许就是，认识到学校的服务对象是其现有的学生，而不是他们可能想要的学生。</li></ol></li><li>穷人每天面临的风险要比富人多许多。</li><li>穷人抵御风险的能力更弱</li><li>穷人的工作种类更加多元化</li><li>越穷的人贷款越难，由于增加信息采集和监督成本，违约后处理的收益率低。</li><li>穷人的自我控制能力越弱，因为满足自己的欲望需要的代价更大。比如吃一顿好的。</li><li>三大问题：意识形态、无知和惯性。</li><li>良政和良策相辅相成</li></ol><h3 id="总结"><a class="header-anchor" href="#总结"></a>总结</h3><p>导致穷人贫困的几个方面：</p><ol><li>穷人通常缺少信息来源，相信那些错误的事情。</li><li>穷人肩负着生活中的多种责任。</li><li>一些服务于穷人的市场正在消失，或是在这些市场中，穷人处于不利地位。</li><li>贫穷的国家因为贫穷或其不堪回首的历史而丧失改革信心和意识。</li><li>人们很难拥有改变自身的意识和决心。</li></ol><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><p>导致贫穷的原因有非常的多，这里主要讲了一些导致贫穷的普遍原因：比如环境因素，抗风险的能力，无知，惯性和意识形态等问题。<br>但这里针对的普遍是极度贫困的那么一群人，虽然中产阶级依旧存在无知，惯性和意识形态问题，但是相对来说，有了更强的抗风险能力，有一定的知识积累，和有机会越过贫困陷阱的s型曲线。但对于中产来说，更多是拥有一定的收入，能有较好的生活物质条件，能够有基本的医疗和意外保障。但是大部分却没有机会积累资产，或者只是积累少额固定资产，让资产产生更多的价值，或许这也是他们停留在中产的原因吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看看我为啥这么穷(•̀⌄•́)&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;主题： 如题，探究贫穷的本质&lt;br&gt;
类别：经济学-&amp;gt;实用性+理论性论述书-&amp;gt;贫穷经济学&lt;br&gt;
概要：尝试阐述是什么因素导致的贫穷，穷人的生活究竟如何，怎样的援助才能使穷人脱贫。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="经济" scheme="http://yoursite.com/tags/%E7%BB%8F%E6%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>使用nginx搭建linux的http代理</title>
    <link href="http://yoursite.com/2021/08/23/%E4%BD%BF%E7%94%A8nginx%E6%90%AD%E5%BB%BAlinux%E7%9A%84http%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2021/08/23/使用nginx搭建linux的http代理/</id>
    <published>2021-08-23T10:26:25.000Z</published>
    <updated>2022-01-07T07:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>想在linux上使用http代理，方便拉代码和装软件依赖。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><a id="more"></a><h2 id="序"><a class="header-anchor" href="#序"></a>序</h2><p>首先你需要准备一个能够访问外网的服务器，作为流量跳板使用。如果没有，可以去买一个。<br>搭建代理就两步：</p><ol><li>在服务器上安装配置nginx</li><li>配置linux客户端上的proxy代理。</li></ol><h2 id="服务端"><a class="header-anchor" href="#服务端"></a>服务端</h2><p>别人写的挺好的，我就不抄了。如果你想实际从源码编译，可以参考下面的链接：<br><a href="https://lvjianzhao.gitee.io/lvjianzhao/2020/06/25/%E9%85%8D%E7%BD%AEnginx%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener">配置nginx正向代理</a><br><a href="https://blog.csdn.net/luChenH/article/details/107553493" target="_blank" rel="noopener">nginx 正向代理https配置</a></p><p>我这里提供一下我编译好的nginx包：<br>centos7.5:  <a href="/download/nginx_centos.tar.gz">nginx_centos</a><br>Ubuntu 7.3:  <a href="/download/nginx_ubuntu.tar.gz">nginx_ubuntu</a></p><p>对应的配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">user www-data;</span><br><span class="line">worker_processes auto;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line">#include /etc/nginx/modules-enabled/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">worker_connections 768;</span><br><span class="line"># multi_accept on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">sendfile on;</span><br><span class="line">tcp_nopush on;</span><br><span class="line">tcp_nodelay on;</span><br><span class="line">keepalive_timeout 65;</span><br><span class="line">types_hash_max_size 2048;</span><br><span class="line"># server_tokens off;</span><br><span class="line"></span><br><span class="line"># server_names_hash_bucket_size 64;</span><br><span class="line"># server_name_in_redirect off;</span><br><span class="line"></span><br><span class="line">include /etc/nginx/mime.types;</span><br><span class="line">default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">access_log /var/log/nginx/access.log;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line"></span><br><span class="line">gzip on;</span><br><span class="line"></span><br><span class="line">#set http and https proxy</span><br><span class="line">server &#123;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    resolver_timeout 5s;</span><br><span class="line">    listen 7080;</span><br><span class="line"></span><br><span class="line">    proxy_connect;</span><br><span class="line">    proxy_connect_allow            all;</span><br><span class="line">    proxy_connect_connect_timeout  10s;</span><br><span class="line">    proxy_connect_read_timeout     10s;</span><br><span class="line">    proxy_connect_send_timeout     10s;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass $scheme://$host$request_uri;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_buffers 256 4k;</span><br><span class="line">        proxy_max_temp_file_size 0;</span><br><span class="line">        proxy_connect_timeout 30;</span><br><span class="line">        proxy_cache_valid 200 302 10m;</span><br><span class="line">        proxy_cache_valid 301 1h;</span><br><span class="line">        proxy_cache_valid any 1m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端"><a class="header-anchor" href="#客户端"></a>客户端</h2><p>非常简单，设置环境变量就行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://xxx.xxx.xxx.xxx:7080</span><br><span class="line">export https_proxy=http://xxx.xxx.xxx.xxx:7080</span><br></pre></td></tr></table></figure><h3 id="观点2"><a class="header-anchor" href="#观点2"></a>观点2</h3><h3 id="观点3"><a class="header-anchor" href="#观点3"></a>观点3</h3><h2 id="其他"><a class="header-anchor" href="#其他"></a>其他</h2><p><strong>参考：</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想在linux上使用http代理，方便拉代码和装软件依赖。&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="技术杂谈" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>《go语言程序设计》读书笔记</title>
    <link href="http://yoursite.com/2021/08/03/%E3%80%8Ago%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/08/03/《go语言程序设计》读书笔记/</id>
    <published>2021-08-03T13:47:48.000Z</published>
    <updated>2022-01-07T07:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>传说中的go语言圣经，得看一看(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>主题：GO语言学习<br>类别：计算机-&gt;实用性+理论性论述书-&gt;golang<br>概要：从语法，特性，接口，工具，测试等方面系统性介绍go语言。总体来说是针对语言本身特性来进行介绍的。</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>最近在设计一个项目的框架，所使用的就是golang语言，期望多看看书以及学习一些源码，从而有更优雅的架构设计。<br>书中有许多的练习程序，手动写代码，跑程序也是很重要的。</p><h2 id="主要内容"><a class="header-anchor" href="#主要内容"></a>主要内容</h2><p>太过于基础的语法，并不会在笔记中出现，这里主要记录一些go语言编写中需要注意的点。</p><h3 id="基础语法"><a class="header-anchor" href="#基础语法"></a>基础语法</h3><p>主要包含一些语法和关键语句特性相关内容。</p><ol><li><p>如果传参使用<code>map</code>或者<code>slice</code>实际传递的是引用的拷贝，也就是指针的拷贝，那么函数里对map的操作对调用者来说也是可见的。比如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertMap</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    m[<span class="number">1</span>] = <span class="string">"1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>switch</code>中的值会和每一个<code>case</code>进行比较，直到找到匹配的值。因此不要在<code>case</code>中放耗时的操作。<code>select</code>也是同样如此。</p></li><li><p>短变量声明一般用作局部变量中。示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in,err := os.Open(file)<span class="comment">//声明两个变量in,err</span></span><br><span class="line">out,err := os.Open(out)<span class="comment">//声明变量out，赋值变量err</span></span><br><span class="line">out,err := os.Open(out1)<span class="comment">//报语法错误</span></span><br></pre></td></tr></table></figure></li><li><p>多重赋值的时候，会先完全计算完右边的值，再赋值给左边。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x,y = x-y, x+y<span class="comment">//可以完全得到预想的值，即x=x[旧]-y[旧], y=x[旧]+y[旧]</span></span><br></pre></td></tr></table></figure></li><li><p>字符串<code>string</code>是不可变字节序列，不可越界，不可修改，运算只能产生新的变量，而非修改原有值。</p></li><li><p>无类型常量<code>const</code>往往拥有更高的精度和更广的取值范围，并且能够适用于很多地方。</p></li><li><p>数组的长度也是数组类型的一部分。</p><ol><li>数组初始化：</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q := [...]int&#123;1,2&#125;//同r类型，...会自己根据初始化数据个数填入</span><br><span class="line">r := [2]int&#123;1,2&#125;</span><br><span class="line">c := [...]int&#123;99:-1&#125;//len(c)=100, 除去c[99] = -1，其他都是0</span><br></pre></td></tr></table></figure></li><li><p>数组直接传递，是值传递，不同其他语言是引用传递。如果想使用引用传递，需要定义成指针类型：<code>func zero(a *[32]int)</code></p></li><li><p><code>slice</code>为空的判断，使用<code>len(s) == 0</code> 而不是<code>s == nil</code></p></li><li><p>go语言有可变长度的栈，最大可以达到1G，能更加安全的使用递归</p></li><li><p><code>defer</code>函数的实际执行顺序以调用顺序的倒叙执行。</p><ol><li>当发生<code>panic</code>时，所有<code>defer</code>也将以倒叙执行。</li></ol></li><li><p>内置函数<code>recover</code>只能在<code>defer</code>中调用，并且当发生<code>panic</code>时能终止当前的宕机，并且从发生<code>panic</code>的位置正常返回(不会往下执行)。</p><ol><li>通常情况下，不建议在<code>recover</code>中进行程序恢复，这样更容易掩盖程序中的bug</li><li>常用<code>recover</code>的方式是提供一些更加有用的信息。</li></ol></li></ol><h3 id="函数及变量作用域"><a class="header-anchor" href="#函数及变量作用域"></a>函数及变量作用域</h3><ol><li><p>作用域：</p><ol><li>整个程序级别：<code>int</code>, <code>new</code>等内置类型或函数</li><li>包级别：同一个包的任何地方引用，比如包里的全局变量</li><li>文件级别：只有导入了该包才能使用的。比如<code>fmt.Print</code></li><li>块儿级别：函数内部，循环内部等。</li></ol></li><li><p>函数作为参数的时候，传递的作用域问题，本质上函数参数传递的是指针，那么使用的时候也是直接使用指针指向的函数，只要指针本身有效(不是野指针)，函数都能正常执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := SendVar&#123;</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   func_scope.CallBack(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"inner call back func"</span>, s.inner, s.Out)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;)</span><br><span class="line">   func_scope.CallBack(<span class="built_in">print</span>) </span><br><span class="line">   func_scope.CallBack(s.<span class="built_in">print</span>) <span class="comment">//这里如果，s对象不存在了过后，容易导致函数指针读取错误。导致panic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s SendVar)</span> <span class="title">print</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"call back print func"</span>, s.inner, s.Out)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"call back print func"</span>, i)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同第三点所说，当结构体作为参数的时候，其他包是否有权限读取内部变量。类似json这种结构体中的内部变量就不会进行转换。实际上，直接读取肯定是无法读取的，写代码都编译不过。但可以通过反射获取，示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   vs := var_scope.VS&#123;Out: <span class="number">1</span>&#125;</span><br><span class="line"> fmt.Println(<span class="string">"Print var_scope VS"</span>, vs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var_scope包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VS <span class="keyword">struct</span> &#123;</span><br><span class="line">   Out   <span class="keyword">int</span></span><br><span class="line">   inner <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这种情况会输出：<code>Print var_scope VS {1 0}</code>，意思是<code>fmt.Println</code>可以读取到包内部变量。实际看源码我们发现，在<code>fmt.Println</code>中实际使用<code>reflect.Value.Int()</code>函数直接获取值(其他类型有对应转换函数)，是能获取到内部变量的，如果使用<code>reflect.Value.Interface()</code>来获取值，就会进行安全检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> safe &amp;&amp; v.flag&amp;flagRO != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Do not allow access to unexported values via Interface,</span></span><br><span class="line"><span class="comment">// because they might be pointers that should not be</span></span><br><span class="line"><span class="comment">// writable or methods or function that should not be callable.</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"reflect.Value.Interface: cannot return value obtained from unexported field or method"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们看下面的示例：<br>var_scope包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintOtherStruct</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   val := reflect.ValueOf(data)</span><br><span class="line">   typeOfTstObj := val.Type()</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; val.NumField(); i++ &#123;</span><br><span class="line">      fieldType := val.Field(i)</span><br><span class="line">      <span class="comment">//fieldType.Interface() 函数提示不能返回域外的值的panic，可以通过CanInterface函数来判断</span></span><br><span class="line">      <span class="comment">//fieldType.Int() 直接转换成对应类型的值，不会检测。</span></span><br><span class="line">      fmt.Printf(<span class="string">"object field %d key=%s value=%v type=%s \n"</span>,</span><br><span class="line">         i, typeOfTstObj.Field(i).Name, fieldType.Int(),</span><br><span class="line">         fieldType.Type())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">"var scope print"</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SendVar <span class="keyword">struct</span> &#123;</span><br><span class="line">   Out   <span class="keyword">int</span></span><br><span class="line">   inner <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := SendVar&#123;</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   var_scope.PrintOtherStruct(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>匿名函数，func关键字后没有变量的函数，例如：<code>strings.Map(func(r rune) rune{return r + 1}, &quot;HAL-9000&quot;)</code>。匿名函数有一些特性</p><ol><li>匿名函数能够获取到整个词法环境，里层能够使用外层的变量。</li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func squares() func() int &#123;</span><br><span class="line">   var x int</span><br><span class="line">   return func() int &#123;</span><br><span class="line">      x++</span><br><span class="line">      return x * x</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   f := squares()</span><br><span class="line">   fmt.Println(f()) //1</span><br><span class="line">   fmt.Println(f()) //4</span><br><span class="line">   fmt.Println(f()) //9</span><br><span class="line"></span><br><span class="line">   f2 := squares()</span><br><span class="line">   fmt.Println(f2()) //1</span><br><span class="line">   fmt.Println(f2()) //4</span><br><span class="line">   fmt.Println(f2()) //9</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的匿名函数是能够使用外层的变量x的。并且变量x在调用<code>squares</code>返回后亦然存在(虽然是隐藏在变量f中，有点像<code>var x int; func()int{...}</code>整个一体为<code>f</code>变量一样)。<br>2. 匿名函数作为递归，必须先申明再赋值，直接声明赋值会导致未定义错误：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">visitAll := func(items []string)&#123;</span><br><span class="line">   //...</span><br><span class="line">   visitAll(m[item]) //compile error: undefind visitAll</span><br><span class="line">   //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>匿名函数在for循环中的外部变量引用，先看示例：</li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var rmdirs []func()</span><br><span class="line">dirs := tmpdirs()</span><br><span class="line">for i:=0;i&lt;len(dirs);i++&#123;</span><br><span class="line">   //a := i //后面os.RemoveAll(dirs[i])替换为os.RemoveAll(dirs[a])才正确</span><br><span class="line">   os.MkdirAll(dirs[i],0755)</span><br><span class="line">   rmdirs = append(rmdirs, func()&#123;</span><br><span class="line">      os.RemoveAll(dirs[i])//不正确</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环里(指<code>for</code>开始到<code>{</code>中间)创建的变量，都是共享相同的变量，意味着匿名函数在使用的时候都是指向的一个地方。而如果内部声明的变量,如<code>a:=i</code>里的<code>a</code>则每次都会声明一个变量，隐藏在匿名函数中，而不会释放。</p></li><li><p>指针类型成员函数，使用非指针类型成员也能正常调用，golang会自动对指针和指针指向的值进行转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span>&#123;</span><br><span class="line">   Num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span>&#123;</span><br><span class="line">   A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span><span class="title">set</span><span class="params">(num <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   a.Num = num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := A&#123;&#125;</span><br><span class="line">   a.set(<span class="number">222</span>)</span><br><span class="line">   fmt.Printf(<span class="string">"A:%v\n"</span>,a)</span><br><span class="line">   b := B&#123;&#125;</span><br><span class="line">   b.set(<span class="number">11</span>)</span><br><span class="line">   fmt.Printf(<span class="string">"B:%v\n"</span>,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A:&#123;222&#125;</span><br><span class="line">B:&#123;&#123;11&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="接口和反射"><a class="header-anchor" href="#接口和反射"></a>接口和反射</h3><ol><li><p><code>nil</code>也可以作为类方法的接收者，比如<code>var a *NewStruct= (* NewStruct)(nil)</code>，但是通常不会这样使用。</p></li><li><p>接口就是提取一系列具体类型的共性而构成的。很多的常用系统函数都是提供接口值传递，支持自定义的类型传递(实现接口就行)。</p></li><li><p>接口值由两部分组成：类型和动态值。</p><ol><li>如果动态值可以比较(不是map或者slice这类)，那么接口值也是可以比较的。</li><li><code>var w *io.writer = os.Stdout</code>。接口值里的类型是<code>*os.File</code>，对应值是<code>&amp;os.File{fd=1}</code></li><li>注意含有空指针的非空接口：</li></ol>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a *os.File</span><br><span class="line">   check(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(w *io.writer)</span></span>&#123;</span><br><span class="line">   <span class="comment">//注意，这个地方传入的w，其接口值不为空。因为接口值存在非空类型值`*os.File`</span></span><br><span class="line">   <span class="keyword">if</span> w == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"w is nil"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>error</code>是一个接口，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span>&#123;</span><br><span class="line">   Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>断言：<code>f, ok := x.(T)</code></p></li><li><p>有些函数包可以通过断言<code>error</code>的类型来判断错误类型。</p></li><li><p>可以通过断言来判断某个接口里是否包含某个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeString</span><span class="params">(w *io.Writer, s <span class="keyword">string</span>)</span><span class="params">(<span class="keyword">int</span>, error)</span></span>&#123;</span><br><span class="line">   <span class="keyword">type</span> stringWriter <span class="keyword">interface</span>&#123;</span><br><span class="line">      WriteString(<span class="keyword">string</span>)(<span class="keyword">int</span>, error)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> sw, ok := w.(WriteString); ok&#123;</span><br><span class="line">      <span class="keyword">return</span> sw.WriteString(s)</span><br><span class="line">   &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反射<code>reflect</code></p><ol><li>反射由两部分构成：Type和Value。对应着interface的类型值和类型值(实际数据)</li></ol>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个反射的示例</span></span><br><span class="line"><span class="keyword">package</span> goreflectexample</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"reflect"</span></span><br><span class="line">   <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatAtom</span><span class="params">(v reflect.Value)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">   <span class="keyword">case</span> reflect.Invalid:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Invalid"</span></span><br><span class="line">   <span class="keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16,</span><br><span class="line">      reflect.Int32, reflect.Int64:</span><br><span class="line">      <span class="keyword">return</span> strconv.FormatInt(v.Int(), <span class="number">10</span>)</span><br><span class="line">   <span class="comment">//....简化起见，省略浮点数和复数</span></span><br><span class="line">   <span class="keyword">case</span> reflect.Bool:</span><br><span class="line">      <span class="keyword">return</span> strconv.FormatBool(v.Bool())</span><br><span class="line">   <span class="keyword">case</span> reflect.String:</span><br><span class="line">      <span class="keyword">return</span> v.String()</span><br><span class="line">   <span class="keyword">case</span> reflect.Chan, reflect.Func, reflect.Ptr,</span><br><span class="line">      reflect.Slice, reflect.Map:</span><br><span class="line">      <span class="keyword">return</span> v.Type().String() + <span class="string">" 0x"</span> +</span><br><span class="line">         strconv.FormatUint(<span class="keyword">uint64</span>(v.Pointer()), <span class="number">16</span>)</span><br><span class="line">   <span class="keyword">default</span>: <span class="comment">//reflect.Array, reflect.Struct, reflect.Interface</span></span><br><span class="line">      <span class="keyword">return</span> v.Type().String() + <span class="string">" value"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(path <span class="keyword">string</span>, v reflect.Value)</span></span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">   <span class="keyword">case</span> reflect.Invalid:</span><br><span class="line">      fmt.Printf(<span class="string">"%s = Invalid\n"</span>, path)</span><br><span class="line">   <span class="keyword">case</span> reflect.Slice, reflect.Array:</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.Len(); i++ &#123;</span><br><span class="line">         display(fmt.Sprintf(<span class="string">"%s[%d]\n"</span>, path, i), v.Index(i))</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">case</span> reflect.Struct:</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">         feildPath := fmt.Sprintf(<span class="string">"%s.%s"</span>, path, v.Type().Field(i).Name)</span><br><span class="line">         display(feildPath, v.Field(i))</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">case</span> reflect.Map:</span><br><span class="line">      <span class="comment">// 另外一个遍历map的方式</span></span><br><span class="line">      <span class="comment">// iter := v.MapRange()</span></span><br><span class="line">      <span class="comment">// for iter.Next() &#123;</span></span><br><span class="line">      <span class="comment">// k := iter.Key()</span></span><br><span class="line">      <span class="comment">// va := iter.Value()</span></span><br><span class="line">      <span class="comment">// display(fmt.Sprintf("%s[%s]\n", path, formatAtom(k)), va)</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> _, key := <span class="keyword">range</span> v.MapKeys() &#123;</span><br><span class="line">         display(fmt.Sprintf(<span class="string">"%s[%s]\n"</span>, path, formatAtom(key)), v.MapIndex(key))</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">case</span> reflect.Ptr:</span><br><span class="line">      <span class="keyword">if</span> v.IsNil() &#123;</span><br><span class="line">         fmt.Printf(<span class="string">"%s = Nil\n"</span>, path)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">         fmt.Printf(<span class="string">"%s.type = %s\n"</span>, path, v.Elem().Type())</span><br><span class="line">         display(path+<span class="string">".value"</span>, v.Elem())</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">default</span>: <span class="comment">// 基本类型、通道、函数</span></span><br><span class="line">      fmt.Printf(<span class="string">"%s = %s\n"</span>, path, formatAtom(v))</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Display</span><span class="params">(name <span class="keyword">string</span>, x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"Display %s (%T)\n"</span>, name, x)</span><br><span class="line">   display(name, reflect.ValueOf(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，上述函数还有优化点，对于多处字符串<code>+</code>的操作，使用<code>bytes.Buffer</code>则更能提升性能。<br>2.  我们可以通过<code>(Value).Set</code>函数来对可寻址的变量进行赋值。是否可寻址(获取变量指针)可以用<code>(Value).CanAddr()</code>来确定。当然也可以通过取地址+断言的方式来获取指针，进行赋值:<code>px := x.Addr().Interface().(*int); *px=3</code><br>3.  反射可以获取到未导出字段的值，但是不能通过反射来更新这些值。<br>4.  可以通过反射获取<code>结构体字段标签</code>比如json中使用的<code>json:&quot;name&quot;</code>可以通过<code>reflect.StructField.Tag.Get(&quot;json&quot;)</code>来获取相应的值。<br>5.  可以通过反射获取相应方法：<code>(Value).Method(i)</code>，函数数量可以通过<code>(Value).NumMethod()</code>来获取。</p></li><li><p>使用反射的注意事项(总结：没有必要用反射，就不要用反射)：</p><ol><li>反射代码是很脆弱的，很容易出bug，并且bug是在遇到对应类型的时候以<code>panic</code>的方式抛出。</li><li>反射无法做静态类型检测，特别是<code>interface{}</code>或<code>reflect.Value</code>参数时，一定要说明参数访问和其他限制。并且大量使用反射也不便于理解。</li><li>使用反射是比特定类型优化的函数低一两个数量级。有些关键性的核心函数，还是要避免使用反射。</li></ol></li><li><p><code>unsafe</code>包中包含了许多接近底层的一些操作，当然这些操作在C语言里面可能是常见的。如果不是很有必要，并不建议使用unsafe包，unsafe包会导致更不易察觉的错误，以及削弱代码可移植性。</p><ol><li><code>unsafe.Pointer</code>指向一个<code>T</code>类型的指针，类似C里的<code>void *</code>。<code>unsafe.Pointer</code>可以转换为<code>uintptr</code>,然后对指针进行数值计算。但是注意如果使用<code>uintptr</code>作为中间变量，由于其类型为一个数据，那么其对应的值所指向的值可能被垃圾回收移动或者回收，导致不易发现的错误。如：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pT := <span class="keyword">uintptr</span>(unsafe.Poniter(<span class="built_in">new</span>(T))) <span class="comment">//语句执行后，创建的T就要被回收，pT值就变成野指针。</span></span><br></pre></td></tr></table></figure><p>如果要使用uintptr，需要谨慎使用，保证使用的最小范围。</p></li><li><p><code>reflect.DeepEqual</code>深度比较，会进行两个任意数据的类型，长度，和数据的比较。</p></li><li><p>在<strong>接口</strong>上调用方法时，必须有和方法定义时相同的接收者类型或者是可以根据具体类型 <code>P</code> 直接辨识的：</p><ul><li>指针方法可以通过指针调用</li><li>值方法可以通过值调用</li><li>接口接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li><li>接口接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li></ul></li></ol><h3 id="goroutine和通道"><a class="header-anchor" href="#goroutine和通道"></a>goroutine和通道</h3><ol><li><p>协程之间是没有父子关系的，所有子协程都是一个等级，挂在main函数下。</p><ol><li>父协程退出，子协程不会退出</li><li>函数退出，函数内的协程不会退出(main函数除外)</li></ol></li><li><p>管道类型<code>chan T</code>和<code>map</code>类似，传递都是进行指针传递。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x, ok := &lt;- ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">   fmt.Fatal(<span class="string">"channel closed."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>管道可以手动关闭(也可以让gc自己回收)，关闭后任何向管道里写入的操作都会崩溃，读取操作能够正常执行，读取完管道值后再读取的值就会零值。</li><li>单向通道：类型<code>chan&lt;- T</code>只能发送的的通道，类型<code>&lt;-chan T</code>只能接收的通道。类型<code>chan T</code>传值给单向通道的时候，都会进行隐式转换到相应的结构。</li><li>带有缓冲的通道，通道的数据存取类似于管道，先进先出。如果粗暴的在一个goroutine中将管道作为队列使用，可能会出现永久阻塞的风险。</li><li>在<code>select</code>中，如果通道是<code>nil</code>，则改分支永远不会被选中，该特性可以用来启用或禁用某些特性。</li><li>可以在goroutine中使用管道作为令牌桶，控制goroutine的并发量：</li></ol>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tokens := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++&#123;</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> tokens &lt;- <span class="keyword">struct</span>&#123;&#125;: <span class="comment">//获取令牌</span></span><br><span class="line">         <span class="keyword">case</span> &lt;-done: <span class="comment">//用于控制进程取消操作。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; &lt;- tokens &#125;() <span class="comment">//释放令牌</span></span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">   &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不要通过共享内存来通信，应该使用通信来共享内存。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deposits = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//存钱</span></span><br><span class="line"><span class="keyword">var</span> balances = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//查余额</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(mony <span class="keyword">int</span>)</span></span> &#123; deposits &lt;- mony &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> &lt;-balances&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">teller</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> balance <span class="keyword">int</span> <span class="comment">//限制在一个goroutine内，不会读写冲突</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> mony := &lt;-deposits:</span><br><span class="line">            balance += mony</span><br><span class="line">         <span class="keyword">case</span> balances &lt;- balance:</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun init()&#123;</span><br><span class="line">   <span class="keyword">go</span> teller() <span class="comment">//启动teller</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>避免数据读写冲突的方法：</p><ol><li>初始化后，变量只读</li><li>避免多个<code>goroutine</code>访问同一变量。比如30的例子，用管道通信的方式，避免了多<code>goroutine</code>的同时读写。</li><li>使用互斥锁。</li></ol></li><li><p>读写锁只有在竞争激烈时效果才比一般锁好，单个执行是不如一般锁，这是由于读写锁实现更复杂。</p></li><li><p>一些导致并行数据冲突的原因：</p><ol><li>读写冲突导致</li><li>cpu缓存会导致并发的时候读到错误的缓存值，而锁操作可以把缓存刷入内存。多核cpu会分配并发线程到不同cpu，而每个cpu都有自己的缓存，会读到过期的数据</li><li>并行程序在相互之间没有变量逻辑关联的时候，编译器可能会交换执行顺序。</li></ol></li><li><p>延迟互斥初始化<code>sync.Once</code></p><ol><li>一种延迟初始化的示例：</li></ol>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> memo <span class="keyword">struct</span>&#123;</span><br><span class="line">   mem <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">   mu sync.Mutex</span><br><span class="line">   ready <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">//mem 准备好后关闭</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *memo)</span><span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   m.mu.Lock()</span><br><span class="line">   <span class="keyword">if</span> m.mem == <span class="literal">nil</span>&#123;</span><br><span class="line">      <span class="comment">//假设初始化的时候没有进行make</span></span><br><span class="line">      <span class="comment">//第一次get数据时，进行初始化。</span></span><br><span class="line">      m.mem = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">      m.mu.Unlock()</span><br><span class="line">      <span class="built_in">close</span>(m.ready)<span class="comment">//广播数据准备完毕，并且只需要广播一次。</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      m.mu.Unlock()</span><br><span class="line">      <span class="comment">//由于第一次广播数据时，关闭了消息，后续的访问，都不会阻塞。</span></span><br><span class="line">      &lt;-m.ready</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> m.mem[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以使用竞态检测器<code>race deleteor</code>来检测代码中是否有数据竞态的情况。使用方法在编译时增加<code>-race</code>参数</p></li><li><p>goroutine和线程的差别</p><ol><li>goroutine有可增长的栈，而OS里的线程一般只有固定大小的2MB。goroutine栈的增长也是以2倍增长，通常初始值在2KB，最大一般可以到1GB</li><li>线程调度需要涉及到CPU上下文切换，而goroutine调度通常是由go调度器处理，而调度技术成为<code>m:n调度</code>(把m个goroutine调度到n个线程)</li><li>goroutine没有标识，而OS线程通常都有线程标识。</li></ol></li><li><p><code>GOMAXPROCS</code>值表示：使用多少个OS线程来执行goroutine。正在休眠的goroutine不占用线程，阻塞IO、其他系统调用执行中或非go语言写的函数这些goroutine需要一个独立的OS线程。</p></li></ol><h3 id="测试"><a class="header-anchor" href="#测试"></a>测试</h3><ol><li><p>测试函数比如导入<code>testing</code>包，除去开头函数，可选后缀必须大写开头。</p></li><li><p>测试部分的代码，通常使用<code>_test.go</code>来进行区分，而包通常在一个里。</p></li><li><p>测试中<code>-run</code>命令后面跟的是正则表达式，运行匹配的函数。匹配字符里，可以忽略<code>Test</code>头</p></li><li><p>测试中的<code>t.Fatal</code>函数必须he<code>Test</code>在同一个<code>goroutine</code>中。错误消息的一般格式&quot;f(x)=y, want z&quot;</p></li><li><p>随机测试，构建符合模式的随机输入，来探测程序的边界。</p></li><li><p>测试程序和被测试程序，虽然都定义在一个包里，但是实际执行<code>go test</code>和执行主程序时，都是分开的。</p></li><li><p>测试程序中，不要调用<code>log.Fatal</code>或<code>os.Exit</code>，这些调用会阻止跟踪的过程。通常认为这两个是main函数的特权调用。</p></li><li><p>白盒测试可以通过修改一些全局量来达到测试部分功能的目的，比如代码中使用了全局函数指针<code>var sendMsg = fun(string) error{...}</code>，我们可以在白盒测试中修改改指针，来避免发送出错。</p></li><li><p>外部测试包，通常用于外部调用来测试相应包，无法访问包内部变量（会单独存在一个包，package命名使用<code>&lt;package&gt;_test</code>）。其他则和内部测试相同。</p></li><li><p>有时候，外部测试包需要拥有对内部包的特殊访问权限，我们可以约定声明一个特殊的测试文件<code>export_test.go</code>，而其存放的内容，仅仅是把包内部功能暴露。如<code>fmt</code>包中的<code>export_test.go</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"><span class="keyword">var</span> IsSpace = isSpace</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>如果我们要看我们自己编写的测试程序覆盖了多少源码，可以使用<code>go test -coverprofile=c.out ./</code>来查看。使用<code>go tool cover</code>可以查看<code>cover</code>的帮助。c.out会输出程序中哪些代码被覆盖，哪些没覆盖。</p></li><li><p>基准测试<code>Benchmark</code>，执行命令<code>go test -bench=&lt;name&gt;</code>，同样<code>&lt;name&gt;</code>使用正则匹配。如果不指定<code>-bench</code>，则不执行基准测试。<code>-benchmem</code>可以看到内存的操作消耗。详细测试可<a href="https://geektutu.com/post/hpg-benchmark.html" target="_blank" rel="noopener">参考</a></p></li><li><p>我们可以通过<code>go test</code>做代码的性能剖析，不同的报告类别告诉我们不同的性能情况：</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test -cpuprofile=cpu.out <span class="comment">//CPU占用</span></span><br><span class="line"><span class="keyword">go</span> test -blockprofile=block.out <span class="comment">//阻塞操作</span></span><br><span class="line"><span class="keyword">go</span> test -memprofile=mem.out <span class="comment">//内存占用</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">一个显示CPU性能的示例：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="keyword">go</span> test -run=NONE -bench=ClientServerParallelTLS64 -cpuprofile=cpu.log net/http</span><br><span class="line"><span class="keyword">go</span> tool pprof -text -nodecount=<span class="number">10</span> ./http.test cpu.log</span><br></pre></td></tr></table></figure><p>其中<code>http.test</code>是执行<code>go test</code>时产生的中间文件(如果<code>go test</code>不带性能分析参数，那么就会删掉该中间文件) <code>-nodecount=10</code>限制输出10行</p></li><li><p><code>Example</code>函数也会被<code>go test</code>视为特殊函数。该函数必须通过语法编译，并且会关联<code>Example</code>同名后缀的函数，并在文档中以示例的方式展示。也可以执行<code>Example</code>函数，并且<code>go test</code>会自动将执行结果，和你函数最后的带有<code>// 输出：</code>后的注释进行比较，判断输出正确性。</p></li></ol><h3 id="环境及工具"><a class="header-anchor" href="#环境及工具"></a>环境及工具</h3><ol><li>工作空间<code>GOPATH</code>依赖的源码，现在通常都是通过<code>go mod</code>来进行管理。环境变量<code>GOROOT</code>，指定go的版本。<code>go env</code>能配置这些变量。</li><li>进行<code>go build</code>时，后面的相对路径前必须加<code>./</code>或<code>../</code>之类的，否则就会识别为参数。</li><li><code>go build</code>和<code>go install</code>非常相似，区别在于<code>go install</code>不会丢弃编译代码和命令。它们对于没有修改过的包都不会进行重新编译。</li><li>可以通过<code>go doc</code>来查看函数结构体等声明和注释，使用方法:<code>go doc time</code>, <code>go doc time.Since</code>等。当然我们自己也在包开发的时候也鼓励编写函数和包注释。</li><li><code>godoc</code>和<code>go doc</code>功能一样，差别在于提供http的服务供网页查看。如<code>godoc -http :8000</code>。<code>-analysis=type</code>和<code>-analysis=pointer</code>提供更丰富的文档。</li><li>内部包是以<code>internal</code>为父目录的目录下的包，只能提供给<code>internal</code>的父目录使用，其他地方无法使用。</li><li><code>go list</code>可以进行可用包的查询，<code>...</code>为通配符。<code>-json</code>参数可以让包已json格式输出，<code>-f</code>可以通过<code>text/template</code>模板来定义输出格式。</li><li>go的标准文件和<code>_test.go</code>文件在<code>go test</code>时会分成两个包进行编译。你可以通过<code>go list -json &lt;package&gt;</code>来查看包里的构成，<code>GoFiles</code>包含的内容在<code>go build</code>时用到，而<code>TestGoFiles</code>则只会在<code>go test</code>的时候用到。``XTestGoFiles`通常指外部测试列表</li><li>包的空导入<code>import _ image/png</code>，其作用是利用包中的<code>init</code>函数进行相关组件的注册。同理，我们也可以通过<code>init</code>函数来进行函数注册和模块注册。</li></ol><h3 id="约定及习惯"><a class="header-anchor" href="#约定及习惯"></a>约定及习惯</h3><ol><li>包名原则上和父目录的文件夹名称一致。如果不一致也能干活儿，但是你引用的<code>import git.com/pkg/A</code>的包，使用A路径下文件里函数的时候却是<code>B.xxFunc</code>，不觉得这么干有病么。</li><li>如果类的方法使用的是指针接收者，那么所有的方法都建议使用指针接收者，如果方法使用结构体接收者，那么所有有方法建议都用结构体接收者。</li><li>接口命名通常是动词+er,比如<code>writer</code>, <code>controller</code>等</li><li>golang提倡平铺式结构，不提倡继承关系的结构。</li><li>程序结构，根据需求，以核心逻辑为主，细节由接口实现。</li><li>如果要提公共接口，公共接口往往专注一个能力，干一件事。不宜过长。</li><li>一个不错的接口设计经验：仅设计你所需要的接口</li><li>golang命名建议：<ol><li>变量、函数、结构体等建议驼峰命名</li><li>包名小写拼接，比如<code>strconv</code>，不建议<code>str_conv</code></li><li>文件名看个人习惯，通常是小写拼接或者小写<code>_</code>拼接。基本除了驼峰类型，其他的都行。</li></ol></li><li>好的测试程序：<ol><li>测试程序也需要健壮性，和秩序跟进维护</li><li>测试程序要尽可能多的报告出错误信息，要尝试一次运行中报多个错误。</li><li>覆盖率</li></ol></li><li>测试的约定函数名：<ol><li>Test开头，代表功能测试</li><li>Benchmark开头，代表性能测试</li><li>Example开头，代表示例函数</li></ol></li></ol><h3 id="Cgo"><a class="header-anchor" href="#Cgo"></a>Cgo</h3><ol><li><p><code>cgo</code>用于在go中调用c的函数，当然如果你的c库很小，可以考虑移植它，如果性能对我们来说不是很关键，那么也可以用<code>os/exec</code>来执行c的可执行程序。<code>cgo</code>只用于复杂且对性能有所要求的C库。<br>一个C写的程序：</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bzlib.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bz2compress(bz_stream *s, <span class="keyword">int</span> action, </span><br><span class="line">   char *in, unsigned *inlen, char *out, unsigned *outlen)&#123;</span><br><span class="line">   s-&gt;next_in = in;</span><br><span class="line">   s-&gt;avail_in = *inlen;</span><br><span class="line">   s-&gt;next_out = out;</span><br><span class="line">   s-&gt;avail_out = *outlen;</span><br><span class="line">   <span class="keyword">int</span> r = BZ2_bzCompress(s,action);</span><br><span class="line">   *inlen -= s-&gt;avail_in;</span><br><span class="line">   *outlen -= s-&gt;avail_out;</span><br><span class="line">   <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应cgo部分的代码。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#cgo CFLAGS: -I/usr/include</span></span><br><span class="line"><span class="comment">#cgo LDFLAGS: -L/usr/lib -lbz2</span></span><br><span class="line"><span class="comment">#include &lt;bzlib.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int bz2compress(bz_stream *s, int action,</span></span><br><span class="line"><span class="comment">   char *in, unsigned *inlen, char *out, unsigned *outlen);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//标识加入cgo，程序会分析注释中的相关内容</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"io"</span></span><br><span class="line">   <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> writer <span class="keyword">struct</span> &#123;</span><br><span class="line">   w      io.Writer</span><br><span class="line">   stream *C.bz_stream</span><br><span class="line">   outbuf [<span class="number">64</span> * <span class="number">1024</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewWriter 对于bzip2压缩的流返回一个wirter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(out io.Writer)</span> <span class="title">io</span>.<span class="title">WriteCloser</span></span> &#123;</span><br><span class="line">   <span class="keyword">const</span> (</span><br><span class="line">      blockSize  = <span class="number">9</span></span><br><span class="line">      verbosity  = <span class="number">0</span></span><br><span class="line">      workFactor = <span class="number">30</span></span><br><span class="line">   )</span><br><span class="line">   w := &amp;writer&#123;w: out, stream: C.bz2alloc()&#125;</span><br><span class="line">   C.BZ2_bzCompressInit(w.stream, blockSize, verbosity, workFactor)</span><br><span class="line">   <span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *writer)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> w.stream == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"closed"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">len</span>(data) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      inlen, outlen := C.<span class="keyword">uint</span>(<span class="built_in">len</span>(data)), C.<span class="keyword">uint</span>(<span class="built_in">cap</span>(w.outbuf))</span><br><span class="line">      C.bz2compress(w.stream, C.BZ_RUN,</span><br><span class="line">         (*C.char)(unsafe.Pointer)(&amp;data[<span class="number">0</span>]), &amp;inlen,</span><br><span class="line">         (*C.char)(unsafe.Pointer)(&amp;w.outbuf), &amp;outlen)</span><br><span class="line">      total += <span class="keyword">int</span>(inlen)</span><br><span class="line">      data = data[inlen:]</span><br><span class="line">      <span class="keyword">if</span> _, err := w.w.Write(w.outbuf[:outlen]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> total, err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> total, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><p>作为golang语言的半入门者，看完这本书，算是入门了。总的来说，书还是很不错的，看完过后，可以让你对golang有个整体的概念，更加熟悉语言本身的特性，以及学习到一些使用技巧。值得入门级别的go语言学习者仔细阅读，其中的一些疑惑可以自己编写代码执行来深入了解。<br>注：这个笔记本身没有什么阅读学习价值，读书笔记对于我来说是在我学习的时候更加帮助我记忆和理解，以及后续遇到某个问题时的快速查阅。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传说中的go语言圣经，得看一看(•̀⌄•́)&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;主题：GO语言学习&lt;br&gt;
类别：计算机-&amp;gt;实用性+理论性论述书-&amp;gt;golang&lt;br&gt;
概要：从语法，特性，接口，工具，测试等方面系统性介绍go语言。总体来说是针对语言本身特性来进行介绍的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《代码整洁之道》读书笔记</title>
    <link href="http://yoursite.com/2021/07/17/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/07/17/《代码整洁之道》读书笔记/</id>
    <published>2021-07-17T14:31:22.000Z</published>
    <updated>2022-01-07T07:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>提升代码能力(•̀⌄•́)  可惜是比较针对java，我又不懂java，只能借鉴一下思想了。<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>主题：如何编写好的代码<br>类别：计算机-&gt;实用性-&gt;提升代码编写能力<br>概要：如何定义优秀的代码，如何编写优秀的代码，给出示例具体分析。</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>写过有几年的代码了，最近在代码架构设计，函数设计，类设计等方面总是不那么通透，期望寻找一些较好的理论和原则，写出更加优雅的代码。期望阅读完本书后，能有一些代码设计编写方面的体会和收获，给出一些理念和原则。</p><h2 id="怎样区分好和差代码"><a class="header-anchor" href="#怎样区分好和差代码"></a>怎样区分好和差代码</h2><h3 id="程序员的职业操守"><a class="header-anchor" href="#程序员的职业操守"></a>程序员的职业操守</h3><p>应当自己为自己的code负责，应尽力写出整洁优雅的代码，当有狗屎需求来，或者要求效率赶工的时候，应当提出自己的反对观点，指出其后续缺陷影响。要是领导还是让那么干，就屎上堆屎吧，堆不动了就溜了吧。😎</p><h3 id="怎么样判断是否是好代码"><a class="header-anchor" href="#怎么样判断是否是好代码"></a>怎么样判断是否是好代码</h3><p>让人改无所改，没有可优化的余地，尝试改了一圈，还是回到原点。</p><h3 id="一些好代码的特性"><a class="header-anchor" href="#一些好代码的特性"></a>一些好代码的特性</h3><ol><li>能通过所有测试</li><li>没有重复的代码</li><li>体现设计中的全部思想理念，而且尽量简单的体现。</li><li>包括尽量少的实体，比如方法，类，函数等。（主要体现系统架构和逻辑，就是系统只做某一类事情，而不是某一件事情）</li><li>写代码的过程中，读写的比例是10:1，因此让你的代码更易读，可以帮助你自己，也能帮助他人</li><li>时时保持代码的整洁。每次修改代码时，或许你只需要清除无用的代码，修改变量名，清除一点重复的代码……</li></ol><h3 id="良好的命名"><a class="header-anchor" href="#良好的命名"></a>良好的命名</h3><ol><li>良好的命名能够帮助你很多，一旦发现好的命名，就要替换旧的命名。好的命名，能一眼看出你想干什么，你代表什么。</li><li>避免误导性的命名，比如fp, socket等，或者语言特定称呼，比如xxxList,除非真的是list类型，不然最好用其他命名。</li><li>做有意义的区分，而不是一些含义相同，拼写不同的命名。比如productInfo和productData</li><li>不要自己造单词，或者不可读单词。比如什么gmssssasl这种乱七八糟的</li><li>避免使用一些编码和数字，而是用一些宏定义替代它。</li><li>类名和变量名，都应该是名词；函数都应该是动词。</li><li>同一个概念应该对应同一个词汇。</li></ol><h3 id="函数"><a class="header-anchor" href="#函数"></a>函数</h3><ol><li>函数应该做一件事情，做好这一件事情。并且只做这一件事情。</li><li>判断函数是否做一件事情的方法，是函数是否还能拆分，从而改变其抽象层级。</li><li>每个函数中应当只包含一个抽象层级。</li><li>使用表述性词汇，即能描述出函数的功能。而且越精简的函数越好命名。</li><li>尽量少的传递参数，如果超过了三个以上的参数，就需要考虑用类封装了。</li><li>标识参数异常丑陋，因为这表明函数不止做一件事情。</li><li>函数尽量不要暗含其他操作。如果有最好进行说明</li></ol><h3 id="注释"><a class="header-anchor" href="#注释"></a>注释</h3><ol><li>优美易读的代码不需要注释。</li><li>有用的注释：<ol><li>法律信息</li><li>提供一些信息，比如wiki链接</li><li>提供意图，为何这么干</li><li>进行一些补充说明</li><li>一些警告，比如前置条件一类</li><li>TODO</li></ol></li><li>避免一些误导性注释，以及一些废话。</li><li>避免循环性注释，也就是每个函数都加什么参数说明这种注释。</li><li>注释也要讲求精炼。</li></ol><h3 id="格式"><a class="header-anchor" href="#格式"></a>格式</h3><p>良好的格式更易于阅读。</p><ol><li>适当的缩进和换行</li><li>被调用的函数写在更下面，以方便顺序阅读。C这种有语言限制的除外。</li><li>水平对齐，更方便查看。</li><li>团队应当保持统一的编码风格。</li></ol><h3 id="对象和数据结构"><a class="header-anchor" href="#对象和数据结构"></a>对象和数据结构</h3><ol><li>面向过程的代码，便于在已有的数据结构下添加新的函数， 这是以数据结构为中心。 面向对象，便于在已有的函数下添加新的类，以函数为中心，也就是接口为中心。</li><li>什么时候使用面向对象，什么时候使用面向过程，都是值得考虑。而混用是否导致混乱和不必要，也需要进行考虑。比如go中封装的db库，即把它当成一个对象，来操作其方法，又直接获取其子成员包含方法。即没有把对象内部细节屏蔽，又使用了对象的封装，以求实现屏蔽细节。矛盾，需要细细思考。TODO</li><li>对象暴露行为，隐藏数据。数据结构暴露数据，没有什么行为。在合适的地方使用合适的结构。(个人理解，如果提供一种能力，那么则可以使用对象。如果是提供一种状态，则可以使用数据结构。对外提供能力，对内传输数据。向上提供接口，向下读写数据。)</li></ol><h3 id="边界"><a class="header-anchor" href="#边界"></a>边界</h3><ol><li>如何应对第三方接口的修改？<ol><li>在第三方接口上进行封装。但是其能力会降低？</li><li>编写相关测试代码，测试第三方程序。以及相应的更新文档。以确定新版本的改动。(风险只能降低，不能避免)</li></ol></li><li>对于还不存在的代码，我们可以先定义其行为和交互的数据。给一个统一的接口，代码来了直接装填就能用。</li><li>编写代码前，我们应当清晰的定义出软件的边界，以及哪些地方可扩展。对于可扩展的地方要小心谨慎对待，系统对接的地方也是如此，以便以后尽量少的改动我们的代码。</li></ol><h3 id="单元测试"><a class="header-anchor" href="#单元测试"></a>单元测试</h3><ol><li>测试应当随着代码的开发跟进开发</li><li>太久不维护测试代码，会导致测试代码失效，导致修改代码的故障率增加，以至于不想不敢去改原始代码。比如我写的AAD模块。</li><li>测试代码覆盖的越全面，你就能更加轻易的修改功能代码。</li><li>测试代码要求简单、精悍、足具表达力。</li><li>一类测试应当有一个断言。</li><li>测试应当是一类作为一个测试，而测试数据应当想办法独立，以保障最大的覆盖面。</li><li>整洁的测试还遵循以下5条规则：<ol><li>快速（Fast）测试应该够快。测试应该能快速运行。测试运行缓慢，你就不会想要频繁地运行它。如果你不频繁运行测试，就不能尽早发现问题，也无法轻易修正，从而也不能轻而易举地清理代码。最终，代码就会腐坏。</li><li>独立（Independent）测试应该相互独立。某个测试不应为下一个测试设定条件。你应该可以单独运行每个测试，及以任何顺序运行测试。当测试互相依赖时，头一个没通过就会导致一连串的测试失败，使问题诊断变得困难，隐藏了下级错误。</li><li>可重复（Repeatable）测试应当可在任何环境中重复通过。你应该能够在生产环境、质检环境中运行测试，也能够在无网络的列车上用笔记本电脑运行测试。如果测试不能在任意环境中重复，你就总会有个解释其失败的接口。当环境条件不具备时，你也会无法运行测试。</li><li>自足验证（Self-Validating）测试应该有布尔值输出。无论是通过或失败，你不应该查看日志文件来确认测试是否通过。你不应该手工对比两个不同文本文件来确认测试是否通过。如果测试不能自足验证，对失败的判断就会变得依赖主观，而运行测试也需要更长的手工操作时间。</li><li>及时（Timely）测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，代码难以测试。你可能会认为某些生产代码本身难以测试。你可能不会去设计可测试的代码。</li></ol></li></ol><h3 id="类"><a class="header-anchor" href="#类"></a>类</h3><ol><li>类应当尽量短小，一个类不要承载过多的公共函数和变量。</li><li>一个类应当遵循单一原则，只有一个修改原因。</li><li>应当对类加以组织，减少修改带来的影响。</li></ol><h3 id="系统"><a class="header-anchor" href="#系统"></a>系统</h3><ol><li>系统的构建和运行应当分离，意思是系统架构和实际运行的功能应当分离。</li><li>主系统在执行的时候，默认实际运行的功能已经是ok的，主程序不依赖任何实际运行的功能。</li><li>依赖注入，一种强大的机制可以实现分离构造与使用。在依赖管理情景中，对象不应负责实体化对自身的依赖。反之，它应当将这份权责移交给其他“有权力”的机制，从而实现控制的反转。</li><li>扩容是系统必须考虑的事情之一。但是无法一次性规划好系统，只需要持续将关注面进行切分。个人觉得，netfilter的架构是扩展性很好的架构。</li><li>模块化和关注面切分成就了分散化管理和决策。</li></ol><h3 id="迭代"><a class="header-anchor" href="#迭代"></a>迭代</h3><p>Kent Beck关于简单设计的四条规则：</p><ol><li>运行所有测试<ol><li>不可测试的系统，不可验证，不可验证的系统不能上线</li><li>良好的测试能促使进一步完善代码。</li></ol></li><li>不要有重复</li><li>表达程序员意图</li><li>尽可能的减少方法和类<br>良好的遵循以上四条规则，能够更好的帮助你重构某个不合理的模块，迭代增加新的功能。</li></ol><h3 id="并发编程"><a class="header-anchor" href="#并发编程"></a>并发编程</h3><p>并发是一种时机上的解耦</p><ol><li>并发并不总能提高性能。</li><li>并发可能伴随很大程度上的系统改造。</li><li>并发可能需要对系统有更加深入的理解。</li><li>并发开发建议：<ol><li>分离并发代码和其他代码</li><li>严谨控制数据的作用域</li><li>尽量使用副本。比如内存池和线程池。</li><li>线程应当尽可能独立。</li><li>详细了解基本的并发之间的基础模型：读写模型，生产者消费者模型，哲学家圆桌模型。</li><li>明确读写锁，死锁，互斥，线程饥饿等概念。</li><li>警惕同步方法之间的依赖，保持同步区域的微小。</li><li>考虑子线程死锁后如何退出线程。TODO</li><li>偶发性错误可能是多线程之间隐藏的难易发现的错误，也要重视。尝试稳定复现。</li><li>编写可插拔的线程代码：可控线程数量，可控线程运行速度，可配置程序运行环境。</li></ol></li></ol><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><p>总的来说，在有一定开发经验的基础上来阅读本书，是很有帮助的，其中最让我受益的是重新理解了测试的重要性，以及一些使代码整洁的基本原则。<br>可惜了是java为主的代码示例，让我有些看不懂，或者感触不深，毕竟毫无java开发经验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提升代码能力(•̀⌄•́)  可惜是比较针对java，我又不懂java，只能借鉴一下思想了。&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;主题：如何编写好的代码&lt;br&gt;
类别：计算机-&amp;gt;实用性-&amp;gt;提升代码编写能力&lt;br&gt;
概要：如何定义优秀的代码，如何编写优秀的代码，给出示例具体分析。&lt;/p&gt;
    
    </summary>
    
      <category term="技术杂谈" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx源码阅读</title>
    <link href="http://yoursite.com/2021/07/11/nginx%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2021/07/11/nginx源码阅读/</id>
    <published>2021-07-11T09:09:05.000Z</published>
    <updated>2022-01-07T07:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>nginx源码阅读分析(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>本人主要使用的nginx源码是<a href="http://nginx.org/download/nginx-1.0.15.tar.gz" target="_blank" rel="noopener">nginx-1.0.15</a>，以降低阅读难度，毕竟需要了解的是大体框架和原理。最新的版本，代码量太大，会增加阅读理解难度，没有必要。而本文的阅读方法，也按照<strong>基本使用-&gt;简单示例-&gt;示例在源码中如何工作-&gt;相关联版块实现逻辑-&gt;结构化整理nginx逻辑框架</strong>的方法来写文档。其核心思路围绕:<strong>什么功能-&gt;功能如何实现</strong>来进行分析，反复循环改过程以理解整个nginx源码。最后会提出一个实际问题，通过阅读源码后来提出相应的解决方案。<br>有必要可以增加一个如何编写nginx的module的文章，单开篇，就不在这里写了。</p><a id="more"></a><h2 id="序"><a class="header-anchor" href="#序"></a>序</h2><p>首先你必须要有一定的C功底，linux功底，以及初步了解过nginx最好也初步使用过，本文对于这几项会几乎略过，当然会给出一个基本使用示例。<br>由于本人也是才工作不久的新人，初次阅读源码，菜是自然的，有问题的地方，欢迎讨论。<br>其他：本文的客户端(浏览器)在windows上，使用Chrome；服务器在linux(centos 7.6)上，其他平台的编译执行请自行处理。</p><h2 id="nginx应用示例"><a class="header-anchor" href="#nginx应用示例"></a>nginx应用示例</h2><p>我们第一步很简单，先把它用起来。这里我们给出两个nginx的经典应用场景，1. 作为web服务器，即在服务器放一个html文件，然后浏览器通过nginx访问该html的网页。2. 作为反向代理，即在服务器A上安装一个nginx做反向代理到服务器B，客户端通过服务器A访问服务器B资源。我们先配置场景1<br>在此之前，先干下面的事情：</p><ol><li>下载nginx源码</li><li>编译</li><li>修改配置文件</li><li>执行nginx，并测试场景1成功</li></ol><h3 id="源码下载编译"><a class="header-anchor" href="#源码下载编译"></a>源码下载编译</h3><p>更加详细的编译和配置可以参考：<a href="https://zhuanlan.zhihu.com/p/92995126" target="_blank" rel="noopener">最全Nginx 配置文件详解及安装</a><br>下载：<a href="http://nginx.org/download/nginx-1.0.15.tar.gz" target="_blank" rel="noopener">nginx-1.0.15</a><br>编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.0.15.tar.gz</span><br><span class="line">tar -xzvf nginx-1.0.15.tar.gz</span><br><span class="line">cd nginx-1.0.15/</span><br><span class="line">./configure --with-debug --prefix=/&lt;your_path&gt;/nginx_learning/</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>不出意外就成功了，如果有错误，自行解决。相应的可执行程序在<code>objs/nginx</code></p><h3 id="配置场景"><a class="header-anchor" href="#配置场景"></a>配置场景</h3><h4 id="环境准备"><a class="header-anchor" href="#环境准备"></a>环境准备</h4><p>我们安装的时候，把可执行文件<code>install</code>到了一个新目录：<code>nginx_learning</code><br>不出意外，结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># tree</span><br><span class="line">.</span><br><span class="line">|-- conf</span><br><span class="line">|   |-- fastcgi.conf</span><br><span class="line">|   |-- fastcgi.conf.default</span><br><span class="line">|   |-- fastcgi_params</span><br><span class="line">|   |-- fastcgi_params.default</span><br><span class="line">|   |-- koi-utf</span><br><span class="line">|   |-- koi-win</span><br><span class="line">|   |-- mime.types</span><br><span class="line">|   |-- mime.types.default</span><br><span class="line">|   |-- nginx.conf</span><br><span class="line">|   |-- nginx.conf.default</span><br><span class="line">|   |-- scgi_params</span><br><span class="line">|   |-- scgi_params.default</span><br><span class="line">|   |-- uwsgi_params</span><br><span class="line">|   |-- uwsgi_params.default</span><br><span class="line">|   `-- win-utf</span><br><span class="line">|-- html</span><br><span class="line">|   |-- 50x.html</span><br><span class="line">|   `-- index.html</span><br><span class="line">|-- logs</span><br><span class="line">`-- sbin</span><br><span class="line">    `-- nginx</span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a class="header-anchor" href="#修改配置文件"></a>修改配置文件</h4><p>上述完成后，我们进行场景1和2的配置文件修改，得到<code>nginx.conf</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8080;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">root /data/www;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        location /proxy &#123;</span><br><span class="line">            proxy_pass   http://127.0.0.1:8000/;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件的<code>root</code>配置根据个人情况修改。<br><em>注意：<code>www</code>目录位置，注意权限问题，详情可查看日志<code>logs/error.log</code>。权限问题处理方式可参考：<a href="https://stackoverflow.com/questions/6795350/nginx-403-forbidden-for-all-files" target="_blank" rel="noopener">Nginx 403 forbidden for all files</a>，翻不了墙的同学，自行百度</em></p><h4 id="构建资源"><a class="header-anchor" href="#构建资源"></a>构建资源</h4><p>然后我们在<code>www</code>目录下新建一个<code>index.html</code>文件，作为场景1的服务端资源：<br>index.html:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt; Hello nginx &lt;/h1&gt;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">对于场景2，我们需要构建反向代理的后端服务，可以自己启动一个http的文件服务器。比如：</span><br></pre></td></tr></table></figure><p>nohub python3 -m http.server --bind 127.0.0.1 8000 &amp;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以本地curl一下以验证启动效果：</span><br></pre></td></tr></table></figure><p>curl <a href="http://127.0.0.1:8000" target="_blank" rel="noopener">http://127.0.0.1:8000</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后我们启动nginx：</span><br></pre></td></tr></table></figure><p>nginx_learning/nginx -p /&lt;your_path&gt;/nginx_learning/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#### 测试效果</span><br><span class="line">我们可以看下场景1的展示效果：</span><br><span class="line">![场景1](./nginx源码阅读/场景1效果.png)</span><br><span class="line">我这里使用的是我自己的一个桩。访问效果如下：</span><br><span class="line">![场景2](./nginx源码阅读/场景2效果.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 场景1源码分析</span><br><span class="line">我们上面已经实现了场景1和场景2的展示，那么现在开始分析场景1的流程。</span><br><span class="line">### 源码分析</span><br><span class="line">按照惯例，我们可以从main函数开始，先分析程序启动，再一步一步的分析场景1是如何实现的。分析过程中，遇到变量结构太复杂可以先记录下来，跳过，等实际应用的时候再回头分析。记住，这时候我们的主要目的是梳理出整个执行逻辑，而不是细节，不必在对流程不重要的细节上花费太多时间，以阻碍主流程梳理进度。</span><br><span class="line">#### main函数</span><br><span class="line">**mian函数局部变量定义：**</span><br><span class="line">找到main函数，一开始就是四个数据结构：</span><br></pre></td></tr></table></figure><pre><code>ngx_int_t         i;ngx_log_t        *log; //猜测用于日志记录ngx_cycle_t      *cycle, init_cycle; //猜测是个贯穿整个流程重要的数据结构，里面包含的东西很多，暂时不管ngx_core_conf_t  *ccf;//猜测配置相关内容，细节再说</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">可以大致看一看，猜测一下它们作用。大致看一下各个数据结构类型。我这里好奇它的[命名习惯](#nginx中的命名习惯)，因此初步进行梳理。`ngx_cycle_t`和`ngx_core_conf_t`结构有些多，后面梳理(你也可以提前看看[nginx中数据结构](#nginx中数据结构))。</span><br><span class="line">**初始化和参数分析：**</span><br><span class="line">1. `ngx_strerror_init`初始化了一个自己的errnum 列表。关于error number，有这样一个解释：[参考](https://blog.csdn.net/baishuwei/article/details/2535484)</span><br><span class="line">   &gt;在没有解释这些错误定义之前，先让我们看看为什么要知道这些常用error number？ 对于写C程序的人来说，errno并不是一个陌生的变量，无论你是在用户态还是在内核态。简短来说，errno是用来保存错误信息，这些信息反应了相应错误原因。因此，一个小小errno就可以连接user space programmer 与 kernel space programmers，可见其重要性。但是，我们的programmers确又常常忽略这些，他们往往只看中正确与错误，而不是去访问强大的errno获取更多的信息。对于普通的程序，为此可能仅仅是&quot;没关系，大不了可以重启&quot;。但是，对于一些重要的任务，重启可能意味着灾难的发生，尤其是在重要的领域。为此，这里我想给大家列出常见的errno，提醒大家在处理设备时，&quot;check errno when your routine failed!&quot;.</span><br><span class="line"></span><br><span class="line">   和[手册](https://man7.org/linux/man-pages/man3/errno.3.html)中的描述差距不大：</span><br><span class="line">   &gt;The &lt;errno.h&gt; header file defines the integer variable errno,</span><br><span class="line">       which is set by system calls and some library functions in the</span><br><span class="line">       event of an error to indicate what went wrong.</span><br><span class="line">2. `ngx_get_options`参数分析，nginx主要依赖配置文件，因此命令行参数很简单。</span><br><span class="line">3. `ngx_time_init`初始化nginx中时间记录格式。</span><br><span class="line">4. `ngx_regex_init`(可先跳过)</span><br><span class="line">5. `ngx_log_init`(可先跳过)</span><br><span class="line">6. `ngx_ssl_init`(可先跳过)</span><br><span class="line">7. `ngx_create_pool`知道是初始化内存池的就行。</span><br><span class="line">8. `ngx_save_argv`(可先跳过)</span><br><span class="line">9. `ngx_process_options`(可先跳过) </span><br><span class="line">10. `ngx_os_init`获取一些系统相关信息</span><br><span class="line">11. `ngx_crc32_table_init`(可先跳过)</span><br><span class="line">12. `ngx_add_inherited_sockets`(可先跳过)看起来像获取NGINX系统变量，然后干些事情，和主流程似乎不影响。毕竟有`inherited == NULL`这种判断</span><br><span class="line">13.  </span><br><span class="line">14. `ngx_init_cycle`这个玩意儿，里面包含了很多东西，粗看一眼，牵涉到系统socket监听，配置文件分析，和主流程是紧密相关，不能跳过了。看 一下其流程</span><br><span class="line">    1. 分配一些内存池，更新一些时间戳，以及一些链表。</span><br><span class="line">    2. `ngx_conf_param` 读取配置文件外的全局内容，实际工作方式调用`ngx_conf_parse`</span><br><span class="line">    3. `ngx_conf_parse(&amp;conf, &amp;cycle-&gt;conf_file)` 读取配置文件内容</span><br><span class="line">        1. `if (filename)` 判断是打开配置文件以及获取基本信息。</span><br><span class="line">        2. `for ( ;; )`中的`ngx_conf_read_token`进行每一个token的分析。这里1个`;`所包含的为一个token</span><br><span class="line">            1. 当找到完整的有用的单词，就会标记`found = 1`,然后进行下面的赋值处理：</span><br><span class="line">            ```c</span><br><span class="line">                if (found) &#123;</span><br><span class="line">                //每当找到一个可用配置，比如‘worker_processes  1;’</span><br><span class="line">                //就会先后将‘worker_processes’和‘1’放到cf-&gt;args中，</span><br><span class="line">                //至于这个ngx_array_t结构如何,待后续分析。TODO</span><br><span class="line">                word = ngx_array_push(cf-&gt;args);</span><br><span class="line">                if (word == NULL) &#123;</span><br><span class="line">                    return NGX_ERROR;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //分配相应内存给数据</span><br><span class="line">                word-&gt;data = ngx_pnalloc(cf-&gt;pool, b-&gt;pos - start + 1);</span><br><span class="line">                if (word-&gt;data == NULL) &#123;</span><br><span class="line">                    return NGX_ERROR;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //拷贝找到的值</span><br><span class="line">                for (dst = word-&gt;data, src = start, len = 0;</span><br><span class="line">                     src &lt; b-&gt;pos - 1;</span><br><span class="line">                     len++)&#123;</span><br><span class="line">                         ....</span><br><span class="line">                     &#125;</span><br><span class="line">                if (ch == &apos;;&apos;) &#123;</span><br><span class="line">                    return NGX_OK;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><pre><code>        2. `ngx_conf_handler`用于将命令行参数载入扩展module。TODO细节4. `for (i = 0; ngx_modules[i]; i++)` 赋值相应的配置变量给扩展的module5. `ngx_create_pathes`创建文件夹路径6. `part = &amp;cycle-&gt;open_files.part; file = part-&gt;elts; for (i = 0; /* void */ ; i++) {` 打开要用到的文件。7. `part = &amp;cycle-&gt;shared_memory.part; shm_zone = part-&gt;elts;`创建共享内存8. `if (old_cycle-&gt;listening.nelts)`赋值相关监听所需值9. `ngx_open_listening_sockets`启动监听10. 释放一些不用的内存，打开的文件，以及socket11. `failed`出错处理，配置回滚。</code></pre><ol start="15"><li><p><code>ngx_signal_process</code>(可先跳过)</p></li><li><p><code>ngx_init_signals</code>注册信号量的回调函数，信号量和回调函数的关联关系在<code>signals</code>全局量中。控制相关标记位来间接控制master进程中的动作</p></li><li><p><code>ngx_os_status</code>打印系统状态</p></li><li><p>获取配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ccf = (ngx_core_conf_t *) ngx_get_conf(cycle-&gt;conf_ctx, ngx_core_module);</span><br></pre></td></tr></table></figure></li><li><p>标识是否是master进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (ccf-&gt;master &amp;&amp; ngx_process == NGX_PROCESS_SINGLE) &#123;</span><br><span class="line">    ngx_process = NGX_PROCESS_MASTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ngx_daemon</code>fork进程，具体操作后续继续阅读</p></li><li><p><code>ngx_create_pidfile</code>创建pidfile</p></li><li><p>创建worker进程或者master进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (ngx_process == NGX_PROCESS_SINGLE) &#123;</span><br><span class="line">    ngx_single_process_cycle(cycle);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ngx_master_process_cycle(cycle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>结构流程：</strong><br>从上面的函数大概分析，我们基本能够梳理出整个main函数的逻辑：</p><pre class="mermaid">flowchart TDA(初始化errnum)B(解析命令行传入参数)C1(时间格式,SSL,内存池初始化)C2(获取系统的一些信息)C3(其他一些不影响的初始化)D1(读取解析额外配置)D2(读取解析配置文件)D3(赋值配置到module)D4(创建文件夹,打开需要使用的文件)D5(创建共享内存)D6(启动监听)D7(释放多余内存,文件,状态)D8(错误处理和配置回滚)E{标识是否为master}F1(创建子进程)F2(创建主进程)    subgraph C [其他初始化]        C1 --> C2         C2 --> C3    end    subgraph D [初始化cycle]        D1 --> D2        D2 --> D3        D3 --> D4        D4 --OK--> D5        D5 --OK--> D6        D6 --OK--> D7        D7 --> D8        D6 --failed-->D8        D5 --failed-->D8        D4 --failed-->D8    end    A --> B    B --> C    C --> D    D -->E    E --否--> F1    E --是--> F2</pre><p>从上述流程图，基本可以了解到主函数所做的工作。接下来就开始梳理master进程和worker进程分别做了什么工作。</p><h4 id="master进程"><a class="header-anchor" href="#master进程"></a>master进程</h4><ol><li>注册许多的信号量，并设置成阻塞，延后处理。<a href="https://blog.csdn.net/ShaoLiang_Ge/article/details/57984123" target="_blank" rel="noopener">sigprocmask</a>函数讲解</li><li>设置进程标记</li><li><code>ngx_start_worker_processes</code>控制子进程启动(这里的fork干嘛用的？)<ol><li><code>for ngx_get_cpu_affinity</code>循环子进程个数</li><li><code>ngx_spawn_process</code>创建和子进程通信的套接字。<ol><li><code>ngx_worker_process_cycle</code>回调函数，具体作用是解析收到的消息，放到状态机里处理。消息从何而来？未知，主要是fork函数作用？</li></ol></li><li><code>ngx_pass_open_channel</code>往套接字里发送消息，消息转发给子进程。</li></ol></li><li><code>ngx_start_cache_manager_processes</code>, 其抽象作用和<code>ngx_start_worker_processes</code>差不多，都是发送消息给子进程，只是功能作用上是进行cache的管理启动。主要调用的也是下面两个函数：<ol><li><code>ngx_spawn_process</code> 内容是：‘cache manager process’</li><li><code>ngx_pass_open_channel</code></li></ol></li><li>主进程的主要<code>for ( ;; )</code><ol><li>是否进行delay<ol><li>使用<code>setitimer</code>控制进程延时</li></ol></li><li><code>sigsuspend</code>恢复之前的sigprocmask阻塞信号的处理</li><li>根据接收到的信号(用户或系统发送)，修改标记位来控制相应的子进程，给子进程发送相应的信号，或者套接字消息(类似上面的ngx_start_worker_processes的方式)。<br>这里我们会疑惑，哪里修改的标记位？哪里接受处理的信号。全局搜索一下可以找到：设置接收信号的回调函数在<code>main</code>中的<code>ngx_init_signals</code>函数中完成，根据对应的信号量调用<code>ngx_signal_handler</code>函数来修改相应标记位。</li></ol></li></ol><h4 id="worker进程"><a class="header-anchor" href="#worker进程"></a>worker进程</h4><ol><li>设置环境变量，是nginx中的全局变量<code>environ</code></li><li>执行<code>ngx_modules</code>中的<code>init_process</code>函数，也就是利用nginx中模块注册机制。</li><li>主<code>for ( ;; )</code>循环。<ol><li><p><code>ngx_process_events_and_timers</code>非常核心的函数，包含了事件处理，和延时处理。<code>nginx</code>中所有事务都是围绕这个函数中事件处理来完成的。也就是利用了状态机的机制，每次事件的触发，执行触发的相应事件，就是在该函数中完成。</p><ol><li>timer初始化，如果ngx开了线程处理方式，则timer初始化和处理有所差异。</li><li><code>ngx_process_events</code>核心函数。define为<code>ngx_event_actions.process_events</code>, <code>ngx_event_actions</code>是一个全局变量，这个全局变量可以注册不同的事件触发器模块(只能注册一个事件触发器，注册方式和普通模块注册一致)，比如你使用<code>epoll</code>做事件触发器，那么就使用<code>ngx_epool_module</code>中的事件触发器的<code>process_events</code>函数。而所有的事件都在<code>ngx_event.h</code>中有定义：</li></ol>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*add)(<span class="keyword">ngx_event_t</span> *ev, <span class="keyword">ngx_int_t</span> event, <span class="keyword">ngx_uint_t</span> flags);</span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*del)(<span class="keyword">ngx_event_t</span> *ev, <span class="keyword">ngx_int_t</span> event, <span class="keyword">ngx_uint_t</span> flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*enable)(<span class="keyword">ngx_event_t</span> *ev, <span class="keyword">ngx_int_t</span> event, <span class="keyword">ngx_uint_t</span> flags);</span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*disable)(<span class="keyword">ngx_event_t</span> *ev, <span class="keyword">ngx_int_t</span> event, <span class="keyword">ngx_uint_t</span> flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*add_conn)(<span class="keyword">ngx_connection_t</span> *c);</span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*del_conn)(<span class="keyword">ngx_connection_t</span> *c, <span class="keyword">ngx_uint_t</span> flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*process_changes)(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">ngx_uint_t</span> nowait);</span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*process_events)(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">ngx_msec_t</span> timer,</span><br><span class="line">                <span class="keyword">ngx_uint_t</span> flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>  (*init)(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">ngx_msec_t</span> timer);</span><br><span class="line">    <span class="keyword">void</span>       (*done)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line">&#125; <span class="keyword">ngx_event_actions_t</span>;</span><br></pre></td></tr></table></figure><p>这里肯定有一些列的事件轮转机制，需要绘图列出TODO<br>3. 执行相应延时。<br>4. <code>posted_events</code>相应的事件还不清楚干啥用的TODO</p></li><li><p>处理接收到的系统信号或者主进程信号：<code>ngx_terminate</code>,<code>ngx_quit</code>,<code>ngx_reconfigure</code>或<code>ngx_reopen</code>。这里面的所代表的功能都很好理解，细节需要的时候再看。</p></li></ol></li></ol><h4 id="nginx架构"><a class="header-anchor" href="#nginx架构"></a>nginx架构</h4><p>从上面的代码分析，我们基本上可以得到大致的结论：</p><ol><li>nginx有多个进程，分别为master进程和work进程(这个从nginx的实际运行情况也可以看到)。</li><li>nginx通过环境变量和配置文件来进行管理。</li><li>master的工作是对work进程进行管理和控制，work进程进行实际的工作。</li></ol><p>因此我们能得到以下的结构图（<a href="http://tengine.taobao.org/book/chapter_02.html" target="_blank" rel="noopener">图片来源</a>）：<br><img src="/2021/07/11/nginx源码阅读/nginx%E6%9E%B6%E6%9E%84.png" alt="架构图"></p><h3 id="场景1的执行流程"><a class="header-anchor" href="#场景1的执行流程"></a>场景1的执行流程</h3><p>当nginx启动后，master进程就一直在主for循环里等待接收信号量，来进行work和自身的控制。而work进程则在主for循环中由<code>ngx_process_events_and_timers</code>函数来处理事件，或处理接收到的信号量。<br>那么场景1的触发流程入口，肯定在<code>ngx_process_events_and_timers</code>函数中的<code>process_events</code>函数触发，而这个函数是个全局函数指针，通过注册生效。而注册的地方我们在编译完成后可以发现一个<code>obj/ngx_modules.c</code>的文件，改文件通过<code>configure</code>生成，通过你选择的编译选择项来生成模块注册文件。那么我们先研究一下nginx的模块注册是如何工作的。</p><h4 id="nginx模块注册机制"><a class="header-anchor" href="#nginx模块注册机制"></a>nginx模块注册机制</h4><h5 id="注册入口"><a class="header-anchor" href="#注册入口"></a>注册入口</h5><p><code>ngx_modules.c</code>用于控制nginx模块注册，模块注册的统一入口。根据编译时的<code>configure</code>参数生成。其文件结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span>  ngx_core_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span>  ngx_errlog_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span>  ngx_conf_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span>  ngx_events_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span>  ngx_event_core_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span>  ngx_epoll_module;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span>  ngx_http_module;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ngx_module_t</span> *ngx_modules[] = &#123;</span><br><span class="line">    &amp;ngx_core_module,</span><br><span class="line">    &amp;ngx_errlog_module,</span><br><span class="line">    &amp;ngx_conf_module,</span><br><span class="line">    &amp;ngx_events_module,</span><br><span class="line">    &amp;ngx_event_core_module,</span><br><span class="line">    &amp;ngx_epoll_module,</span><br><span class="line">    &amp;ngx_http_module,</span><br><span class="line">    ...</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其核心注册机制就是通过配置文件，选择生成全局变量<code>ngx_modules</code>, nginx主体程序读取该全局变量的值来执行相应模块。</p><h5 id="模块入口"><a class="header-anchor" href="#模块入口"></a>模块入口</h5><p>通过注册机制可知，主程序与模块直接的交互只能通过<code>ngx_module_t</code>这个结构，也就是说<code>ngx_module_t</code>是模块提供的接口。<code>ngx_module_t</code>结构如下(先撇一眼，在<a href="#ngx_module_t%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90">后续</a>分析)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_module_s</span>      <span class="title">ngx_module_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_module_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            ctx_index;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            spare0;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            spare1;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            spare2;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            spare3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                 *ctx;</span><br><span class="line">    <span class="keyword">ngx_command_t</span>        *commands;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_master)(<span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_module)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_process)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_thread)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line">    <span class="keyword">void</span>                (*exit_thread)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line">    <span class="keyword">void</span>                (*exit_process)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                (*exit_master)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook0;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook1;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook2;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook3;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook4;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook5;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook6;</span><br><span class="line">    <span class="keyword">uintptr_t</span>             spare_hook7;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们现在已经知道如何进行模块注册，主程序和模块之间的交互接口。对于主程序来说，它并不知道模块具体功能是什么，只知道<code>ngx_module_t</code>这个结构，和<code>ngx_modules</code>全局量。那么现在我们就需要分析，<code>ngx_modules</code>在什么时候使用(模块实际生效位置)以及<code>ngx_module_t</code>里每个变量功能(模块生效干了啥)。即模块生效位置和功能。</p><h5 id="模块生效位置"><a class="header-anchor" href="#模块生效位置"></a>模块生效位置</h5><p>我们跟着启动顺序进行梳理，寻找<code>ngx_modules</code>使用的位置。注册模块分为两类，一是核心模块(NGX_CORE_MODULE)，二是配置模块(NGX_CONF_MODULE)。</p><ol><li><p>main函数，进行<code>ngx_module_t.index</code>初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ngx_max_module = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">    ngx_modules[i]-&gt;index = ngx_max_module++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>ngx_init_cycle</code>中执行注册的核心模块配置初始化(<code>module-&gt;create_conf</code>)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ngx_modules[i]-&gt;type != NGX_CORE_MODULE) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`ngx_module_t.ctx`强转`ngx_core_module_t`</span></span><br><span class="line">    <span class="keyword">module</span> = ngx_modules[i]-&gt;ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;create_conf) &#123;</span><br><span class="line">        rv = <span class="keyword">module</span>-&gt;create_conf(cycle);</span><br><span class="line">        <span class="keyword">if</span> (rv == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ngx_destroy_pool(pool);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cycle-&gt;conf_ctx[ngx_modules[i]-&gt;index] = rv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件解析中，读取注册的配置模块，并用于处理配置文件参数(具体配置方法后面细化)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ngx_modules[i]-&gt;type != NGX_CONF_MODULE</span><br><span class="line">     &amp;&amp; ngx_modules[i]-&gt;type != cf-&gt;module_type)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>注册的核心模块初始化，类似上述第二点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ngx_modules[i]-&gt;type != NGX_CORE_MODULE) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">module</span> = ngx_modules[i]-&gt;ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;init_conf) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;init_conf(cycle, cycle-&gt;conf_ctx[ngx_modules[i]-&gt;index])</span><br><span class="line">            == NGX_CONF_ERROR)</span><br><span class="line">        &#123;</span><br><span class="line">            environ = senv;</span><br><span class="line">            ngx_destroy_cycle_pools(&amp;conf);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行注册模块各自的<code>init_module</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ngx_modules[i]-&gt;init_module) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ngx_modules[i]-&gt;init_module(cycle) != NGX_OK) &#123;</span><br><span class="line">            <span class="comment">/* fatal */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>work里<code>ngx_single_process_cycle</code>中会执行模块的<code>init_process</code>和<code>exit_process</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ngx_modules[i]-&gt;init_process) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ngx_modules[i]-&gt;init_process(cycle) == NGX_ERROR) &#123;</span><br><span class="line">            <span class="comment">/* fatal */</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ngx_terminate || ngx_quit) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ngx_modules[i]-&gt;exit_process) &#123;</span><br><span class="line">            ngx_modules[i]-&gt;exit_process(cycle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>master的<code>ngx_master_process_cycle</code>函数的子函数，<code>ngx_master_process_exit</code>会调用到对应的函数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (ngx_modules[i]-&gt;exit_master) &#123;</span><br><span class="line">         ngx_modules[i]-&gt;exit_master(cycle);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><p>上面的1-5几乎全是模块配置初始化相关的内容，<code>init_process</code>和<code>exit_process</code>是work进程中调用的模块初始化和退出。而<code>init_master</code>和<code>exit_master</code>则是在master进程中进行初始化和退出的。但这里还是有一个问题，模块真正处理请求的函数时如何和work程序挂钩的？</p><h5 id="nginx事件处理流程"><a class="header-anchor" href="#nginx事件处理流程"></a>nginx事件处理流程</h5><p>这里要弄清楚事件处理流程，有两种方式：</p><ol><li><p><s>从必调的<code>init_process</code>入手，阅读一个注册模块的<code>init_process</code>函数，看实现了什么。</s></p><ol><li>首先从一个熟悉的<code>ngx_http_module</code>入手，看<code>init_process</code>做了什么。找到定义的<code>ngx_http_module</code>:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_core_module_t</span>  ngx_http_module_ctx = &#123;</span><br><span class="line">     ngx_string(<span class="string">"http"</span>),</span><br><span class="line">     <span class="literal">NULL</span>,</span><br><span class="line">     <span class="literal">NULL</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ngx_module_t</span>  ngx_http_module = &#123;</span><br><span class="line">     NGX_MODULE_V1,</span><br><span class="line">     &amp;ngx_http_module_ctx,                  <span class="comment">/* module context */</span></span><br><span class="line">     ngx_http_commands,                     <span class="comment">/* module directives */</span></span><br><span class="line">     NGX_CORE_MODULE,                       <span class="comment">/* module type */</span></span><br><span class="line">     <span class="literal">NULL</span>,                                  <span class="comment">/* init master */</span></span><br><span class="line">     <span class="literal">NULL</span>,                                  <span class="comment">/* init module */</span></span><br><span class="line">     <span class="literal">NULL</span>,                                  <span class="comment">/* init process */</span></span><br><span class="line">     <span class="literal">NULL</span>,                                  <span class="comment">/* init thread */</span></span><br><span class="line">     <span class="literal">NULL</span>,                                  <span class="comment">/* exit thread */</span></span><br><span class="line">     <span class="literal">NULL</span>,                                  <span class="comment">/* exit process */</span></span><br><span class="line">     <span class="literal">NULL</span>,                                  <span class="comment">/* exit master */</span></span><br><span class="line">     NGX_MODULE_V1_PADDING</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>一看，麻了麻了，这啥也没有啊。<code>init_process</code>函数为空，<code>ngx_http_module_ctx</code>中的<code>create_conf</code>和<code>init_conf</code>也为空。<br>然后一连看了多个http的模块，发现<code>init_process</code>都为空。看来这种方法不行了。</p></li><li><p>从<code>work</code>进程入手，看谁注册了<code>ngx_event_actions</code>时间处理函数，然后阅读该模块的实现机制。</p><ol><li>在linux下，默认使用的是<code>epoll</code>, 对应注册的<code>ngx_event_actions</code>如下：</li></ol> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ngx_event_module_t</span>  ngx_poll_module_ctx = &#123;</span><br><span class="line">    &amp;poll_name,</span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* create configuration */</span></span><br><span class="line">    ngx_poll_init_conf,                    <span class="comment">/* init configuration */</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ngx_poll_add_event,                <span class="comment">/* add an event */</span></span><br><span class="line">        ngx_poll_del_event,                <span class="comment">/* delete an event */</span></span><br><span class="line">        ngx_poll_add_event,                <span class="comment">/* enable an event */</span></span><br><span class="line">        ngx_poll_del_event,                <span class="comment">/* disable an event */</span></span><br><span class="line">        <span class="literal">NULL</span>,                              <span class="comment">/* add an connection */</span></span><br><span class="line">        <span class="literal">NULL</span>,                              <span class="comment">/* delete an connection */</span></span><br><span class="line">        <span class="literal">NULL</span>,                              <span class="comment">/* process the changes */</span></span><br><span class="line">        ngx_poll_process_events,           <span class="comment">/* process the events */</span></span><br><span class="line">        ngx_poll_init,                     <span class="comment">/* init the events */</span></span><br><span class="line">        ngx_poll_done                      <span class="comment">/* done the events */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>work进程中调用的事件函数<code>(void) ngx_process_events(cycle, timer, flags);</code>对应着<code>epoll</code>中的<code>ngx_poll_process_events</code>函数。<br>那么我们可以得到初步的结论：</p><ol><li>nginx的模块依赖是一层层递进的：<ol><li>核心模块</li><li>事件处理模块</li><li>业务处理模块</li></ol></li><li><code>ngx_module_t</code>负责模块注册时的初始化。比如各种配置相关处理，执行业务前的初始化等。</li><li><code>ngx_event_module_t</code>则是负责进行业务注册，也就是当事件触发后，我应当执行哪些业务。而业务注册则是通过<code>ngx_event_actions_t.add*</code>函数实现。</li></ol></li></ol><p>结合上述两点，可以初步得到模块注册和事件处理的流程：</p><ol><li><p>在<code>ngx_event_core_module</code>注册模块(编译时控制)，生成<code>ngx_modules.c</code>文件，包含全局变量<code>ngx_modules</code></p></li><li><p>nginx启动时执行相关初始化,执行<code>ngx_modules</code>中<code>init_conf</code>等。</p></li><li><p>启动nginx的work进程，执行<code>ngx_modules</code>中<code>init_process</code>。其中包含<code>ngx_event_core_module.ngx_event_process_init</code></p></li><li><p><code>ngx_event_process_init</code>又以同样的原理，进行<code>event事件的注册</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (m = <span class="number">0</span>; ngx_modules[m]; m++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ngx_modules[m]-&gt;type != NGX_EVENT_MODULE) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_modules[m]-&gt;ctx_index != ecf-&gt;use) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ngx_event_module_t  *module;</span></span><br><span class="line">    <span class="keyword">module</span> = ngx_modules[m]-&gt;ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;actions.init(cycle, ngx_timer_resolution) != NGX_OK) &#123;</span><br><span class="line">        <span class="comment">/* fatal */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ngx_event_process_init</code>注册的事件中就有<code>ngx_epoll_module</code>模块(ngx_modules.c),可以说<code>ngx_epoll_module</code>是真正处理事件的地方。<code>ngx_event_process_init</code>中调用的<code>module-&gt;actions.init</code>在这里本质就是<code>ngx_epoll_init</code></p></li><li><p><code>ngx_epoll_init</code>中进行了<code>ngx_event_actions</code>事件的注册：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_event_actions = ngx_epoll_module_ctx.actions;</span><br></pre></td></tr></table></figure></li><li><p>nginx的work进程处理事件实际调用的是<code>ngx_event_actions.process_events</code>,那么就等同于<code>ngx_epoll_module</code>中的<code>ngx_epoll_process_events</code>函数。</p></li><li><p><code>ngx_epoll_process_events</code>中调用<code>epoll_wait</code>来接收事件，接收到的事件通过<code>event_list[i].data.ptr</code>用户自定义指针来进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只列出核心步骤，省略其他代码</span></span><br><span class="line"><span class="comment">//使用epoll的异步io来获取事件</span></span><br><span class="line">events = epoll_wait(ep, event_list, (<span class="keyword">int</span>) nevents, timer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; events; i++) &#123;</span><br><span class="line">    <span class="comment">//读取触发的事件，触发的事件是之前通过epoll_ctl注册到ep中的。</span></span><br><span class="line">    revents = event_list[i].events;</span><br><span class="line">    <span class="comment">//用户自定义的结构体指针，这里是nginx中的ngx_connection_s结构</span></span><br><span class="line">    c = event_list[i].data.ptr;</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    rev = c-&gt;read;</span><br><span class="line">    <span class="keyword">if</span> ((revents &amp; EPOLLIN) &amp;&amp; rev-&gt;active) &#123;</span><br><span class="line">        rev-&gt;handler(rev);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//写入数据</span></span><br><span class="line">     wev = c-&gt;write;</span><br><span class="line">     <span class="keyword">if</span> ((revents &amp; EPOLLOUT) &amp;&amp; wev-&gt;active) &#123;</span><br><span class="line">             wev-&gt;handler(wev);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>epoll事件处理通过调用<code>event_list[i].data.ptr</code>指针来指向具体实现进行处理。而事件的注册，则由<code>ngx_event_actions.add/add_conn</code>来调用对应的注册事件<code>epoll_ctl</code>来实现。</p><ol><li><code>ngx_event_actions.add/add_conn</code>相当于一个抽象接口，实现注册的一方，只需要根据<code>add</code>接口的定义<code>ngx_int_t  (*add)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);</code>实现注册即可。而调用的函数也只需要调用对应的<code>ngx_event_actions.add</code>，传递对应的参数，不用关系内部实现。</li><li><code>#define ngx_add_event        ngx_event_actions.add</code>被进一步封装成<code>ngx_handle_read_event, ngx_handle_write_event</code>等，由业务模块来进行调用注册。</li><li>业务模块调用<code>ngx_handle_write_event</code>等事件注册时机通常在<code>ngx_module_s</code>结构下的<code>ngx_command_t</code>模块，比如<code>ngx_http_module</code>模块的定义如下：</li></ol> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_command_t</span>  ngx_http_commands[] = &#123;</span><br><span class="line"></span><br><span class="line">&#123; ngx_string(<span class="string">"http"</span>),</span><br><span class="line">  NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,</span><br><span class="line">  ngx_http_block, <span class="comment">//改函数中进行了事件注册的调用。</span></span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="literal">NULL</span> &#125;,</span><br><span class="line"></span><br><span class="line">  ngx_null_command</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ngx_module_t</span>  ngx_http_module = &#123;</span><br><span class="line">    NGX_MODULE_V1,</span><br><span class="line">    &amp;ngx_http_module_ctx,                  <span class="comment">/* module context */</span></span><br><span class="line">    ngx_http_commands,                     <span class="comment">/* module directives */</span></span><br><span class="line">    NGX_CORE_MODULE,                       <span class="comment">/* module type */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* init master */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* init module */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* init process */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* init thread */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* exit thread */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* exit process */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* exit master */</span></span><br><span class="line">    NGX_MODULE_V1_PADDING</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="4"><li>而每个模块的<code>ngx_command_t</code>结构，都会在<code>ngx_conf_handler</code>函数中进行处理：</li></ol> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmd = ngx_modules[i]-&gt;commands;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">rv = cmd-&gt;<span class="built_in">set</span>(cf, cmd, conf);</span><br></pre></td></tr></table></figure></li></ol><h4 id="nginx注册机制结构图"><a class="header-anchor" href="#nginx注册机制结构图"></a>nginx注册机制结构图</h4><p>根据Nginx的注册机制，我们把结构流程图分为了三个部分：</p><ol><li>编译时控制注册哪些模块</li><li>运行时模块注册执行</li><li>运行时事件处理函数注册执行</li></ol><p>前文已提过，nginx的模块注册控制是根据<code>configure</code>配置来控制是否编译某些文件，以及生成对应的<code>ngx_module.c</code>文件来控制注册列表。而执行的时候，则根据<code>ngx_module.c</code>文件中的模块列表的全局变量值<code>ngx_modules</code>来执行对应模块实现的接口。<br>TODO 对应的commands没有体现<br><img src="/2021/07/11/nginx源码阅读/%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8C%E6%9C%BA%E5%88%B6.drawio.png" alt="nginx模块注册机制"></p><p>nginx通过以上机制对事件处理模块进行注册，实例化事件处理接口<code>ngx_event_actions</code>（这个变量只有一个，也就是说nginx同时只能有一个事件处理模块）。<br>nginx通过事件处理统一接口<code>ngx_event_actions.add</code>，来进行事件处理函数的注册，同样删除事件也有相应的接口，而事件注册的具体方式，则通过上述注册的事件处理模块来实现(如<code>epoll</code>,<a href="https://blog.csdn.net/s2603898260/article/details/106821040" target="_blank" rel="noopener">一些epoll示例</a>)。<br>TODO 该图还需要修改和细化<br><img src="/2021/07/11/nginx源码阅读/%E4%BA%8B%E4%BB%B6%E6%B3%A8%E5%86%8C%E6%9C%BA%E5%88%B6.drawio.png" alt="nginx事件注册机制"></p><h4 id="一个事件触发流程"><a class="header-anchor" href="#一个事件触发流程"></a>一个事件触发流程</h4><ol><li><p>nginx启动后会监听配置的端口，监听端口后才会进行fork子进程，此时所有nginx都会监听对应的端口。使用算法让其中一个子进程获得fd</p><ol><li>为了方式<code>惊群</code>效应，通过获取互斥锁的方式保证只有一个子进程获取到fd。<a href="https://blog.csdn.net/u012062760/article/details/48732535" target="_blank" rel="noopener">参考</a></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngx_process_events_and_timers</span></span><br><span class="line"> <span class="keyword">if</span> (ngx_use_accept_mutex) &#123;</span><br><span class="line">     <span class="keyword">if</span> (ngx_accept_disabled &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         ngx_accept_disabled--;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//在此函数中尝试进行加锁，争抢锁。</span></span><br><span class="line">         <span class="keyword">if</span> (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//抢到锁，使用post机制进行通知</span></span><br><span class="line">         <span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">             flags |= NGX_POST_EVENTS;</span><br><span class="line"></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//没有抢到，推迟进行锁竞争</span></span><br><span class="line">             <span class="keyword">if</span> (timer == NGX_TIMER_INFINITE</span><br><span class="line">                 || timer &gt; ngx_accept_mutex_delay)</span><br><span class="line">             &#123;</span><br><span class="line">                 timer = ngx_accept_mutex_delay;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//尝试加锁，成功即可进行fd获取，失败则过一段时间再竞争。</span></span><br><span class="line"> ngx_trylock_accept_mutex(<span class="keyword">ngx_cycle_t</span> *cycle)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (ngx_shmtx_trylock(&amp;ngx_accept_mutex)) &#123;</span><br><span class="line"></span><br><span class="line">         ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                     <span class="string">"accept mutex locked"</span>);</span><br><span class="line">     ...</span><br><span class="line">     &#125;</span><br><span class="line">      ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="string">"accept mutex lock failed: %ui"</span>, ngx_accept_mutex_held);</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>加锁后，事件来临之前，获取锁work进程一直阻塞在<code>ngx_epoll_module.c:ngx_epoll_process_events-&gt;epoll_wait</code>，而没有获取锁的设置timer，进入下一轮循环。</p></li><li><p>触发<code>ngx_event_accept</code>函数，该函数在<code>ngx_event_process_init</code>时期被注册到了<code>epoll</code>中。</p><ol><li>获取链接相关信息, 使用<code>accept</code>获取返回新的<code>socket</code>。<br><img src="/2021/07/11/nginx源码阅读/accept%E8%AF%A6%E8%A7%A3.png" alt="accept原理"><a href="https://blog.csdn.net/Z_Stand/article/details/102535706" target="_blank" rel="noopener">图片来源</a></li><li>调用注册的<code>ls-&gt;handler</code>函数，这里对应的是<code>ngx_http_init_connection</code>，该函数是在<code>ngx_http_commands</code>里的<code>ngx_http_block</code>函数中被调用的。<ol><li><code>ngx_http_init_connection</code>初始化了一个timer(TODO干啥的？)，然后使用<code>ngx_handle_read_event</code>注册了一个读事件，事件<code>rev-&gt;handler = ngx_http_init_request</code></li></ol></li></ol></li><li><p>触发步骤2注册的<code>epoll</code>读事件，对应调用<code>rev-&gt;handler</code>函数，也就是<code>ngx_http_init_request</code>函数</p></li><li><p><code>ngx_http_init_request</code>函数处理完所有的http请求的数据处理。</p></li></ol><h4 id="事件轮转"><a class="header-anchor" href="#事件轮转"></a>事件轮转</h4><ol><li><code>nginx</code>的<code>master</code>进程在接收到请求后，将获取到的<code>fd</code>根据算法分配给某一个子进程，子进程触发<code>epoll</code>监听事件，获取执行<code>accept</code>，并根据类型增加<code>epoll</code>的读/写事件</li><li><code>epoll</code>触发读/写事件，进行读写操作。由于<code>nginx</code>的<code>epoll</code>是<code>ET</code>模式, 如果第一次读取数据没有读完，会继续增加对应的<code>epoll</code>读事件。(TODO)</li><li>继续触发后续事件。</li></ol><h4 id="timer机制"><a class="header-anchor" href="#timer机制"></a>timer机制</h4><p><a href="https://www.cnblogs.com/549294286/p/6058774.html" target="_blank" rel="noopener">Nginx的定时事件的实现</a><br>nginx的master进程使用的是系统信号来进行死循环的延时，关键函数<code>setitimer(ITIMER_REAL, &amp;itv, NULL)</code>.<br>在worker进程中，则是使用自定义的timer，来判断超时，以及调用超时函数。nginx中的timer是通过红黑树实现的。</p><ol><li><p>timer的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ngx_event_process_init函数中调用</span></span><br><span class="line"><span class="keyword">ngx_int_t</span></span><br><span class="line"> ngx_event_timer_init(<span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     ngx_rbtree_init(&amp;ngx_event_timer_rbtree, &amp;ngx_event_timer_sentinel,</span><br><span class="line">                     ngx_rbtree_insert_timer_value);</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> NGX_OK;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>整体流程，和timer的读取处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主for循环</span></span><br><span class="line"><span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"worker cycle"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要处理事件和event</span></span><br><span class="line">    ngx_process_events_and_timers(cycle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收到退出信号，terminate或者quit</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_terminate || ngx_quit) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ngx_modules[i]-&gt;exit_process) &#123;</span><br><span class="line">                ngx_modules[i]-&gt;exit_process(cycle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//内部会调用exit</span></span><br><span class="line">        ngx_master_process_exit(cycle);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ngx_process_events_and_timers:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在红黑树中找到对应的最新超时。</span></span><br><span class="line"><span class="keyword">if</span> (ngx_timer_resolution) &#123;</span><br><span class="line">     timer = NGX_TIMER_INFINITE;</span><br><span class="line">     flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     timer = ngx_event_find_timer();</span><br><span class="line">     flags = NGX_UPDATE_TIME;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//在evnet的wait前更新ngx_current_msec</span></span><br><span class="line"> delta = ngx_current_msec;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*事件处理核心工作函数，将timer传递给epoll_wait中，作为超时时间。</span></span><br><span class="line"><span class="comment"> 如果该timer从epoll_wait中超时，那么证明这个timer到期了，</span></span><br><span class="line"><span class="comment"> 可以执行后面的ngx_event_expire_timers */</span></span><br><span class="line"> (<span class="keyword">void</span>) ngx_process_events(cycle, timer, flags);</span><br><span class="line"></span><br><span class="line"> delta = ngx_current_msec - delta;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//只有超过了1ms，才会执行timer中的超时。</span></span><br><span class="line"> <span class="keyword">if</span> (delta) &#123;</span><br><span class="line">     ngx_event_expire_timers();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>timer的添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本质上就是向红黑树中插入节点</span></span><br><span class="line"><span class="keyword">static</span> ngx_inline <span class="keyword">void</span></span><br><span class="line"> ngx_event_add_timer(<span class="keyword">ngx_event_t</span> *ev, <span class="keyword">ngx_msec_t</span> timer)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">ngx_msec_t</span>      key;</span><br><span class="line">     <span class="keyword">ngx_msec_int_t</span>  diff;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     ngx_mutex_lock(ngx_event_timer_mutex);</span><br><span class="line"></span><br><span class="line">     ngx_rbtree_insert(&amp;ngx_event_timer_rbtree, &amp;ev-&gt;timer);</span><br><span class="line"></span><br><span class="line">     ngx_mutex_unlock(ngx_event_timer_mutex);</span><br><span class="line"></span><br><span class="line">     ev-&gt;timer_set = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><p>红黑树：<br><a href="https://blog.csdn.net/jjc120074203/article/details/78780221" target="_blank" rel="noopener">快速理解红黑树原理</a><br><a href="https://www.jianshu.com/p/038585421b73" target="_blank" rel="noopener">红黑树之原理详解</a></p><h3 id="nginx中的事件机制"><a class="header-anchor" href="#nginx中的事件机制"></a>nginx中的事件机制</h3><p><a href="https://tangocc.github.io/2018/07/08/nginx-event-model/" target="_blank" rel="noopener">参考</a></p><ol><li><p>nginx通过<code>accept_mutex</code>锁来解决惊群问题，意味着同一时间一个请求只有一个进程接收到</p></li><li><p>当进程接收到数据后，事件模块产生事件，并添加到事件队列中。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//epoll触发事件</span></span><br><span class="line">events = epoll_wait(ep, event_list, (<span class="keyword">int</span>) nevents, timer);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//这里将读写事件放到ngx_posted_accept_events或者ngx_posted_events事件中</span></span><br><span class="line"><span class="comment">//在ngx_process_events_and_timers函数中的ngx_event_process_posted中进行处理</span></span><br><span class="line"><span class="comment">//猜测这个锁是在多线程的模式下才加上的</span></span><br><span class="line">ngx_mutex_lock(ngx_posted_events_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; events; i++) &#123;</span><br><span class="line">    c = event_list[i].data.ptr;</span><br><span class="line"></span><br><span class="line">    rev = c-&gt;read;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; NGX_POST_EVENTS) &#123;</span><br><span class="line">        <span class="built_in">queue</span> = (<span class="keyword">ngx_event_t</span> **) (rev-&gt;accept ?</span><br><span class="line">                        &amp;ngx_posted_accept_events : &amp;ngx_posted_events);</span><br><span class="line"></span><br><span class="line">        ngx_locked_post_event(rev, <span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事件放到<code>ngx_posted_accept_events</code>队列或<code>ngx_posted_events</code>队列后，由<code>ngx_process_events_and_timers</code>函数进行处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取防止惊群的锁</span></span><br><span class="line"><span class="keyword">if</span> (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理事件接收的事件</span></span><br><span class="line"><span class="keyword">if</span> (ngx_posted_accept_events) &#123;</span><br><span class="line">    ngx_event_process_posted(cycle, &amp;ngx_posted_accept_events);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放锁，防止阻塞其他进程</span></span><br><span class="line"><span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">    ngx_shmtx_unlock(&amp;ngx_accept_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理其他事件</span></span><br><span class="line">ngx_event_process_posted(cycle, &amp;ngx_posted_events);</span><br></pre></td></tr></table></figure></li></ol><p>防止惊群问题，nginx在后续采用了新的方式<code>Socket ReusePort</code>来处理。同时对应的就是linux系统中的<a href="https://lwn.net/Articles/542629/" target="_blank" rel="noopener">SO_REUSEPORT</a>参数。粗浅理解可<a href="http://xiaorui.cc/archives/2413" target="_blank" rel="noopener">参考</a>，<a href="https://zhuanlan.zhihu.com/p/351065391" target="_blank" rel="noopener">其他一些参考</a></p><h1>NEXT：</h1><p>使用gdb+debug日志更加快捷和方便。</p><ol><li>nginx的web缓存机制(相同请求缓存返回),NGINX为单进程模型，不存在互斥问题，直接到cache中找即可，只是数据写入如果要进行落盘的时候，是异步操作。</li><li>编写一个基于<code>epoll</code>的状态机。epoll状态机只能基于fd轮转，而触发只能通过内核软中断触发。epoll是用于io复用层面，意味着必须有io操作。业务层面的状态转换并没有io操作，并不适合这个。</li><li>更新一些图和说明</li></ol><h4 id="nginx中的命名习惯"><a class="header-anchor" href="#nginx中的命名习惯"></a>nginx中的命名习惯</h4><ol><li>几乎所有的通用变量都使用ngx_xxx进行了重定义，比如<code>intptr_t-&gt;ngx_int_t</code>。至于<code>intptr_t</code>数据结构的解析，<a href="https://www.cnblogs.com/yinbiao/p/12566738.html" target="_blank" rel="noopener">可参考</a></li><li>nginx中，_s结尾的都代表是定义的结构体，_t都代表在声明变量时需要使用的类型，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct ngx_log_s         ngx_log_t;</span><br><span class="line">struct ngx_log_s &#123; //_s用于定义结构</span><br><span class="line"> ngx_uint_t           log_level;</span><br><span class="line"> ngx_open_file_t     *file;</span><br><span class="line"> ...</span><br><span class="line"> &#125;;</span><br><span class="line"> ngx_log_t        *log;  //_t用于声明变量</span><br></pre></td></tr></table></figure></li></ol><h4 id="nginx中数据结构"><a class="header-anchor" href="#nginx中数据结构"></a>nginx中数据结构</h4><h4 id="nginx的数据共享"><a class="header-anchor" href="#nginx的数据共享"></a>nginx的数据共享</h4><h3 id="分析验证"><a class="header-anchor" href="#分析验证"></a>分析验证</h3><p>重新编译debug版本，来验证我们的猜想，或者使用gdb跟踪也是可以的。gdb跟踪更方便快捷，但是在多进程分析的时候，debug模式往往更方便。</p><h3 id="整体流程图"><a class="header-anchor" href="#整体流程图"></a>整体流程图</h3><h2 id="其他"><a class="header-anchor" href="#其他"></a>其他</h2><h3 id="nginx中的一些骚操作"><a class="header-anchor" href="#nginx中的一些骚操作"></a>nginx中的一些骚操作</h3><h4 id="内存节约"><a class="header-anchor" href="#内存节约"></a>内存节约</h4><ol><li><code>unsigned    recycled:1;</code><br>使用了<a href="https://www.runoob.com/cprogramming/c-bit-fields.html" target="_blank" rel="noopener">位域</a>的方法来减少内存的使用。<code>unsigned</code> == <code>unsigned int</code></li></ol><h3 id="参考"><a class="header-anchor" href="#参考"></a>参考</h3><p><a href="http://tengine.taobao.org/book/index.html" target="_blank" rel="noopener">Nginx开发从入门到精通</a><br><a href="https://cloud.tencent.com/developer/article/1447290" target="_blank" rel="noopener">通俗易懂的Nginx工作原理</a><br><a href="https://www.zhihu.com/question/486578358" target="_blank" rel="noopener">epoll 原理是如何实现的</a></p><h4 id="可以列出相关的看过的书籍，或者问题参考链接网页一类的。"><a class="header-anchor" href="#可以列出相关的看过的书籍，或者问题参考链接网页一类的。"></a>可以列出相关的看过的书籍，或者问题参考链接网页一类的。</h4><p>备注：<br>可以进行单独开帖：</p><ol><li>nginx中的一些骚操作</li><li>nginx中数据结构</li><li>nginx的数据共享</li><li>nginx的模块机制<ol><li>都可以在编译后的objs/ngx_modules.c查看哪些被注册。</li><li>模块分为几大类：<ol><li>事件模块，构建不同的事件触发框架，类似<code>epoll</code>, <code>poll</code>。这类模块不实现具体功能，只是配置不同的的事件触发器。</li><li>功能模块，如http模块…</li></ol></li><li>模块注册方式：<ol><li>有configure来控制文件拷贝，进而控制全局变量<code>ngx_modules</code>和<code>ngx_event_actions</code>，以此达到模块注册效果。</li><li>configure内容解析？？TODO</li></ol></li></ol></li><li>nginx中的events以及进程间通信</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx源码阅读分析(•̀⌄•́)&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本人主要使用的nginx源码是&lt;a href=&quot;http://nginx.org/download/nginx-1.0.15.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nginx-1.0.15&lt;/a&gt;，以降低阅读难度，毕竟需要了解的是大体框架和原理。最新的版本，代码量太大，会增加阅读理解难度，没有必要。而本文的阅读方法，也按照&lt;strong&gt;基本使用-&amp;gt;简单示例-&amp;gt;示例在源码中如何工作-&amp;gt;相关联版块实现逻辑-&amp;gt;结构化整理nginx逻辑框架&lt;/strong&gt;的方法来写文档。其核心思路围绕:&lt;strong&gt;什么功能-&amp;gt;功能如何实现&lt;/strong&gt;来进行分析，反复循环改过程以理解整个nginx源码。最后会提出一个实际问题，通过阅读源码后来提出相应的解决方案。&lt;br&gt;
有必要可以增加一个如何编写nginx的module的文章，单开篇，就不在这里写了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《鲁迅全集》读书笔记</title>
    <link href="http://yoursite.com/2021/07/10/%E3%80%8A%E9%B2%81%E8%BF%85%E5%85%A8%E9%9B%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/07/10/《鲁迅全集》读书笔记/</id>
    <published>2021-07-10T10:30:38.000Z</published>
    <updated>2022-01-07T07:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>来膜拜迅哥儿的作品(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>主题：迅哥儿，不用说了吧<br>类别：文学作品-&gt;小说+散文-&gt;迅哥儿<br>概要：略</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>迅哥儿的大名，在学生时代早已如雷贯耳，我也没有想过在二十多了还来品读他的作品。也是因为B站上一个介绍鲁迅先生的视频，让我重新燃起了阅读他作品的兴趣。这次没有要是要求的阅读理解，没有摘抄背诵，就单单的当做一个小说看，轻松愉悦的体验作品本身带来的第一感觉。<br>目前只看了第一二卷，里面有很多熟悉的文章，想看看再次阅读的感觉，可惜了没有当时读完某篇文章，就做记录导致遗失了许多。我也没有什么文学素养，是个认字的文盲，也就记录一些我觉得有趣，还在记忆里有些印象，或者对我来说眼前一亮的文章(没有亮的文章估计我没看懂)</p><h2 id="随感"><a class="header-anchor" href="#随感"></a>随感</h2><p>下面的文章是我看完后有所映象的文章，写下我的印象，有兴趣的可以自读原文</p><h3 id="第一卷"><a class="header-anchor" href="#第一卷"></a>第一卷</h3><h4 id="坟"><a class="header-anchor" href="#坟"></a>坟</h4><h5 id="我们现在怎样做父亲"><a class="header-anchor" href="#我们现在怎样做父亲"></a>我们现在怎样做父亲</h5><p>不得不说，那个父为刚的时代拥有现在(2020)部分人才能拥有的思想，着实佩服。<br><strong>‘这样，便是父母对于子女，应该健全的产生，尽力的教育，完全的解放。’</strong></p><h5 id="未有天才之前"><a class="header-anchor" href="#未有天才之前"></a>未有天才之前</h5><p>天才需要土壤，鲜花需要绿叶，不是说一个人是土壤就该贬责他，而众多肥沃的土壤，总会有长出天才的一天。<br><strong>‘天才并不是自生自长在深林荒野里的怪物，是由可以使天才生长的民众产生，长育出来的，所以没有这种民众，就没有天才。’</strong></p><h5 id="说胡须"><a class="header-anchor" href="#说胡须"></a>说胡须</h5><p>一个胡子的形式别人就说东说西，上纲上线，按现在的话说，吃多了。</p><h5 id="论“他妈的！”"><a class="header-anchor" href="#论“他妈的！”"></a>论“他妈的！”</h5><p>题目眼前一亮，原来这是“国骂”，一直流传至今啊。</p><h4 id="呐喊"><a class="header-anchor" href="#呐喊"></a>呐喊</h4><h5 id="自序"><a class="header-anchor" href="#自序"></a>自序</h5><p><strong>‘“假如一间铁屋子，是绝无窗户而万难破毁的，里面有许多熟睡的人们，不久都要闷死了，然而是从昏睡入死灭，并不感到就死的悲哀。现在你大嚷起来，惊起了较为清醒的几个人，使这不幸的少数者来受无可挽救的临终的苦楚，你倒以为对得起他们么？”<br>“然而几个人既然起来，你不能说决没有毁坏这铁屋的希望。”’</strong></p><h5 id="狂人日记"><a class="header-anchor" href="#狂人日记"></a>狂人日记</h5><p><strong>‘今天晚上，很好的月光。<br>我不见他，已是三十多年；今天见了，精神分外爽快。才知道以前的三十多年，全是发昏；然而须十分小心。不然，那赵家的狗，何以看我两眼呢？<br>我怕得有理。’</strong><br><strong>‘凡事总须研究，才会明白，古来时常吃人，我也还记得，可是不甚清楚。我翻开历史一查，这历史没有年代，歪歪斜斜的每页上都写着“仁义道德”几个字。我横竖睡不着，仔细看了半夜，才从字缝里看出字来，满本都写着两个字是“吃人”！’</strong></p><h5 id="一件小事"><a class="header-anchor" href="#一件小事"></a>一件小事</h5><p>如果这件小事放到现在，估计又是另外一个故事了……</p><h5 id="故乡"><a class="header-anchor" href="#故乡"></a>故乡</h5><p><strong>‘“阿！闰土哥，——你来了？…”<br>我接着便有许多话，想要连珠一般涌出：角鸡、跳鱼儿、贝壳、猹，…但又总觉得被什么挡着似的。单在脑里面回旋，吐不出口外去。<br>他站住了，脸上现出欢喜和凄凉的神情；动着嘴唇，却没有作声。他的态度终于恭敬起来了，分明的叫道：<br>“老爷！…”’</strong></p><h5 id="阿Q正传"><a class="header-anchor" href="#阿Q正传"></a>阿Ｑ正传</h5><p><strong>‘闲人还不完，只撩他，于是终而至于打。阿Ｑ在形式上打败了，被人揪住黄辫子，在壁上碰了四五个响头，闲人这才心满意足的得胜的走了，阿Ｑ站了一刻，心里想，“我总算被儿子打了，现在的世界真不像样…”于是也心满意足的得胜的走了。’</strong></p><h4 id="野草"><a class="header-anchor" href="#野草"></a>野草</h4><p>这个合集的文章我觉得都非常精炼，耐读，值得都看看</p><h5 id="秋夜"><a class="header-anchor" href="#秋夜"></a>秋夜</h5><p><strong>‘在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。’</strong></p><h5 id="我的失恋"><a class="header-anchor" href="#我的失恋"></a>我的失恋</h5><p><strong>‘我的所爱在山腰；<br>想去寻她山太高，<br>低头无法泪沾袍。<br>爱人赠我百蝶巾；<br>回她什么：猫头鹰。<br>从此翻脸不理我，<br>不知何故兮使我心惊。<br>……’</strong></p><h5 id="希望"><a class="header-anchor" href="#希望"></a>希望</h5><p><strong>‘我只得由我来肉搏这空虚中的暗夜了，纵使寻不到身外的青春，也总得自己来一掷我身中的迟暮。但暗夜又在那里呢？现在没有星，没有月光以至笑的渺茫和爱的翔舞；青年们很平安，而我的面前又竟至于并且没有真的暗夜。<br>绝望之为虚妄，正与希望相同！’</strong></p><h5 id="过客"><a class="header-anchor" href="#过客"></a>过客</h5><p><strong>‘翁——前面？前面，是坟。<br>客——（诧异地，）坟？<br>孩——不，不，不的。那里有许多许多野百合、野蔷薇，我常常去玩，去看他们的。’</strong><br><strong>‘客——料不定可能走完？…（沉思，忽然惊起，）那不行！我只得走。回到那里去，就没一处没有名目，没一处没有地主，没一处没有驱逐和牢笼，没一处没有皮面的笑容，没一处没有眶外的眼泪。我憎恶他们，我不回转去！’</strong></p><h5 id="狗的驳诘"><a class="header-anchor" href="#狗的驳诘"></a>狗的驳诘</h5><p><strong>‘“呔！住口！你这势利的狗！”<br>“嘻嘻！”他笑了，还接着说，“不敢，愧不如人呢。”’</strong></p><h5 id="聪明人和傻子和奴才"><a class="header-anchor" href="#聪明人和傻子和奴才"></a>聪明人和傻子和奴才</h5><h3 id="第二卷"><a class="header-anchor" href="#第二卷"></a>第二卷</h3><h4 id="热风"><a class="header-anchor" href="#热风"></a>热风</h4><h5 id="随感录三十六"><a class="header-anchor" href="#随感录三十六"></a>随感录三十六</h5><p><strong>‘有人说：“我们要特别生长；不然，何以为中国人！”<br>于是乎要从“世界人”中挤出。<br>于是乎中国人失了世界，却暂时仍要在这世界上住！——这便是我的大恐惧。’</strong></p><h5 id="随感录四十一"><a class="header-anchor" href="#随感录四十一"></a>随感录四十一</h5><p><strong>‘纵令不过一洼浅水，也可以学学大海；横竖都是水，可以相通。几粒石子，任他们暗地里掷来；几滴秽水，任他们从背后泼来就是了。’</strong></p><h5 id="随感录四十七"><a class="header-anchor" href="#随感录四十七"></a>随感录四十七</h5><p><strong>‘张三、李四是同时人。张三记了古典来做古文；李四又记了古典，去读张三做的古文。我想：古典是古人的时事，要晓得那时的事，免不了翻着古典；现在两位既然同时，何妨老实说出，一目了然，省却你也记古典，我也记古典的工夫呢？’</strong><br>正如现在的什么yyds，awsl……</p><h5 id="随感录五十四"><a class="header-anchor" href="#随感录五十四"></a>随感录五十四</h5><p><strong>‘要想进步，要想太平，总得连根的拔去了“二重思想”。因为世界虽然不小，但彷徨的人种，是终竟寻不出位置的。’</strong></p><h5 id="六十六-生命的路"><a class="header-anchor" href="#六十六-生命的路"></a>六十六 生命的路</h5><p><strong>‘什么是路？就是从没路的地方践踏出来的，从只有荆棘的地方开辟出来的。’</strong></p><h4 id="彷徨"><a class="header-anchor" href="#彷徨"></a>彷徨</h4><h5 id="伤逝"><a class="header-anchor" href="#伤逝"></a>伤逝</h5><p><strong>‘但是，这却更虚空于新的生路；现在所有的只是初春的夜，竟还是那么长。我活着，我总得向着新的生路跨出去，那第一步，——却不过是写下我的悔恨和悲哀，为子君，为自己。’</strong></p><h5 id="弟兄"><a class="header-anchor" href="#弟兄"></a>弟兄</h5><p><strong>‘“不！”他不放手，“我来办。”<br>月生也就不再去抢着办了。沛君便十分安心似的沉静地走到自己的桌前，看着呈文，一面伸手去揭开了绿锈斑斓的墨盒盖。’</strong></p><h4 id="朝花夕拾"><a class="header-anchor" href="#朝花夕拾"></a>朝花夕拾</h4><p><strong>‘前天，已将《野草》编定了，这回便轮到陆续载在《莽原》上的《旧事重提》，我还替他改了一个名称：《朝花夕拾》。’</strong><br>很多我们熟知的文章，记录着迅哥儿的过去……</p><h4 id="故事新编"><a class="header-anchor" href="#故事新编"></a>故事新编</h4><p>非常有趣，建议去看看。<br>嫦娥为何奔月？是因为受不了后裔天天只能给他做乌鸦炸酱面…… 哈哈哈</p><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><p>不知道是不是受了读书时的影响，迅哥儿的文章，但凡一看，有些异样的语句，就觉得他在讽刺着什么。但有些他讽刺的文章，写的又深刻形象，比如《牺牲谟》。<br>总的来说，目前只看了前两卷，还是非常值得一读。个人感觉，迅哥儿对于人物形象塑造能力极其强，几句话，几个字，一个人就活了。而讽刺现象，一类人，你马上能够真真切切的在现实中看到，就是某个人的某个嘴脸。<br>很多文章，还是需要细细读细细品，多读几次。<br>后面空了继续看后面的……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来膜拜迅哥儿的作品(•̀⌄•́)&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;主题：迅哥儿，不用说了吧&lt;br&gt;
类别：文学作品-&amp;gt;小说+散文-&amp;gt;迅哥儿&lt;br&gt;
概要：略&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>《财富自由之路》粗读</title>
    <link href="http://yoursite.com/2021/03/09/%E3%80%8A%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF%E3%80%8B%E7%B2%97%E8%AF%BB/"/>
    <id>http://yoursite.com/2021/03/09/《财富自由之路》粗读/</id>
    <published>2021-03-09T09:19:39.000Z</published>
    <updated>2022-01-07T07:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>钱钱钱(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p>一共三册。<br>主题： 讲述怎样一步一步的实现财富自由<br>类别：经济学-&gt;实用性-&gt;投资理财+鸡汤<br>概要：从金钱管理，投资理财，自我成长，金钱价值观等方面给出建议，让你更快的实现财务自由。</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>作者核心思想：教会你如何规划自己的财产，制定计划，以实现财务自由。</p><p>而我的想法非常明确，赚钱。</p><h2 id="主要观点"><a class="header-anchor" href="#主要观点"></a>主要观点</h2><h3 id="7年内赚到你第一个1000万"><a class="header-anchor" href="#7年内赚到你第一个1000万"></a>7年内赚到你第一个1000万</h3><p>讲述一条从0开始到财富自由的路，给出大概的轮廓和基础理念。</p><ol><li>财富不会从天而降——除非你指望着中彩票头奖。但每个人可以做到的是：做出正确的决定，制订一个长期计划，使自己获得财务保障，甚至创造出一份财富，以此来改善自己的生活质量。</li><li>变富的途径很多，本书中为您详述其中一种，它由以下4种策略组成：<ol><li>储蓄一定比例的金钱。</li><li>使用储蓄资金进行投资。</li><li>提高自己的收入。</li><li>从每次加薪中提取一定比例进行储蓄。</li></ol></li><li>仅仅闭门读书不会让你变得富有。更多地运用这本书，使这本书的知识成为你知识体系的一部分，你才能变得富有。</li><li>首先进行自我分析，分析完成后，在进行计划制定。</li><li>我们在等谁？在等什么？是上帝还是命运？“所有的傻瓜都生活在希望和等待之中。”</li><li>将困难当作成长的机会</li><li>扩大你的个人范畴</li><li>变化的5个层次：<ol><li>你意识到自己对现状感到不满意</li><li>期待的结果没有出现，你意识到，仅仅只是采取行动还远远不够。</li><li>学到的技巧对你起到了一定的帮助</li><li>用不同的方向看待问题和世界</li><li>通过改变对自身的认知，我们可以带来巨大的变化。</li></ol></li><li>成功日记和自信</li><li>没有哪个奇迹的发生不需要冒险</li><li>好运不是一种不通过努力，光靠期待就可以获得的东西。</li><li>储存资本+识别机会+果断地做出决定并采取行动 -&gt; 好运</li><li>大多数人都高估了自己1年内能做到的事情，也低估了自己10年内能做到的事情。</li><li>清晰明确的目标，可量化的目标，并且随时回顾目标，让其能够不断在你脑海里生根。</li><li>穷和富裕在于每次细小的选择。或者说，富人思想，要么暴富，要么难受死。</li><li>教练法则。让一个教练来督促你成长，少走弯路。</li><li>定下一个大目标，即使他看起来不可能完成。</li><li>大力发展自己的优势，而不是着重弥补自己的劣势。</li><li>当你为自己设立了极限，你就会设法达到你的极限。你不仅仅要对自己的失败承担责任，也要对你的成功承担责任。</li><li>你如果认为成功是不可重复的，就失去了提升自我价值的机会。</li><li>一个付出110％努力，主动摒弃所有借口的人，势必取得成功。</li><li>明确你的信念，并让它变得更加深刻。比如我必须要改变。</li><li>你需要建立一个能让自己变得富有的信念，并且加固它。</li><li>不要陷入债务危机。</li><li>增加收入方式：<ol><li>展示和提升你的强项，和价值。</li><li>安排的事情立马去做，不要有拖延症。</li><li>让自己称为专家。</li></ol></li><li>储蓄是必要的。</li><li>影响收入的版块：<ol><li>能力</li><li>精力</li><li>知名度/影响力</li><li>自我评价</li><li>创意</li></ol></li><li>收入来源：<ol><li>产品价值</li><li>知识价值</li><li>服务价值</li><li>创意价值</li></ol></li><li>当你可以靠自己的资产生活，而不是工作，才能称为富有。</li><li>学会寻找新的收入。</li><li>市场波动一直存在，要考虑到大危机的可能性。</li><li>股民需要遵循的原则:<ol><li>区分投资和投机，投资是可以在固定的一段时间获得收益，投机是卖出时获得收益。</li><li>区分债务和投资，债务是花钱，投资是赚钱。</li><li>确定你的资产类型：<ol><li>货币资产</li><li>有型资产</li><li>赌博</li></ol></li><li>有型资产完胜货币资产。</li><li>必须承担风险</li><li>分散投资</li></ol></li><li>投资三部曲：<ol><li>财务保障，是指发生意外情况(生病，失业)能帮助你的财产。这部分钱用于定期，或者现金存放。</li><li>财务安全，是指产生的利息能够够你的日常开支。这部分钱按照4:4:2(低:适中:中风险)的比例用于投资。</li><li>财务自由，除了上述两笔钱，剩下的钱，用于较高风险投资，一般比例5:5(中:高风险)</li></ol></li><li>近朱者赤</li><li>想尽办法获得一个优秀的导师。记住如何使他人收益。</li><li>要拥有感激之心，付出一定的金钱。</li><li>知识只有运用起来才是力量。</li><li>建立一个团队，让你的富足持续下去。</li></ol><h3 id="3年内让你的个人资产翻一翻"><a class="header-anchor" href="#3年内让你的个人资产翻一翻"></a>3年内让你的个人资产翻一翻</h3><p>学习如何显著提高自己的收入——在并不需要延长工作时间或者增加工作强度。</p><ol><li>仓鼠之轮：做为一个赚钱工具，不停的赚的更多，而又花的更多，却不思考自身的意义和价值，并且无法停歇。</li><li>尝试开启自己的第二职业，第二职业就是能够带来很多收益(至少能够做好了带来很多收益)</li><li>思想决定一切，穷人常常不知道自己想要什么，中产阶级常常是负担不起，富裕阶级常常想怎么能负担起。</li><li>沉静在做自己喜爱事务之中，某个瞬间感觉到了永恒，这就会“心流”。</li><li>要知道自己真正想要什么。</li><li>列出自己的爱好，列出自己的能力，找到这些交集，交集越多的地方，越是适合你的工作。</li><li>找工作的方法：<ol><li>熟人内推</li><li>找到感兴趣的公司，针对性的制作简历。</li></ol></li><li>专家途径：<ol><li>追求卓越</li><li>与众不同</li><li>成为第一人</li><li>如果不能成为第一人，就创造新的定位。</li><li>宁可精致，不要宽泛。</li><li>选择基本需求，不要搞套路。顺应时代</li><li>选择一个目标群体。</li><li>为他人解决一个问题。</li><li>宣传自己和自己的产品。</li><li>给自己的产品或服务定价。</li></ol></li><li>idea的产生：<ol><li>你想解决一个问题，并为之思考。</li><li>调研别人的处理方式，考虑其优点和不足</li><li>结合自己的想法慢慢勾勒出一个方案</li><li>灵光乍现</li></ol></li><li>明白自己的定位和自己擅长的东西，如何变成与众不同的产品以及能解决实际问题。</li><li>企业家的特质：<ol><li>企业家都敢于冒险</li><li>能经受住失望</li><li>渴望权利</li><li>更多的自信心</li><li>善于控制资金</li><li>榜样作用</li><li>好胜心</li><li>求知欲</li><li>经营直觉</li></ol></li><li>销售行业可以锻炼一些企业家的特性</li><li>企业家的6项基本任务概要：<ol><li>寻找优秀的同事与合伙人。</li><li>监督盈利以及创建机制。</li><li>对您的公司进行创新。</li><li>从一切多余的事务中解脱出来。</li><li>保持您的宏伟蓝图及其意义永远充满活力。</li><li>想出一条退出的策略。</li></ol></li><li>好的机制就是领导的依赖性越小。</li></ol><h3 id="为你量身定制的投资组合"><a class="header-anchor" href="#为你量身定制的投资组合"></a>为你量身定制的投资组合</h3><p>更加安全的高效的提升自己的资产，前提得是你有资金来投资。<br>1.</p><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><p>财富自由之路有三本，我也是粗读了前两本，也是分为三个阶段，财务保障-&gt;财务安全-&gt;财务自由。从最开始的如何赚钱到后面的如何理财，到如何定位，工作，当投资人等等……<br>总的来说，它大概的给你指出了一条通往财富自由的路子，而其中80%的内容或许你都知道，更加类似于鸡汤一样的东西。对于我而言，最大的鸡汤收获莫过于一句“你在等什么？上帝还是命运？”，同样其中也不乏一些理财观念，而我最赞同的就是对金钱的划分：保障资金，安全资金和自由资金。<br>总的来说，粗读还是有一定收获的，至于第三本，我暂时没有看了，因为没到哪个地步，也没了兴趣，毕竟现在还在实现财务保障阶段。至于进行分析阅读和精读，感觉没啥必要，没有那么多高深的知识，一看你我都明白，重点在行动。</p><h3 id="相关"><a class="header-anchor" href="#相关"></a>相关</h3><p>这本书和小狗钱钱的理念相似，但是我更喜欢那本书，更有趣，更生动，而又较为透彻的传输了理财理念。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;钱钱钱(•̀⌄•́)&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一共三册。&lt;br&gt;
主题： 讲述怎样一步一步的实现财富自由&lt;br&gt;
类别：经济学-&amp;gt;实用性-&amp;gt;投资理财+鸡汤&lt;br&gt;
概要：从金钱管理，投资理财，自我成长，金钱价值观等方面给出建议，让你更快的实现财务自由。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="经济" scheme="http://yoursite.com/tags/%E7%BB%8F%E6%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>《nginx入门到精通》读书笔记</title>
    <link href="http://yoursite.com/2021/03/09/%E3%80%8Anginx%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/03/09/《nginx入门到精通》读书笔记/</id>
    <published>2021-03-09T02:29:26.000Z</published>
    <updated>2022-01-07T07:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>从实践入门介绍nginx(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><a href="http://tengine.taobao.org/book/index.html" target="_blank" rel="noopener">在线阅读</a><br>主题： nginx模块开发和原理解析<br>类别：计算机-&gt;实用性+理论性论述书-&gt;nginx<br>概要：从模块开发了解nginx的使用以及nginx整体结构。从源码原理解析了解nginx底层设计和各种优化操作。<br>这个玩意儿太监了，没有写完，很多东西都只有大纲。</p><a id="more"></a><h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2><p>作者想通过文章帮助人们了解nginx的模块开发，和其内部实现原理。<br>而我也想进行nginx源码学习，了解其中的实现原理和架构，以及一些实现亮点。<br>为了更深入学习，需要将nginx源码和书结合起来看，虽然书中选择了1.2的版本，为了降低难度，我选择了<a href="http://nginx.org/download/nginx-1.0.15.tar.gz" target="_blank" rel="noopener">nginx-1.0.15</a>版本。</p><h2 id="主旨"><a class="header-anchor" href="#主旨"></a>主旨</h2><h3 id="文章的核心内容"><a class="header-anchor" href="#文章的核心内容"></a>文章的核心内容</h3><h4 id="核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。"><a class="header-anchor" href="#核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。"></a>核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。</h4><h3 id="整本书的架构"><a class="header-anchor" href="#整本书的架构"></a>整本书的架构</h3><h4 id="作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。"><a class="header-anchor" href="#作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。"></a>作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。</h4><h3 id="问题处理"><a class="header-anchor" href="#问题处理"></a>问题处理</h3><h4 id="作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。"><a class="header-anchor" href="#作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。"></a>作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。</h4><h2 id="章节"><a class="header-anchor" href="#章节"></a>章节</h2><h3 id="nginx模块开发"><a class="header-anchor" href="#nginx模块开发"></a>nginx模块开发</h3><p>该模块主要进行nginx整体架构的初步介绍，并指导进行相关的实践操作，进行相关模块开发。</p><h4 id="nginx架构"><a class="header-anchor" href="#nginx架构"></a>nginx架构</h4><p>先上一幅nginx架构图：<br><img src="/2021/03/09/《nginx入门到精通》读书笔记/nginx%E6%9E%B6%E6%9E%84.png" alt><br>这幅图很明显的说明了nginx的大架构，其中：<br>master：负责接收外部控制信号，管理work进程<br>worker：负责处理请求连接，每个worker之间平等竞争连接。<br>优势：</p><ol><li>work使用进程，而不是线程(虽然也支持线程模式)，是为了最大限度避免线程切换开销，并且work数量一般和cpu数量相同，减少cpu上下文切换。</li><li>事件处理采用了异步非阻塞形式，使进程处理请求时不会阻塞。<br>而通常web服务器事件分为三类：网络事件，信号(信号事件如何处理???)和定时器。而nginx的这三个事件处理方式可以用一段伪代码表示：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//执行事件</span></span><br><span class="line">    <span class="keyword">for</span> t in run_tasks:</span><br><span class="line">        t.handler();</span><br><span class="line">    update_time(&amp;now);</span><br><span class="line">    timeout = ETERNITY;</span><br><span class="line">    <span class="comment">//处理定时器</span></span><br><span class="line">    <span class="keyword">for</span> t in wait_tasks: <span class="comment">/* 已经排序，依次取出超时最小定时器 */</span></span><br><span class="line">        <span class="keyword">if</span> (t.time &lt;= now) &#123;</span><br><span class="line">            t.timeout_handler();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = t.time - now;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//网络事件触发，或者定时器到期</span></span><br><span class="line">    nevents = poll_function(events, timeout);</span><br><span class="line">    <span class="keyword">for</span> i in nevents:</span><br><span class="line">        task t;</span><br><span class="line">        <span class="keyword">if</span> (events[i].type == READ) &#123;</span><br><span class="line">            t.handler = read_handler;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* events[i].type == WRITE */</span></span><br><span class="line">            t.handler = write_handler;</span><br><span class="line">        &#125;</span><br><span class="line">        run_tasks_add(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nginx基础概念"><a class="header-anchor" href="#nginx基础概念"></a>nginx基础概念</h4><p><strong>connection</strong>：对tcp链接的封装，其中包括socket，读写事件。<br>connection生命周期：master读取配置文件，建立监听并获得fd-&gt;fork子进程，获得该fd-&gt;竞争获取链接，并建立链接-&gt;客户端或者服务端完成时间后断开。<br>链接竞争机制伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处的设计是为了避免某些进程已经没有剩余链接却还能竞争到锁，</span></span><br><span class="line"><span class="comment">//而有剩余链接的进程却竞争不到。</span></span><br><span class="line"><span class="comment">//当前进程总连接数/8 - 当前剩余连接数</span></span><br><span class="line">ngx_accept_disabled = ngx_cycle-&gt;connection_n / <span class="number">8</span></span><br><span class="line">    - ngx_cycle-&gt;free_connection_n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ngx_accept_disabled &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    ngx_accept_disabled--; <span class="comment">//(有必要???每次该值都会被上面覆盖)</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//尝试竞争锁</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">        flags |= NGX_POST_EVENTS;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer == NGX_TIMER_INFINITE</span><br><span class="line">                || timer &gt; ngx_accept_mutex_delay)</span><br><span class="line">        &#123;</span><br><span class="line">            timer = ngx_accept_mutex_delay;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>request</strong>：<br>很明显，这就是表示一个http的请求，其生命周期如下图(细节code???)：<br><img src="/2021/03/09/《nginx入门到精通》读书笔记/request%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt></p><p><strong>keepalive</strong>：<br>链接跟踪，在接收到第一个http请求后，不断开连接，如果一定时间内没有接到该客户端的后续请求再断开连接。对于大多数网页访问来说，keepalive是很有必要的。</p><p><strong>pipeline</strong>：<br>同时可以接收两个请求，即当客户端不用等到第一个请求完再发第二个请求。有点类似http2的处理方式。</p><p><strong>lingering_close</strong>：<br>在出现服务端错误的情况下，服务端返回错误信息，write到tcp的write buffer里，然后直接close。如果这个时候该链接的read buffer里还有数据，则会直接返回reset，丢弃write buffer里的内容。如果没有，则等write buffer里数据发送了再close。而lingering_close的作用，就是在出错write数据后，等一段时间再close，这段时间内仍然读取read buffer里的数据扔掉即可。</p><h4 id="基础数据结构"><a class="header-anchor" href="#基础数据结构"></a>基础数据结构</h4><p><strong>ngx_str_t</strong>：具体参考源码，并且自己进行相关调用。<br><strong>ngx_pool_t</strong>:</p><h3 id="nginx原理"><a class="header-anchor" href="#nginx原理"></a>nginx原理</h3><p>从架构深入到内部实现，讲解nginx源码的各个模块的关键设计。需要配合源码来进行阅读。</p><h4 id><a class="header-anchor" href="#"></a></h4><h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2><h3 id="所得"><a class="header-anchor" href="#所得"></a>所得</h3><h4 id="作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？"><a class="header-anchor" href="#作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？"></a>作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？</h4><h3 id="所想"><a class="header-anchor" href="#所想"></a>所想</h3><h4 id="看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。"><a class="header-anchor" href="#看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。"></a>看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。</h4><h3 id="相关"><a class="header-anchor" href="#相关"></a>相关</h3><h4 id="可以列出相关的看过的书籍，或者问题参考链接网页一类的。"><a class="header-anchor" href="#可以列出相关的看过的书籍，或者问题参考链接网页一类的。"></a>可以列出相关的看过的书籍，或者问题参考链接网页一类的。</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从实践入门介绍nginx(•̀⌄•́)&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;http://tengine.taobao.org/book/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在线阅读&lt;/a&gt;&lt;br&gt;
主题： nginx模块开发和原理解析&lt;br&gt;
类别：计算机-&amp;gt;实用性+理论性论述书-&amp;gt;nginx&lt;br&gt;
概要：从模块开发了解nginx的使用以及nginx整体结构。从源码原理解析了解nginx底层设计和各种优化操作。&lt;br&gt;
这个玩意儿太监了，没有写完，很多东西都只有大纲。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>阅读笔记框架</title>
    <link href="http://yoursite.com/2021/03/08/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2021/03/08/阅读笔记框架/</id>
    <published>2021-03-08T09:47:01.000Z</published>
    <updated>2022-01-07T07:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>好的笔记能体现出一本书的核心思想，能表达自己的心得体会，能帮助你快速回忆巩固。(•̀⌄•́)<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</p><hr><p><em>不同的书有不同的笔记方法，特定框架能更快速的明确笔记目的——读《如何阅读一本书》后所得</em></p><a id="more"></a><h2 id="检视阅读"><a class="header-anchor" href="#检视阅读"></a>检视阅读</h2><p>检视阅读的主旨在了解书的架构，核心内容。所以，大多数时候，你都只会得到一个概念性的东西，自己了解即可。至于笔记，更适合于名言名句那种记录方式，记录下表达核心思想的语句。<br><strong>如果要有笔记，也需要那么几个部分</strong>：</p><ol><li><p>书的概要</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 书名</span><br><span class="line">## 前言</span><br><span class="line">### 书的主题和分类</span><br><span class="line">### 整本书的核心内容，一到两句话</span><br><span class="line">### 作者写这本书的目的，或者他想解决什么问题？</span><br><span class="line">### 你期望能从书中获得什么</span><br></pre></td></tr></table></figure></li><li><p>列出文章中一些核心的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 主旨</span><br><span class="line">### 观点1</span><br><span class="line">### 观点2</span><br><span class="line">### 观点3</span><br><span class="line">....(不一定要全，看到了就记下)</span><br></pre></td></tr></table></figure></li><li><p>总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 结语</span><br><span class="line">###  延展</span><br><span class="line">#### 作者所提出的问题，是否就是你真正想问的问题？是否有必要进行分析阅读？理由？</span><br><span class="line">###  相关</span><br><span class="line">#### 可以列出相关的看过的书籍，或者问题参考链接网页一类的。</span><br></pre></td></tr></table></figure></li></ol><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 《nginx入门到精通》读书笔记</span><br><span class="line">date: 2021-03-09 10:29:26</span><br><span class="line">categories: 笔记</span><br><span class="line">tags: [nginx]</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">从实践入门介绍nginx(•̀⌄•́)</span><br><span class="line">　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</span><br><span class="line">* * *</span><br><span class="line">主题： nginx模块开发和原理解析</span><br><span class="line">类别：计算机-&gt;实用性+理论性论述书-&gt;nginx</span><br><span class="line">概要：从模块开发了解nginx的使用以及nginx整体结构。从源码原理解析了解nginx底层设计和各种优化操作。</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line">## 前言</span><br><span class="line">作者想通过文章帮助人们了解nginx的模块开发，和其内部实现原理。</span><br><span class="line">而我也想进行nginx源码学习，了解其中的实现原理和架构，以及一些实现亮点。</span><br><span class="line"></span><br><span class="line">## 主要观点</span><br><span class="line">### 观点1</span><br><span class="line">### 观点2</span><br><span class="line">### 观点3</span><br><span class="line"></span><br><span class="line">## 结语</span><br><span class="line">###  延展</span><br><span class="line">#### 作者所提出的问题，是否就是你真正想问的问题？是否有必要进行分析阅读？理由？</span><br><span class="line">###  相关</span><br><span class="line">#### 可以列出相关的看过的书籍，或者问题参考链接网页一类的。</span><br></pre></td></tr></table></figure><h2 id="分析阅读"><a class="header-anchor" href="#分析阅读"></a>分析阅读</h2><p>分析阅读的笔记结构，主要以结构笔记为主(记录全书的整体架构)，概念笔记(记录一个概念或观点)为辅。<br><strong>分析阅读的通用方法</strong>：</p><ol><li><p>进行一遍检视阅读，并获得以下信息：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 书名</span><br><span class="line">## 前言</span><br><span class="line">### 书的主题和分类</span><br><span class="line">### 整本书的核心内容，一到两句话</span><br><span class="line">### 作者写这本书的目的，或者他想解决什么问题？</span><br><span class="line">### 你期望能从书中获得什么</span><br></pre></td></tr></table></figure></li><li><p>开始进行分析阅读，并在阅读过程中完成以下笔记：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 章节</span><br><span class="line">### 第一章(章节内容名称，可以和书中相同，也可以自己拟定)</span><br><span class="line">#### 核心内容，主要观点</span><br><span class="line">### 第二章</span><br><span class="line">#### 核心内容，主要观点</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>分析阅读过程中完成以下笔记：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## 主旨</span><br><span class="line">###  文章的核心内容</span><br><span class="line">#### 核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。</span><br><span class="line">###  整本书的架构</span><br><span class="line">#### 作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。</span><br><span class="line">###  问题处理</span><br><span class="line">#### 作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。</span><br></pre></td></tr></table></figure></li><li><p>认真完成上述过程后：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## 结语</span><br><span class="line">###  所得</span><br><span class="line">#### 作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？</span><br><span class="line">###  所想</span><br><span class="line">#### 看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。</span><br><span class="line">###  相关</span><br><span class="line">#### 可以列出相关的看过的书籍，或者问题参考链接网页一类的。</span><br></pre></td></tr></table></figure></li></ol><p><strong>整体结构</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 书名</span><br><span class="line">## 前言</span><br><span class="line">### 书的主题和分类</span><br><span class="line">### 整本书的核心内容，一到两句话</span><br><span class="line">### 作者写这本书的目的，或者他想解决什么问题？</span><br><span class="line">### 你期望能从书中获得什么</span><br><span class="line"></span><br><span class="line">## 主旨</span><br><span class="line">###  文章的核心内容</span><br><span class="line">#### 核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。</span><br><span class="line">###  整本书的架构</span><br><span class="line">#### 作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。</span><br><span class="line">###  问题处理</span><br><span class="line">#### 作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。</span><br><span class="line"></span><br><span class="line">## 章节</span><br><span class="line">### 第一章(章节内容名称，可以和书中相同，也可以自己拟定)</span><br><span class="line">#### 核心内容，主要观点</span><br><span class="line">### 第二章</span><br><span class="line">#### 核心内容，主要观点</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">## 结语</span><br><span class="line">###  所得</span><br><span class="line">#### 作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？</span><br><span class="line">###  所想</span><br><span class="line">#### 看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。</span><br><span class="line">###  相关</span><br><span class="line">#### 可以列出相关的看过的书籍，或者问题参考链接网页一类的。</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 《nginx入门到精通》读书笔记</span><br><span class="line">date: 2021-03-09 10:29:26</span><br><span class="line">categories: 笔记</span><br><span class="line">tags: [nginx]</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">从实践入门介绍nginx(•̀⌄•́)</span><br><span class="line">　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan</span><br><span class="line">* * *</span><br><span class="line">主题： nginx模块开发和原理解析</span><br><span class="line">类别：计算机-&gt;实用性+理论性论述书-&gt;nginx</span><br><span class="line">概要：从模块开发了解nginx的使用以及nginx整体结构。从源码原理解析了解nginx底层设计和各种优化操作。</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line">## 前言</span><br><span class="line">作者想通过文章帮助人们了解nginx的模块开发，和其内部实现原理。</span><br><span class="line">而我也想进行nginx源码学习，了解其中的实现原理和架构，以及一些实现亮点。</span><br><span class="line"></span><br><span class="line">## 主旨</span><br><span class="line">###  文章的核心内容</span><br><span class="line">#### 核心内容，主要观点，支持什么，反对什么，主要依据，依据是否真实可靠。</span><br><span class="line">###  整本书的架构</span><br><span class="line">#### 作者怎么样突出的主旨，使用了什么手法，逻辑顺序如何，怎样让核心内容更加夯实。</span><br><span class="line">###  问题处理</span><br><span class="line">#### 作者想解决什么样的问题，是否解决，还有没有未解决的？未解决问题中，哪些是作者认为无法解决，哪些又需要你从其他地方去找到答案。</span><br><span class="line"></span><br><span class="line">## 章节</span><br><span class="line">### nginx模块开发</span><br><span class="line">该模块主要进行nginx整体架构的初步介绍，并指导进行相关的实践操作，进行相关模块开发。</span><br><span class="line">#### </span><br><span class="line">### nginx原理</span><br><span class="line">从架构深入到内部实现，讲解nginx源码的各个模块的关键设计。需要配合源码来进行阅读。</span><br><span class="line">#### </span><br><span class="line"></span><br><span class="line">## 结语</span><br><span class="line">###  所得</span><br><span class="line">#### 作者所提出的问题，是否就是你真正想问的问题？而他所提出的答案你是否赞成？如果有不赞成，说明原因。是否还有你想问的问题在书中没有提及，或者你又有了新的疑问书中没有给出答案？</span><br><span class="line">###  所想</span><br><span class="line">#### 看完这本书，有什么感想，有什么值得学习的，这里就可以随便写了。</span><br><span class="line">###  相关</span><br><span class="line">#### 可以列出相关的看过的书籍，或者问题参考链接网页一类的。</span><br></pre></td></tr></table></figure><h2 id="主题阅读"><a class="header-anchor" href="#主题阅读"></a>主题阅读</h2><p>主题阅读笔记以辩证笔记为主，结构笔记为辅。通常是围绕一个主题，引出不同作者的观点，整理各个作者之间的观点联系和区别。加上结构上整理，列出主题架构。可以说，主题笔记写好了相当于一本新的论述性书籍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好的笔记能体现出一本书的核心思想，能表达自己的心得体会，能帮助你快速回忆巩固。(•̀⌄•́)&lt;br&gt;
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　——　By Jihan&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;不同的书有不同的笔记方法，特定框架能更快速的明确笔记目的——读《如何阅读一本书》后所得&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
